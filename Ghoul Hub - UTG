-- Ghoul Hub - UTG
-- Made by Ghoul Scripts
-- Netless by Ace
-- Subscribe to my YouTube channel : https://www.youtube.com/channel/UCqiDt4odmGjSGfj58XX5oAg

-- Instances:

local ScreenGui = Instance.new("ScreenGui")
local Main = Instance.new("Frame")
local RoundedBG = Instance.new("UICorner")
local Pages = Instance.new("Frame")
local Page1 = Instance.new("Frame")
local NekoMaid = Instance.new("TextButton")
local RoundedBG_2 = Instance.new("UICorner")
local GaleFighter = Instance.new("TextButton")
local RoundedBG_3 = Instance.new("UICorner")
local ServerAdmin = Instance.new("TextButton")
local RoundedBG_4 = Instance.new("UICorner")
local Flash = Instance.new("TextButton")
local RoundedBG_5 = Instance.new("UICorner")
local UltimateMemeDance = Instance.new("TextButton")
local RoundedBG_6 = Instance.new("UICorner")
local Chips = Instance.new("TextButton")
local RoundedBG_7 = Instance.new("UICorner")
local AmongUs = Instance.new("TextButton")
local RoundedBG_8 = Instance.new("UICorner")
local Joy = Instance.new("TextButton")
local RoundedBG_9 = Instance.new("UICorner")
local ParkourGod = Instance.new("TextButton")
local RoundedBG_10 = Instance.new("UICorner")
local Killbot = Instance.new("TextButton")
local RoundedBG_11 = Instance.new("UICorner")
local PageNumber = Instance.new("TextButton")
local Page = Instance.new("TextButton")
local RoundedBG_12 = Instance.new("UICorner")
local Smug = Instance.new("TextButton")
local RoundedBG_13 = Instance.new("UICorner")
local Ender = Instance.new("TextButton")
local RoundedBG_14 = Instance.new("UICorner")
local Page2 = Instance.new("Frame")
local Spider = Instance.new("TextButton")
local RoundedBG_15 = Instance.new("UICorner")
local Sonic = Instance.new("TextButton")
local RoundedBG_16 = Instance.new("UICorner")
local ButtonName = Instance.new("TextButton")
local RoundedBG_17 = Instance.new("UICorner")
local ButtonName_2 = Instance.new("TextButton")
local RoundedBG_18 = Instance.new("UICorner")
local ButtonName_3 = Instance.new("TextButton")
local RoundedBG_19 = Instance.new("UICorner")
local ButtonName_4 = Instance.new("TextButton")
local RoundedBG_20 = Instance.new("UICorner")
local ButtonName_5 = Instance.new("TextButton")
local RoundedBG_21 = Instance.new("UICorner")
local ButtonName_6 = Instance.new("TextButton")
local RoundedBG_22 = Instance.new("UICorner")
local ButtonName_7 = Instance.new("TextButton")
local RoundedBG_23 = Instance.new("UICorner")
local ButtonName_8 = Instance.new("TextButton")
local RoundedBG_24 = Instance.new("UICorner")
local PageNumber_2 = Instance.new("TextButton")
local Page_2 = Instance.new("TextButton")
local RoundedBG_25 = Instance.new("UICorner")
local Page_3 = Instance.new("TextButton")
local RoundedBG_26 = Instance.new("UICorner")
local ButtonName_9 = Instance.new("TextButton")
local RoundedBG_27 = Instance.new("UICorner")
local ButtonName_10 = Instance.new("TextButton")
local RoundedBG_28 = Instance.new("UICorner")
local Page4 = Instance.new("Frame")
local UtgV2 = Instance.new("TextButton")
local RoundedBG_29 = Instance.new("UICorner")
local UtgV1 = Instance.new("TextButton")
local RoundedBG_30 = Instance.new("UICorner")
local UtgReborn = Instance.new("TextButton")
local RoundedBG_31 = Instance.new("UICorner")
local Linorix = Instance.new("TextButton")
local RoundedBG_32 = Instance.new("UICorner")
local ButtonName_11 = Instance.new("TextButton")
local RoundedBG_33 = Instance.new("UICorner")
local ButtonName_12 = Instance.new("TextButton")
local RoundedBG_34 = Instance.new("UICorner")
local ButtonName_13 = Instance.new("TextButton")
local RoundedBG_35 = Instance.new("UICorner")
local ButtonName_14 = Instance.new("TextButton")
local RoundedBG_36 = Instance.new("UICorner")
local ButtonName_15 = Instance.new("TextButton")
local RoundedBG_37 = Instance.new("UICorner")
local ButtonName_16 = Instance.new("TextButton")
local RoundedBG_38 = Instance.new("UICorner")
local ButtonName_17 = Instance.new("TextButton")
local RoundedBG_39 = Instance.new("UICorner")
local ButtonName_18 = Instance.new("TextButton")
local RoundedBG_40 = Instance.new("UICorner")
local PageNumber_3 = Instance.new("TextButton")
local Page_4 = Instance.new("TextButton")
local RoundedBG_41 = Instance.new("UICorner")
local Page_5 = Instance.new("TextButton")
local RoundedBG_42 = Instance.new("UICorner")
local Page5 = Instance.new("Frame")
local ButtonName_19 = Instance.new("TextButton")
local RoundedBG_43 = Instance.new("UICorner")
local UltraClickers4 = Instance.new("TextButton")
local RoundedBG_44 = Instance.new("UICorner")
local ButtonName_20 = Instance.new("TextButton")
local RoundedBG_45 = Instance.new("UICorner")
local ButtonName_21 = Instance.new("TextButton")
local RoundedBG_46 = Instance.new("UICorner")
local ButtonName_22 = Instance.new("TextButton")
local RoundedBG_47 = Instance.new("UICorner")
local ButtonName_23 = Instance.new("TextButton")
local RoundedBG_48 = Instance.new("UICorner")
local ButtonName_24 = Instance.new("TextButton")
local RoundedBG_49 = Instance.new("UICorner")
local ButtonName_25 = Instance.new("TextButton")
local RoundedBG_50 = Instance.new("UICorner")
local ButtonName_26 = Instance.new("TextButton")
local RoundedBG_51 = Instance.new("UICorner")
local ButtonName_27 = Instance.new("TextButton")
local RoundedBG_52 = Instance.new("UICorner")
local ButtonName_28 = Instance.new("TextButton")
local RoundedBG_53 = Instance.new("UICorner")
local ButtonName_29 = Instance.new("TextButton")
local RoundedBG_54 = Instance.new("UICorner")
local PageNumber_4 = Instance.new("TextButton")
local Page_6 = Instance.new("TextButton")
local RoundedBG_55 = Instance.new("UICorner")
local Page3 = Instance.new("Frame")
local ButtonName_30 = Instance.new("TextButton")
local RoundedBG_56 = Instance.new("UICorner")
local ButtonName_31 = Instance.new("TextButton")
local RoundedBG_57 = Instance.new("UICorner")
local ButtonName_32 = Instance.new("TextButton")
local RoundedBG_58 = Instance.new("UICorner")
local ButtonName_33 = Instance.new("TextButton")
local RoundedBG_59 = Instance.new("UICorner")
local ButtonName_34 = Instance.new("TextButton")
local RoundedBG_60 = Instance.new("UICorner")
local ButtonName_35 = Instance.new("TextButton")
local RoundedBG_61 = Instance.new("UICorner")
local ButtonName_36 = Instance.new("TextButton")
local RoundedBG_62 = Instance.new("UICorner")
local ButtonName_37 = Instance.new("TextButton")
local RoundedBG_63 = Instance.new("UICorner")
local ButtonName_38 = Instance.new("TextButton")
local RoundedBG_64 = Instance.new("UICorner")
local ButtonName_39 = Instance.new("TextButton")
local RoundedBG_65 = Instance.new("UICorner")
local PageNumber_5 = Instance.new("TextButton")
local Page_7 = Instance.new("TextButton")
local RoundedBG_66 = Instance.new("UICorner")
local Page_8 = Instance.new("TextButton")
local RoundedBG_67 = Instance.new("UICorner")
local ButtonName_40 = Instance.new("TextButton")
local RoundedBG_68 = Instance.new("UICorner")
local ButtonName_41 = Instance.new("TextButton")
local RoundedBG_69 = Instance.new("UICorner")
local Close = Instance.new("TextButton")
local RoundedBG_70 = Instance.new("UICorner")
local Separator = Instance.new("TextButton")
local UICorner = Instance.new("UICorner")
local Title = Instance.new("TextLabel")
local Version = Instance.new("TextLabel")
local Netless = Instance.new("TextButton")
local RoundedBG_71 = Instance.new("UICorner")
local Respawn = Instance.new("TextButton")
local RoundedBG_72 = Instance.new("UICorner")
local AntiFling = Instance.new("TextButton")
local RoundedBG_73 = Instance.new("UICorner")

--Properties:

ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
ScreenGui.ResetOnSpawn = false

Main.Name = "Main"
Main.Parent = ScreenGui
Main.Active = true
Main.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Main.Position = UDim2.new(0.36500001, 0, 0.224999994, 0)
Main.Size = UDim2.new(0, 550, 0, 310)

RoundedBG.Name = "RoundedBG"
RoundedBG.Parent = Main

Pages.Name = "Pages"
Pages.Parent = Main
Pages.Active = true
Pages.BackgroundColor3 = Color3.fromRGB(255, 255, 235)
Pages.BackgroundTransparency = 1.000
Pages.BorderSizePixel = 0
Pages.ClipsDescendants = true
Pages.Position = UDim2.new(0, -2, 0, 2)
Pages.Selectable = true
Pages.Size = UDim2.new(1, 0, 1, 0)
Pages.ZIndex = 2

Page1.Name = "Page1"
Page1.Parent = Pages
Page1.Active = true
Page1.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Page1.BackgroundTransparency = 1.000
Page1.BorderSizePixel = 0
Page1.Position = UDim2.new(0, 0, 0.300000012, 0)
Page1.Size = UDim2.new(1, 0, 0.600000024, 0)

NekoMaid.Name = "NekoMaid"
NekoMaid.Parent = Page1
NekoMaid.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
NekoMaid.BorderSizePixel = 0
NekoMaid.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
NekoMaid.Size = UDim2.new(0, 110, 0, 48)
NekoMaid.ZIndex = 7
NekoMaid.Font = Enum.Font.SourceSansBold
NekoMaid.Text = "Neko Maid"
NekoMaid.TextColor3 = Color3.fromRGB(61, 61, 61)
NekoMaid.TextSize = 18.000
NekoMaid.TextWrapped = true

RoundedBG_2.CornerRadius = UDim.new(0, 9)
RoundedBG_2.Name = "RoundedBG"
RoundedBG_2.Parent = NekoMaid

GaleFighter.Name = "GaleFighter"
GaleFighter.Parent = Page1
GaleFighter.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
GaleFighter.BorderSizePixel = 0
GaleFighter.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
GaleFighter.Size = UDim2.new(0, 110, 0, 48)
GaleFighter.ZIndex = 7
GaleFighter.Font = Enum.Font.SourceSansBold
GaleFighter.Text = "Gale Fighter"
GaleFighter.TextColor3 = Color3.fromRGB(61, 61, 61)
GaleFighter.TextSize = 18.000
GaleFighter.TextWrapped = true

RoundedBG_3.CornerRadius = UDim.new(0, 9)
RoundedBG_3.Name = "RoundedBG"
RoundedBG_3.Parent = GaleFighter

ServerAdmin.Name = "ServerAdmin"
ServerAdmin.Parent = Page1
ServerAdmin.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ServerAdmin.BorderSizePixel = 0
ServerAdmin.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
ServerAdmin.Size = UDim2.new(0, 110, 0, 48)
ServerAdmin.ZIndex = 7
ServerAdmin.Font = Enum.Font.SourceSansBold
ServerAdmin.Text = "Server Admin"
ServerAdmin.TextColor3 = Color3.fromRGB(61, 61, 61)
ServerAdmin.TextSize = 18.000
ServerAdmin.TextWrapped = true

RoundedBG_4.CornerRadius = UDim.new(0, 9)
RoundedBG_4.Name = "RoundedBG"
RoundedBG_4.Parent = ServerAdmin

Flash.Name = "Flash"
Flash.Parent = Page1
Flash.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Flash.BorderSizePixel = 0
Flash.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
Flash.Size = UDim2.new(0, 110, 0, 48)
Flash.ZIndex = 7
Flash.Font = Enum.Font.SourceSansBold
Flash.Text = "Flash"
Flash.TextColor3 = Color3.fromRGB(61, 61, 61)
Flash.TextSize = 18.000
Flash.TextWrapped = true

RoundedBG_5.CornerRadius = UDim.new(0, 9)
RoundedBG_5.Name = "RoundedBG"
RoundedBG_5.Parent = Flash

UltimateMemeDance.Name = "UltimateMemeDance"
UltimateMemeDance.Parent = Page1
UltimateMemeDance.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
UltimateMemeDance.BorderSizePixel = 0
UltimateMemeDance.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
UltimateMemeDance.Size = UDim2.new(0, 110, 0, 48)
UltimateMemeDance.ZIndex = 7
UltimateMemeDance.Font = Enum.Font.SourceSansBold
UltimateMemeDance.Text = "Ultimate Meme Dance"
UltimateMemeDance.TextColor3 = Color3.fromRGB(61, 61, 61)
UltimateMemeDance.TextSize = 18.000
UltimateMemeDance.TextWrapped = true

RoundedBG_6.CornerRadius = UDim.new(0, 9)
RoundedBG_6.Name = "RoundedBG"
RoundedBG_6.Parent = UltimateMemeDance

Chips.Name = "Chips"
Chips.Parent = Page1
Chips.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Chips.BorderSizePixel = 0
Chips.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
Chips.Size = UDim2.new(0, 110, 0, 48)
Chips.ZIndex = 7
Chips.Font = Enum.Font.SourceSansBold
Chips.Text = "Chips"
Chips.TextColor3 = Color3.fromRGB(61, 61, 61)
Chips.TextSize = 18.000
Chips.TextWrapped = true

RoundedBG_7.CornerRadius = UDim.new(0, 9)
RoundedBG_7.Name = "RoundedBG"
RoundedBG_7.Parent = Chips

AmongUs.Name = "AmongUs"
AmongUs.Parent = Page1
AmongUs.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
AmongUs.BorderSizePixel = 0
AmongUs.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
AmongUs.Size = UDim2.new(0, 110, 0, 48)
AmongUs.ZIndex = 7
AmongUs.Font = Enum.Font.SourceSansBold
AmongUs.Text = "Amogus"
AmongUs.TextColor3 = Color3.fromRGB(61, 61, 61)
AmongUs.TextSize = 18.000
AmongUs.TextWrapped = true

RoundedBG_8.CornerRadius = UDim.new(0, 9)
RoundedBG_8.Name = "RoundedBG"
RoundedBG_8.Parent = AmongUs

Joy.Name = "Joy"
Joy.Parent = Page1
Joy.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Joy.BorderSizePixel = 0
Joy.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
Joy.Size = UDim2.new(0, 110, 0, 48)
Joy.ZIndex = 7
Joy.Font = Enum.Font.SourceSansBold
Joy.Text = ":Joy:"
Joy.TextColor3 = Color3.fromRGB(61, 61, 61)
Joy.TextSize = 18.000
Joy.TextWrapped = true

RoundedBG_9.CornerRadius = UDim.new(0, 9)
RoundedBG_9.Name = "RoundedBG"
RoundedBG_9.Parent = Joy

ParkourGod.Name = "ParkourGod"
ParkourGod.Parent = Page1
ParkourGod.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ParkourGod.BorderSizePixel = 0
ParkourGod.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
ParkourGod.Size = UDim2.new(0, 110, 0, 48)
ParkourGod.ZIndex = 7
ParkourGod.Font = Enum.Font.SourceSansBold
ParkourGod.Text = "Parkour God"
ParkourGod.TextColor3 = Color3.fromRGB(61, 61, 61)
ParkourGod.TextSize = 18.000
ParkourGod.TextWrapped = true

RoundedBG_10.CornerRadius = UDim.new(0, 9)
RoundedBG_10.Name = "RoundedBG"
RoundedBG_10.Parent = ParkourGod

Killbot.Name = "Killbot"
Killbot.Parent = Page1
Killbot.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Killbot.BorderSizePixel = 0
Killbot.Position = UDim2.new(0.75999999, 10, 1.875, -280)
Killbot.Size = UDim2.new(0, 110, 0, 48)
Killbot.ZIndex = 7
Killbot.Font = Enum.Font.SourceSansBold
Killbot.Text = "Killbot"
Killbot.TextColor3 = Color3.fromRGB(61, 61, 61)
Killbot.TextSize = 18.000
Killbot.TextWrapped = true

RoundedBG_11.CornerRadius = UDim.new(0, 9)
RoundedBG_11.Name = "RoundedBG"
RoundedBG_11.Parent = Killbot

PageNumber.Name = "Page Number"
PageNumber.Parent = Page1
PageNumber.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PageNumber.BackgroundTransparency = 1.000
PageNumber.Position = UDim2.new(0.00400002208, 10, 2.45220447, -280)
PageNumber.Size = UDim2.new(0, 525, 0, 32)
PageNumber.ZIndex = 8
PageNumber.Font = Enum.Font.SourceSansBold
PageNumber.Text = "[ FE ] FREE SCRIPTS"
PageNumber.TextColor3 = Color3.fromRGB(61, 61, 61)
PageNumber.TextSize = 22.000
PageNumber.TextWrapped = true

Page.Name = "Page>"
Page.Parent = Page1
Page.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page.BorderSizePixel = 0
Page.Position = UDim2.new(0.785999954, 10, 1.04301071, -280)
Page.Size = UDim2.new(0, 44, 0, 32)
Page.ZIndex = 7
Page.Font = Enum.Font.SourceSansBold
Page.Text = ">"
Page.TextColor3 = Color3.fromRGB(61, 61, 61)
Page.TextSize = 22.000
Page.TextWrapped = true

RoundedBG_12.CornerRadius = UDim.new(0, 9)
RoundedBG_12.Name = "RoundedBG"
RoundedBG_12.Parent = Page

Smug.Name = "Smug"
Smug.Parent = Page1
Smug.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Smug.BorderSizePixel = 0
Smug.Position = UDim2.new(0.501999974, 10, 1.875, -280)
Smug.Size = UDim2.new(0, 110, 0, 48)
Smug.ZIndex = 7
Smug.Font = Enum.Font.SourceSansBold
Smug.Text = "Smug"
Smug.TextColor3 = Color3.fromRGB(61, 61, 61)
Smug.TextSize = 18.000
Smug.TextWrapped = true

RoundedBG_13.CornerRadius = UDim.new(0, 9)
RoundedBG_13.Name = "RoundedBG"
RoundedBG_13.Parent = Smug

Ender.Name = "Ender"
Ender.Parent = Page1
Ender.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Ender.BorderSizePixel = 0
Ender.Position = UDim2.new(0.254999995, 10, 1.875, -280)
Ender.Size = UDim2.new(0, 110, 0, 48)
Ender.ZIndex = 7
Ender.Font = Enum.Font.SourceSansBold
Ender.Text = "Ender"
Ender.TextColor3 = Color3.fromRGB(61, 61, 61)
Ender.TextSize = 18.000
Ender.TextWrapped = true

RoundedBG_14.CornerRadius = UDim.new(0, 9)
RoundedBG_14.Name = "RoundedBG"
RoundedBG_14.Parent = Ender

Page2.Name = "Page2"
Page2.Parent = Pages
Page2.Active = true
Page2.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Page2.BackgroundTransparency = 1.000
Page2.BorderSizePixel = 0
Page2.Position = UDim2.new(0, 0, 0.300000012, 0)
Page2.Size = UDim2.new(1, 0, 0.600000024, 0)
Page2.Visible = false

Spider.Name = "Spider"
Spider.Parent = Page2
Spider.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Spider.BorderSizePixel = 0
Spider.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
Spider.Size = UDim2.new(0, 110, 0, 48)
Spider.ZIndex = 7
Spider.Font = Enum.Font.SourceSansBold
Spider.Text = "Spider"
Spider.TextColor3 = Color3.fromRGB(61, 61, 61)
Spider.TextSize = 18.000
Spider.TextWrapped = true

RoundedBG_15.CornerRadius = UDim.new(0, 9)
RoundedBG_15.Name = "RoundedBG"
RoundedBG_15.Parent = Spider

Sonic.Name = "Sonic"
Sonic.Parent = Page2
Sonic.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Sonic.BorderSizePixel = 0
Sonic.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
Sonic.Size = UDim2.new(0, 110, 0, 48)
Sonic.ZIndex = 7
Sonic.Font = Enum.Font.SourceSansBold
Sonic.Text = "Sonic"
Sonic.TextColor3 = Color3.fromRGB(61, 61, 61)
Sonic.TextSize = 18.000
Sonic.TextWrapped = true

RoundedBG_16.CornerRadius = UDim.new(0, 9)
RoundedBG_16.Name = "RoundedBG"
RoundedBG_16.Parent = Sonic

ButtonName.Name = "ButtonName"
ButtonName.Parent = Page2
ButtonName.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName.BorderSizePixel = 0
ButtonName.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
ButtonName.Size = UDim2.new(0, 110, 0, 48)
ButtonName.ZIndex = 7
ButtonName.Font = Enum.Font.SourceSansBold
ButtonName.Text = "Script here"
ButtonName.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName.TextSize = 18.000
ButtonName.TextWrapped = true

RoundedBG_17.CornerRadius = UDim.new(0, 9)
RoundedBG_17.Name = "RoundedBG"
RoundedBG_17.Parent = ButtonName

ButtonName_2.Name = "ButtonName"
ButtonName_2.Parent = Page2
ButtonName_2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_2.BorderSizePixel = 0
ButtonName_2.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
ButtonName_2.Size = UDim2.new(0, 110, 0, 48)
ButtonName_2.ZIndex = 7
ButtonName_2.Font = Enum.Font.SourceSansBold
ButtonName_2.Text = "Script here"
ButtonName_2.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_2.TextSize = 18.000
ButtonName_2.TextWrapped = true

RoundedBG_18.CornerRadius = UDim.new(0, 9)
RoundedBG_18.Name = "RoundedBG"
RoundedBG_18.Parent = ButtonName_2

ButtonName_3.Name = "ButtonName"
ButtonName_3.Parent = Page2
ButtonName_3.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_3.BorderSizePixel = 0
ButtonName_3.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
ButtonName_3.Size = UDim2.new(0, 110, 0, 48)
ButtonName_3.ZIndex = 7
ButtonName_3.Font = Enum.Font.SourceSansBold
ButtonName_3.Text = "Script here"
ButtonName_3.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_3.TextSize = 18.000
ButtonName_3.TextWrapped = true

RoundedBG_19.CornerRadius = UDim.new(0, 9)
RoundedBG_19.Name = "RoundedBG"
RoundedBG_19.Parent = ButtonName_3

ButtonName_4.Name = "ButtonName"
ButtonName_4.Parent = Page2
ButtonName_4.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_4.BorderSizePixel = 0
ButtonName_4.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
ButtonName_4.Size = UDim2.new(0, 110, 0, 48)
ButtonName_4.ZIndex = 7
ButtonName_4.Font = Enum.Font.SourceSansBold
ButtonName_4.Text = "Script here"
ButtonName_4.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_4.TextSize = 18.000
ButtonName_4.TextWrapped = true

RoundedBG_20.CornerRadius = UDim.new(0, 9)
RoundedBG_20.Name = "RoundedBG"
RoundedBG_20.Parent = ButtonName_4

ButtonName_5.Name = "ButtonName"
ButtonName_5.Parent = Page2
ButtonName_5.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_5.BorderSizePixel = 0
ButtonName_5.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
ButtonName_5.Size = UDim2.new(0, 110, 0, 48)
ButtonName_5.ZIndex = 7
ButtonName_5.Font = Enum.Font.SourceSansBold
ButtonName_5.Text = "Script here"
ButtonName_5.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_5.TextSize = 18.000
ButtonName_5.TextWrapped = true

RoundedBG_21.CornerRadius = UDim.new(0, 9)
RoundedBG_21.Name = "RoundedBG"
RoundedBG_21.Parent = ButtonName_5

ButtonName_6.Name = "ButtonName"
ButtonName_6.Parent = Page2
ButtonName_6.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_6.BorderSizePixel = 0
ButtonName_6.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
ButtonName_6.Size = UDim2.new(0, 110, 0, 48)
ButtonName_6.ZIndex = 7
ButtonName_6.Font = Enum.Font.SourceSansBold
ButtonName_6.Text = "Script here"
ButtonName_6.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_6.TextSize = 18.000
ButtonName_6.TextWrapped = true

RoundedBG_22.CornerRadius = UDim.new(0, 9)
RoundedBG_22.Name = "RoundedBG"
RoundedBG_22.Parent = ButtonName_6

ButtonName_7.Name = "ButtonName"
ButtonName_7.Parent = Page2
ButtonName_7.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_7.BorderSizePixel = 0
ButtonName_7.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
ButtonName_7.Size = UDim2.new(0, 110, 0, 48)
ButtonName_7.ZIndex = 7
ButtonName_7.Font = Enum.Font.SourceSansBold
ButtonName_7.Text = "Script here"
ButtonName_7.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_7.TextSize = 18.000
ButtonName_7.TextWrapped = true

RoundedBG_23.CornerRadius = UDim.new(0, 9)
RoundedBG_23.Name = "RoundedBG"
RoundedBG_23.Parent = ButtonName_7

ButtonName_8.Name = "ButtonName"
ButtonName_8.Parent = Page2
ButtonName_8.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_8.BorderSizePixel = 0
ButtonName_8.Position = UDim2.new(0.75999999, 10, 1.875, -280)
ButtonName_8.Size = UDim2.new(0, 110, 0, 48)
ButtonName_8.ZIndex = 7
ButtonName_8.Font = Enum.Font.SourceSansBold
ButtonName_8.Text = "Script here"
ButtonName_8.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_8.TextSize = 18.000
ButtonName_8.TextWrapped = true

RoundedBG_24.CornerRadius = UDim.new(0, 9)
RoundedBG_24.Name = "RoundedBG"
RoundedBG_24.Parent = ButtonName_8

PageNumber_2.Name = "Page Number"
PageNumber_2.Parent = Page2
PageNumber_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PageNumber_2.BackgroundTransparency = 1.000
PageNumber_2.Position = UDim2.new(0.00763638597, 10, 2.45220447, -280)
PageNumber_2.Size = UDim2.new(0, 523, 0, 32)
PageNumber_2.ZIndex = 8
PageNumber_2.Font = Enum.Font.SourceSansBold
PageNumber_2.Text = "[ FE ] FREE SCRIPTS"
PageNumber_2.TextColor3 = Color3.fromRGB(61, 61, 61)
PageNumber_2.TextSize = 22.000
PageNumber_2.TextWrapped = true

Page_2.Name = "Page<"
Page_2.Parent = Page2
Page_2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_2.BorderSizePixel = 0
Page_2.Position = UDim2.new(0.69599998, 10, 1.04301071, -280)
Page_2.Size = UDim2.new(0, 44, 0, 32)
Page_2.ZIndex = 7
Page_2.Font = Enum.Font.SourceSansBold
Page_2.Text = "<"
Page_2.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_2.TextSize = 22.000
Page_2.TextWrapped = true

RoundedBG_25.CornerRadius = UDim.new(0, 9)
RoundedBG_25.Name = "RoundedBG"
RoundedBG_25.Parent = Page_2

Page_3.Name = "Page>"
Page_3.Parent = Page2
Page_3.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_3.BorderSizePixel = 0
Page_3.Position = UDim2.new(0.785999954, 10, 1.04301071, -280)
Page_3.Size = UDim2.new(0, 44, 0, 32)
Page_3.ZIndex = 7
Page_3.Font = Enum.Font.SourceSansBold
Page_3.Text = ">"
Page_3.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_3.TextSize = 22.000
Page_3.TextWrapped = true

RoundedBG_26.CornerRadius = UDim.new(0, 9)
RoundedBG_26.Name = "RoundedBG"
RoundedBG_26.Parent = Page_3

ButtonName_9.Name = "ButtonName"
ButtonName_9.Parent = Page2
ButtonName_9.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_9.BorderSizePixel = 0
ButtonName_9.Position = UDim2.new(0.501999974, 10, 1.875, -280)
ButtonName_9.Size = UDim2.new(0, 110, 0, 48)
ButtonName_9.ZIndex = 7
ButtonName_9.Font = Enum.Font.SourceSansBold
ButtonName_9.Text = "Script here"
ButtonName_9.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_9.TextSize = 18.000
ButtonName_9.TextWrapped = true

RoundedBG_27.CornerRadius = UDim.new(0, 9)
RoundedBG_27.Name = "RoundedBG"
RoundedBG_27.Parent = ButtonName_9

ButtonName_10.Name = "ButtonName"
ButtonName_10.Parent = Page2
ButtonName_10.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_10.BorderSizePixel = 0
ButtonName_10.Position = UDim2.new(0.254999995, 10, 1.875, -280)
ButtonName_10.Size = UDim2.new(0, 110, 0, 48)
ButtonName_10.ZIndex = 7
ButtonName_10.Font = Enum.Font.SourceSansBold
ButtonName_10.Text = "Script here"
ButtonName_10.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_10.TextSize = 18.000
ButtonName_10.TextWrapped = true

RoundedBG_28.CornerRadius = UDim.new(0, 9)
RoundedBG_28.Name = "RoundedBG"
RoundedBG_28.Parent = ButtonName_10

Page4.Name = "Page4"
Page4.Parent = Pages
Page4.Active = true
Page4.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Page4.BackgroundTransparency = 1.000
Page4.BorderSizePixel = 0
Page4.Position = UDim2.new(0, 0, 0.300000012, 0)
Page4.Size = UDim2.new(1, 0, 0.600000024, 0)
Page4.Visible = false

UtgV2.Name = "UtgV2"
UtgV2.Parent = Page4
UtgV2.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
UtgV2.BorderSizePixel = 0
UtgV2.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
UtgV2.Size = UDim2.new(0, 110, 0, 48)
UtgV2.ZIndex = 7
UtgV2.Font = Enum.Font.SourceSansBold
UtgV2.Text = "UTG V2"
UtgV2.TextColor3 = Color3.fromRGB(61, 61, 61)
UtgV2.TextSize = 18.000
UtgV2.TextWrapped = true

RoundedBG_29.CornerRadius = UDim.new(0, 9)
RoundedBG_29.Name = "RoundedBG"
RoundedBG_29.Parent = UtgV2

UtgV1.Name = "UtgV1"
UtgV1.Parent = Page4
UtgV1.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
UtgV1.BorderSizePixel = 0
UtgV1.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
UtgV1.Size = UDim2.new(0, 110, 0, 48)
UtgV1.ZIndex = 7
UtgV1.Font = Enum.Font.SourceSansBold
UtgV1.Text = "UTG V1"
UtgV1.TextColor3 = Color3.fromRGB(61, 61, 61)
UtgV1.TextSize = 18.000
UtgV1.TextWrapped = true

RoundedBG_30.CornerRadius = UDim.new(0, 9)
RoundedBG_30.Name = "RoundedBG"
RoundedBG_30.Parent = UtgV1

UtgReborn.Name = "UtgReborn"
UtgReborn.Parent = Page4
UtgReborn.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
UtgReborn.BorderSizePixel = 0
UtgReborn.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
UtgReborn.Size = UDim2.new(0, 110, 0, 48)
UtgReborn.ZIndex = 7
UtgReborn.Font = Enum.Font.SourceSansBold
UtgReborn.Text = "UTG Reborn"
UtgReborn.TextColor3 = Color3.fromRGB(61, 61, 61)
UtgReborn.TextSize = 18.000
UtgReborn.TextWrapped = true

RoundedBG_31.CornerRadius = UDim.new(0, 9)
RoundedBG_31.Name = "RoundedBG"
RoundedBG_31.Parent = UtgReborn

Linorix.Name = "Linorix"
Linorix.Parent = Page4
Linorix.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Linorix.BorderSizePixel = 0
Linorix.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
Linorix.Size = UDim2.new(0, 110, 0, 48)
Linorix.ZIndex = 7
Linorix.Font = Enum.Font.SourceSansBold
Linorix.Text = "Linorix Hub"
Linorix.TextColor3 = Color3.fromRGB(61, 61, 61)
Linorix.TextSize = 18.000
Linorix.TextWrapped = true

RoundedBG_32.CornerRadius = UDim.new(0, 9)
RoundedBG_32.Name = "RoundedBG"
RoundedBG_32.Parent = Linorix

ButtonName_11.Name = "ButtonName"
ButtonName_11.Parent = Page4
ButtonName_11.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_11.BorderSizePixel = 0
ButtonName_11.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
ButtonName_11.Size = UDim2.new(0, 110, 0, 48)
ButtonName_11.ZIndex = 7
ButtonName_11.Font = Enum.Font.SourceSansBold
ButtonName_11.Text = "Script here"
ButtonName_11.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_11.TextSize = 18.000
ButtonName_11.TextWrapped = true

RoundedBG_33.CornerRadius = UDim.new(0, 9)
RoundedBG_33.Name = "RoundedBG"
RoundedBG_33.Parent = ButtonName_11

ButtonName_12.Name = "ButtonName"
ButtonName_12.Parent = Page4
ButtonName_12.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_12.BorderSizePixel = 0
ButtonName_12.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
ButtonName_12.Size = UDim2.new(0, 110, 0, 48)
ButtonName_12.ZIndex = 7
ButtonName_12.Font = Enum.Font.SourceSansBold
ButtonName_12.Text = "Script here"
ButtonName_12.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_12.TextSize = 18.000
ButtonName_12.TextWrapped = true

RoundedBG_34.CornerRadius = UDim.new(0, 9)
RoundedBG_34.Name = "RoundedBG"
RoundedBG_34.Parent = ButtonName_12

ButtonName_13.Name = "ButtonName"
ButtonName_13.Parent = Page4
ButtonName_13.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_13.BorderSizePixel = 0
ButtonName_13.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
ButtonName_13.Size = UDim2.new(0, 110, 0, 48)
ButtonName_13.ZIndex = 7
ButtonName_13.Font = Enum.Font.SourceSansBold
ButtonName_13.Text = "Script here"
ButtonName_13.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_13.TextSize = 18.000
ButtonName_13.TextWrapped = true

RoundedBG_35.CornerRadius = UDim.new(0, 9)
RoundedBG_35.Name = "RoundedBG"
RoundedBG_35.Parent = ButtonName_13

ButtonName_14.Name = "ButtonName"
ButtonName_14.Parent = Page4
ButtonName_14.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_14.BorderSizePixel = 0
ButtonName_14.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
ButtonName_14.Size = UDim2.new(0, 110, 0, 48)
ButtonName_14.ZIndex = 7
ButtonName_14.Font = Enum.Font.SourceSansBold
ButtonName_14.Text = "Script here"
ButtonName_14.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_14.TextSize = 18.000
ButtonName_14.TextWrapped = true

RoundedBG_36.CornerRadius = UDim.new(0, 9)
RoundedBG_36.Name = "RoundedBG"
RoundedBG_36.Parent = ButtonName_14

ButtonName_15.Name = "ButtonName"
ButtonName_15.Parent = Page4
ButtonName_15.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_15.BorderSizePixel = 0
ButtonName_15.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
ButtonName_15.Size = UDim2.new(0, 110, 0, 48)
ButtonName_15.ZIndex = 7
ButtonName_15.Font = Enum.Font.SourceSansBold
ButtonName_15.Text = "Script here"
ButtonName_15.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_15.TextSize = 18.000
ButtonName_15.TextWrapped = true

RoundedBG_37.CornerRadius = UDim.new(0, 9)
RoundedBG_37.Name = "RoundedBG"
RoundedBG_37.Parent = ButtonName_15

ButtonName_16.Name = "ButtonName"
ButtonName_16.Parent = Page4
ButtonName_16.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_16.BorderSizePixel = 0
ButtonName_16.Position = UDim2.new(0.75999999, 10, 1.875, -280)
ButtonName_16.Size = UDim2.new(0, 110, 0, 48)
ButtonName_16.ZIndex = 7
ButtonName_16.Font = Enum.Font.SourceSansBold
ButtonName_16.Text = "Script here"
ButtonName_16.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_16.TextSize = 18.000
ButtonName_16.TextWrapped = true

RoundedBG_38.CornerRadius = UDim.new(0, 9)
RoundedBG_38.Name = "RoundedBG"
RoundedBG_38.Parent = ButtonName_16

ButtonName_17.Name = "ButtonName"
ButtonName_17.Parent = Page4
ButtonName_17.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_17.BorderSizePixel = 0
ButtonName_17.Position = UDim2.new(0.501999974, 10, 1.875, -280)
ButtonName_17.Size = UDim2.new(0, 110, 0, 48)
ButtonName_17.ZIndex = 7
ButtonName_17.Font = Enum.Font.SourceSansBold
ButtonName_17.Text = "Script here"
ButtonName_17.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_17.TextSize = 18.000
ButtonName_17.TextWrapped = true

RoundedBG_39.CornerRadius = UDim.new(0, 9)
RoundedBG_39.Name = "RoundedBG"
RoundedBG_39.Parent = ButtonName_17

ButtonName_18.Name = "ButtonName"
ButtonName_18.Parent = Page4
ButtonName_18.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_18.BorderSizePixel = 0
ButtonName_18.Position = UDim2.new(0.254999995, 10, 1.875, -280)
ButtonName_18.Size = UDim2.new(0, 110, 0, 48)
ButtonName_18.ZIndex = 7
ButtonName_18.Font = Enum.Font.SourceSansBold
ButtonName_18.Text = "Script here"
ButtonName_18.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_18.TextSize = 18.000
ButtonName_18.TextWrapped = true

RoundedBG_40.CornerRadius = UDim.new(0, 9)
RoundedBG_40.Name = "RoundedBG"
RoundedBG_40.Parent = ButtonName_18

PageNumber_3.Name = "Page Number"
PageNumber_3.Parent = Page4
PageNumber_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PageNumber_3.BackgroundTransparency = 1.000
PageNumber_3.Position = UDim2.new(0.00763638597, 10, 2.45220447, -280)
PageNumber_3.Size = UDim2.new(0, 523, 0, 32)
PageNumber_3.ZIndex = 8
PageNumber_3.Font = Enum.Font.SourceSansBold
PageNumber_3.Text = "HUBS"
PageNumber_3.TextColor3 = Color3.fromRGB(61, 61, 61)
PageNumber_3.TextSize = 22.000
PageNumber_3.TextWrapped = true

Page_4.Name = "Page<"
Page_4.Parent = Page4
Page_4.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_4.BorderSizePixel = 0
Page_4.Position = UDim2.new(0.69599998, 10, 1.04301071, -280)
Page_4.Size = UDim2.new(0, 44, 0, 32)
Page_4.ZIndex = 7
Page_4.Font = Enum.Font.SourceSansBold
Page_4.Text = "<"
Page_4.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_4.TextSize = 22.000
Page_4.TextWrapped = true

RoundedBG_41.CornerRadius = UDim.new(0, 9)
RoundedBG_41.Name = "RoundedBG"
RoundedBG_41.Parent = Page_4

Page_5.Name = "Page>"
Page_5.Parent = Page4
Page_5.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_5.BorderSizePixel = 0
Page_5.Position = UDim2.new(0.785999954, 10, 1.04301071, -280)
Page_5.Size = UDim2.new(0, 44, 0, 32)
Page_5.ZIndex = 7
Page_5.Font = Enum.Font.SourceSansBold
Page_5.Text = ">"
Page_5.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_5.TextSize = 22.000
Page_5.TextWrapped = true

RoundedBG_42.CornerRadius = UDim.new(0, 9)
RoundedBG_42.Name = "RoundedBG"
RoundedBG_42.Parent = Page_5

Page5.Name = "Page5"
Page5.Parent = Pages
Page5.Active = true
Page5.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Page5.BackgroundTransparency = 1.000
Page5.BorderSizePixel = 0
Page5.Position = UDim2.new(0, 0, 0.300000012, 0)
Page5.Size = UDim2.new(1, 0, 0.600000024, 0)
Page5.Visible = false

ButtonName_19.Name = "ButtonName"
ButtonName_19.Parent = Page5
ButtonName_19.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_19.BorderSizePixel = 0
ButtonName_19.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
ButtonName_19.Size = UDim2.new(0, 110, 0, 48)
ButtonName_19.ZIndex = 7
ButtonName_19.Font = Enum.Font.SourceSansBold
ButtonName_19.Text = "Script here"
ButtonName_19.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_19.TextSize = 18.000
ButtonName_19.TextWrapped = true

RoundedBG_43.CornerRadius = UDim.new(0, 9)
RoundedBG_43.Name = "RoundedBG"
RoundedBG_43.Parent = ButtonName_19

UltraClickers4.Name = "UltraClickers4"
UltraClickers4.Parent = Page5
UltraClickers4.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
UltraClickers4.BorderSizePixel = 0
UltraClickers4.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
UltraClickers4.Size = UDim2.new(0, 110, 0, 48)
UltraClickers4.ZIndex = 7
UltraClickers4.Font = Enum.Font.SourceSansBold
UltraClickers4.Text = "Ultra Clickers 4"
UltraClickers4.TextColor3 = Color3.fromRGB(61, 61, 61)
UltraClickers4.TextSize = 18.000
UltraClickers4.TextWrapped = true

RoundedBG_44.CornerRadius = UDim.new(0, 9)
RoundedBG_44.Name = "RoundedBG"
RoundedBG_44.Parent = UltraClickers4

ButtonName_20.Name = "ButtonName"
ButtonName_20.Parent = Page5
ButtonName_20.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_20.BorderSizePixel = 0
ButtonName_20.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
ButtonName_20.Size = UDim2.new(0, 110, 0, 48)
ButtonName_20.ZIndex = 7
ButtonName_20.Font = Enum.Font.SourceSansBold
ButtonName_20.Text = "Script here"
ButtonName_20.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_20.TextSize = 18.000
ButtonName_20.TextWrapped = true

RoundedBG_45.CornerRadius = UDim.new(0, 9)
RoundedBG_45.Name = "RoundedBG"
RoundedBG_45.Parent = ButtonName_20

ButtonName_21.Name = "ButtonName"
ButtonName_21.Parent = Page5
ButtonName_21.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_21.BorderSizePixel = 0
ButtonName_21.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
ButtonName_21.Size = UDim2.new(0, 110, 0, 48)
ButtonName_21.ZIndex = 7
ButtonName_21.Font = Enum.Font.SourceSansBold
ButtonName_21.Text = "Script here"
ButtonName_21.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_21.TextSize = 18.000
ButtonName_21.TextWrapped = true

RoundedBG_46.CornerRadius = UDim.new(0, 9)
RoundedBG_46.Name = "RoundedBG"
RoundedBG_46.Parent = ButtonName_21

ButtonName_22.Name = "ButtonName"
ButtonName_22.Parent = Page5
ButtonName_22.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_22.BorderSizePixel = 0
ButtonName_22.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
ButtonName_22.Size = UDim2.new(0, 110, 0, 48)
ButtonName_22.ZIndex = 7
ButtonName_22.Font = Enum.Font.SourceSansBold
ButtonName_22.Text = "Script here"
ButtonName_22.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_22.TextSize = 18.000
ButtonName_22.TextWrapped = true

RoundedBG_47.CornerRadius = UDim.new(0, 9)
RoundedBG_47.Name = "RoundedBG"
RoundedBG_47.Parent = ButtonName_22

ButtonName_23.Name = "ButtonName"
ButtonName_23.Parent = Page5
ButtonName_23.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_23.BorderSizePixel = 0
ButtonName_23.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
ButtonName_23.Size = UDim2.new(0, 110, 0, 48)
ButtonName_23.ZIndex = 7
ButtonName_23.Font = Enum.Font.SourceSansBold
ButtonName_23.Text = "Script here"
ButtonName_23.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_23.TextSize = 18.000
ButtonName_23.TextWrapped = true

RoundedBG_48.CornerRadius = UDim.new(0, 9)
RoundedBG_48.Name = "RoundedBG"
RoundedBG_48.Parent = ButtonName_23

ButtonName_24.Name = "ButtonName"
ButtonName_24.Parent = Page5
ButtonName_24.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_24.BorderSizePixel = 0
ButtonName_24.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
ButtonName_24.Size = UDim2.new(0, 110, 0, 48)
ButtonName_24.ZIndex = 7
ButtonName_24.Font = Enum.Font.SourceSansBold
ButtonName_24.Text = "Script here"
ButtonName_24.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_24.TextSize = 18.000
ButtonName_24.TextWrapped = true

RoundedBG_49.CornerRadius = UDim.new(0, 9)
RoundedBG_49.Name = "RoundedBG"
RoundedBG_49.Parent = ButtonName_24

ButtonName_25.Name = "ButtonName"
ButtonName_25.Parent = Page5
ButtonName_25.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_25.BorderSizePixel = 0
ButtonName_25.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
ButtonName_25.Size = UDim2.new(0, 110, 0, 48)
ButtonName_25.ZIndex = 7
ButtonName_25.Font = Enum.Font.SourceSansBold
ButtonName_25.Text = "Script here"
ButtonName_25.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_25.TextSize = 18.000
ButtonName_25.TextWrapped = true

RoundedBG_50.CornerRadius = UDim.new(0, 9)
RoundedBG_50.Name = "RoundedBG"
RoundedBG_50.Parent = ButtonName_25

ButtonName_26.Name = "ButtonName"
ButtonName_26.Parent = Page5
ButtonName_26.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_26.BorderSizePixel = 0
ButtonName_26.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
ButtonName_26.Size = UDim2.new(0, 110, 0, 48)
ButtonName_26.ZIndex = 7
ButtonName_26.Font = Enum.Font.SourceSansBold
ButtonName_26.Text = "Script here"
ButtonName_26.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_26.TextSize = 18.000
ButtonName_26.TextWrapped = true

RoundedBG_51.CornerRadius = UDim.new(0, 9)
RoundedBG_51.Name = "RoundedBG"
RoundedBG_51.Parent = ButtonName_26

ButtonName_27.Name = "ButtonName"
ButtonName_27.Parent = Page5
ButtonName_27.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_27.BorderSizePixel = 0
ButtonName_27.Position = UDim2.new(0.75999999, 10, 1.875, -280)
ButtonName_27.Size = UDim2.new(0, 110, 0, 48)
ButtonName_27.ZIndex = 7
ButtonName_27.Font = Enum.Font.SourceSansBold
ButtonName_27.Text = "Script here"
ButtonName_27.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_27.TextSize = 18.000
ButtonName_27.TextWrapped = true

RoundedBG_52.CornerRadius = UDim.new(0, 9)
RoundedBG_52.Name = "RoundedBG"
RoundedBG_52.Parent = ButtonName_27

ButtonName_28.Name = "ButtonName"
ButtonName_28.Parent = Page5
ButtonName_28.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_28.BorderSizePixel = 0
ButtonName_28.Position = UDim2.new(0.501999974, 10, 1.875, -280)
ButtonName_28.Size = UDim2.new(0, 110, 0, 48)
ButtonName_28.ZIndex = 7
ButtonName_28.Font = Enum.Font.SourceSansBold
ButtonName_28.Text = "Script here"
ButtonName_28.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_28.TextSize = 18.000
ButtonName_28.TextWrapped = true

RoundedBG_53.CornerRadius = UDim.new(0, 9)
RoundedBG_53.Name = "RoundedBG"
RoundedBG_53.Parent = ButtonName_28

ButtonName_29.Name = "ButtonName"
ButtonName_29.Parent = Page5
ButtonName_29.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_29.BorderSizePixel = 0
ButtonName_29.Position = UDim2.new(0.254999995, 10, 1.875, -280)
ButtonName_29.Size = UDim2.new(0, 110, 0, 48)
ButtonName_29.ZIndex = 7
ButtonName_29.Font = Enum.Font.SourceSansBold
ButtonName_29.Text = "Script here"
ButtonName_29.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_29.TextSize = 18.000
ButtonName_29.TextWrapped = true

RoundedBG_54.CornerRadius = UDim.new(0, 9)
RoundedBG_54.Name = "RoundedBG"
RoundedBG_54.Parent = ButtonName_29

PageNumber_4.Name = "Page Number"
PageNumber_4.Parent = Page5
PageNumber_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PageNumber_4.BackgroundTransparency = 1.000
PageNumber_4.Position = UDim2.new(0.00763638597, 10, 2.45220447, -280)
PageNumber_4.Size = UDim2.new(0, 523, 0, 32)
PageNumber_4.ZIndex = 8
PageNumber_4.Font = Enum.Font.SourceSansBold
PageNumber_4.Text = "GAMES HUB"
PageNumber_4.TextColor3 = Color3.fromRGB(61, 61, 61)
PageNumber_4.TextSize = 22.000
PageNumber_4.TextWrapped = true

Page_6.Name = "Page<"
Page_6.Parent = Page5
Page_6.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_6.BorderSizePixel = 0
Page_6.Position = UDim2.new(0.786000013, 10, 1.04299998, -280)
Page_6.Size = UDim2.new(0, 44, 0, 32)
Page_6.ZIndex = 7
Page_6.Font = Enum.Font.SourceSansBold
Page_6.Text = "<"
Page_6.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_6.TextSize = 22.000
Page_6.TextWrapped = true

RoundedBG_55.CornerRadius = UDim.new(0, 9)
RoundedBG_55.Name = "RoundedBG"
RoundedBG_55.Parent = Page_6

Page3.Name = "Page3"
Page3.Parent = Pages
Page3.Active = true
Page3.BackgroundColor3 = Color3.fromRGB(61, 61, 61)
Page3.BackgroundTransparency = 1.000
Page3.BorderSizePixel = 0
Page3.Position = UDim2.new(0, 0, 0.300000012, 0)
Page3.Size = UDim2.new(1, 0, 0.600000024, 0)
Page3.Visible = false

ButtonName_30.Name = "ButtonName"
ButtonName_30.Parent = Page3
ButtonName_30.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_30.BorderSizePixel = 0
ButtonName_30.Position = UDim2.new(0.254999995, 10, 1.27499998, -280)
ButtonName_30.Size = UDim2.new(0, 110, 0, 48)
ButtonName_30.ZIndex = 7
ButtonName_30.Font = Enum.Font.SourceSansBold
ButtonName_30.Text = "Script here"
ButtonName_30.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_30.TextSize = 18.000
ButtonName_30.TextWrapped = true

RoundedBG_56.CornerRadius = UDim.new(0, 9)
RoundedBG_56.Name = "RoundedBG"
RoundedBG_56.Parent = ButtonName_30

ButtonName_31.Name = "ButtonName"
ButtonName_31.Parent = Page3
ButtonName_31.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_31.BorderSizePixel = 0
ButtonName_31.Position = UDim2.new(0.00400000019, 10, 1.27499998, -280)
ButtonName_31.Size = UDim2.new(0, 110, 0, 48)
ButtonName_31.ZIndex = 7
ButtonName_31.Font = Enum.Font.SourceSansBold
ButtonName_31.Text = "Script here"
ButtonName_31.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_31.TextSize = 18.000
ButtonName_31.TextWrapped = true

RoundedBG_57.CornerRadius = UDim.new(0, 9)
RoundedBG_57.Name = "RoundedBG"
RoundedBG_57.Parent = ButtonName_31

ButtonName_32.Name = "ButtonName"
ButtonName_32.Parent = Page3
ButtonName_32.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_32.BorderSizePixel = 0
ButtonName_32.Position = UDim2.new(0.501999974, 10, 1.27499998, -280)
ButtonName_32.Size = UDim2.new(0, 110, 0, 48)
ButtonName_32.ZIndex = 7
ButtonName_32.Font = Enum.Font.SourceSansBold
ButtonName_32.Text = "Script here"
ButtonName_32.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_32.TextSize = 18.000
ButtonName_32.TextWrapped = true

RoundedBG_58.CornerRadius = UDim.new(0, 9)
RoundedBG_58.Name = "RoundedBG"
RoundedBG_58.Parent = ButtonName_32

ButtonName_33.Name = "ButtonName"
ButtonName_33.Parent = Page3
ButtonName_33.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_33.BorderSizePixel = 0
ButtonName_33.Position = UDim2.new(0.75999999, 10, 1.27499998, -280)
ButtonName_33.Size = UDim2.new(0, 110, 0, 48)
ButtonName_33.ZIndex = 7
ButtonName_33.Font = Enum.Font.SourceSansBold
ButtonName_33.Text = "Script here"
ButtonName_33.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_33.TextSize = 18.000
ButtonName_33.TextWrapped = true

RoundedBG_59.CornerRadius = UDim.new(0, 9)
RoundedBG_59.Name = "RoundedBG"
RoundedBG_59.Parent = ButtonName_33

ButtonName_34.Name = "ButtonName"
ButtonName_34.Parent = Page3
ButtonName_34.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_34.BorderSizePixel = 0
ButtonName_34.Position = UDim2.new(0.501999974, 10, 1.57500005, -280)
ButtonName_34.Size = UDim2.new(0, 110, 0, 48)
ButtonName_34.ZIndex = 7
ButtonName_34.Font = Enum.Font.SourceSansBold
ButtonName_34.Text = "Script here"
ButtonName_34.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_34.TextSize = 18.000
ButtonName_34.TextWrapped = true

RoundedBG_60.CornerRadius = UDim.new(0, 9)
RoundedBG_60.Name = "RoundedBG"
RoundedBG_60.Parent = ButtonName_34

ButtonName_35.Name = "ButtonName"
ButtonName_35.Parent = Page3
ButtonName_35.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_35.BorderSizePixel = 0
ButtonName_35.Position = UDim2.new(0.00400000019, 10, 1.875, -280)
ButtonName_35.Size = UDim2.new(0, 110, 0, 48)
ButtonName_35.ZIndex = 7
ButtonName_35.Font = Enum.Font.SourceSansBold
ButtonName_35.Text = "Script here"
ButtonName_35.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_35.TextSize = 18.000
ButtonName_35.TextWrapped = true

RoundedBG_61.CornerRadius = UDim.new(0, 9)
RoundedBG_61.Name = "RoundedBG"
RoundedBG_61.Parent = ButtonName_35

ButtonName_36.Name = "ButtonName"
ButtonName_36.Parent = Page3
ButtonName_36.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_36.BorderSizePixel = 0
ButtonName_36.Position = UDim2.new(0.254999995, 10, 1.57500005, -280)
ButtonName_36.Size = UDim2.new(0, 110, 0, 48)
ButtonName_36.ZIndex = 7
ButtonName_36.Font = Enum.Font.SourceSansBold
ButtonName_36.Text = "Script here"
ButtonName_36.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_36.TextSize = 18.000
ButtonName_36.TextWrapped = true

RoundedBG_62.CornerRadius = UDim.new(0, 9)
RoundedBG_62.Name = "RoundedBG"
RoundedBG_62.Parent = ButtonName_36

ButtonName_37.Name = "ButtonName"
ButtonName_37.Parent = Page3
ButtonName_37.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_37.BorderSizePixel = 0
ButtonName_37.Position = UDim2.new(0.75999999, 10, 1.57500005, -280)
ButtonName_37.Size = UDim2.new(0, 110, 0, 48)
ButtonName_37.ZIndex = 7
ButtonName_37.Font = Enum.Font.SourceSansBold
ButtonName_37.Text = "Script here"
ButtonName_37.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_37.TextSize = 18.000
ButtonName_37.TextWrapped = true

RoundedBG_63.CornerRadius = UDim.new(0, 9)
RoundedBG_63.Name = "RoundedBG"
RoundedBG_63.Parent = ButtonName_37

ButtonName_38.Name = "ButtonName"
ButtonName_38.Parent = Page3
ButtonName_38.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_38.BorderSizePixel = 0
ButtonName_38.Position = UDim2.new(0.00400000019, 10, 1.57500005, -280)
ButtonName_38.Size = UDim2.new(0, 110, 0, 48)
ButtonName_38.ZIndex = 7
ButtonName_38.Font = Enum.Font.SourceSansBold
ButtonName_38.Text = "Script here"
ButtonName_38.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_38.TextSize = 18.000
ButtonName_38.TextWrapped = true

RoundedBG_64.CornerRadius = UDim.new(0, 9)
RoundedBG_64.Name = "RoundedBG"
RoundedBG_64.Parent = ButtonName_38

ButtonName_39.Name = "ButtonName"
ButtonName_39.Parent = Page3
ButtonName_39.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_39.BorderSizePixel = 0
ButtonName_39.Position = UDim2.new(0.75999999, 10, 1.875, -280)
ButtonName_39.Size = UDim2.new(0, 110, 0, 48)
ButtonName_39.ZIndex = 7
ButtonName_39.Font = Enum.Font.SourceSansBold
ButtonName_39.Text = "Script here"
ButtonName_39.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_39.TextSize = 18.000
ButtonName_39.TextWrapped = true

RoundedBG_65.CornerRadius = UDim.new(0, 9)
RoundedBG_65.Name = "RoundedBG"
RoundedBG_65.Parent = ButtonName_39

PageNumber_5.Name = "Page Number"
PageNumber_5.Parent = Page3
PageNumber_5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PageNumber_5.BackgroundTransparency = 1.000
PageNumber_5.Position = UDim2.new(0.00763638597, 10, 2.45220447, -280)
PageNumber_5.Size = UDim2.new(0, 523, 0, 32)
PageNumber_5.ZIndex = 8
PageNumber_5.Font = Enum.Font.SourceSansBold
PageNumber_5.Text = "[ FE ] HAT SCRIPTS"
PageNumber_5.TextColor3 = Color3.fromRGB(61, 61, 61)
PageNumber_5.TextSize = 22.000
PageNumber_5.TextWrapped = true

Page_7.Name = "Page<"
Page_7.Parent = Page3
Page_7.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_7.BorderSizePixel = 0
Page_7.Position = UDim2.new(0.69599998, 10, 1.04301071, -280)
Page_7.Size = UDim2.new(0, 44, 0, 32)
Page_7.ZIndex = 7
Page_7.Font = Enum.Font.SourceSansBold
Page_7.Text = "<"
Page_7.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_7.TextSize = 22.000
Page_7.TextWrapped = true

RoundedBG_66.CornerRadius = UDim.new(0, 9)
RoundedBG_66.Name = "RoundedBG"
RoundedBG_66.Parent = Page_7

Page_8.Name = "Page>"
Page_8.Parent = Page3
Page_8.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Page_8.BorderSizePixel = 0
Page_8.Position = UDim2.new(0.785999954, 10, 1.04301071, -280)
Page_8.Size = UDim2.new(0, 44, 0, 32)
Page_8.ZIndex = 7
Page_8.Font = Enum.Font.SourceSansBold
Page_8.Text = ">"
Page_8.TextColor3 = Color3.fromRGB(61, 61, 61)
Page_8.TextSize = 22.000
Page_8.TextWrapped = true

RoundedBG_67.CornerRadius = UDim.new(0, 9)
RoundedBG_67.Name = "RoundedBG"
RoundedBG_67.Parent = Page_8

ButtonName_40.Name = "ButtonName"
ButtonName_40.Parent = Page3
ButtonName_40.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_40.BorderSizePixel = 0
ButtonName_40.Position = UDim2.new(0.501999974, 10, 1.875, -280)
ButtonName_40.Size = UDim2.new(0, 110, 0, 48)
ButtonName_40.ZIndex = 7
ButtonName_40.Font = Enum.Font.SourceSansBold
ButtonName_40.Text = "Script here"
ButtonName_40.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_40.TextSize = 18.000
ButtonName_40.TextWrapped = true

RoundedBG_68.CornerRadius = UDim.new(0, 9)
RoundedBG_68.Name = "RoundedBG"
RoundedBG_68.Parent = ButtonName_40

ButtonName_41.Name = "ButtonName"
ButtonName_41.Parent = Page3
ButtonName_41.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
ButtonName_41.BorderSizePixel = 0
ButtonName_41.Position = UDim2.new(0.254999995, 10, 1.875, -280)
ButtonName_41.Size = UDim2.new(0, 110, 0, 48)
ButtonName_41.ZIndex = 7
ButtonName_41.Font = Enum.Font.SourceSansBold
ButtonName_41.Text = "Script here"
ButtonName_41.TextColor3 = Color3.fromRGB(61, 61, 61)
ButtonName_41.TextSize = 18.000
ButtonName_41.TextWrapped = true

RoundedBG_69.CornerRadius = UDim.new(0, 9)
RoundedBG_69.Name = "RoundedBG"
RoundedBG_69.Parent = ButtonName_41

Close.Name = "Close"
Close.Parent = Main
Close.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Close.Position = UDim2.new(0.875999987, 10, 0.931999981, -280)
Close.Size = UDim2.new(0, 44, 0, 32)
Close.ZIndex = 7
Close.Font = Enum.Font.SourceSansBold
Close.Text = "X"
Close.TextColor3 = Color3.fromRGB(61, 61, 61)
Close.TextSize = 18.000
Close.TextWrapped = true

RoundedBG_70.Name = "RoundedBG"
RoundedBG_70.Parent = Close

Separator.Name = "Separator"
Separator.Parent = Main
Separator.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Separator.Position = UDim2.new(0.00400000019, 10, 1.80299997, -280)
Separator.Size = UDim2.new(0, 526, 0, 19)
Separator.ZIndex = 7
Separator.Font = Enum.Font.SourceSansBold
Separator.Text = ""
Separator.TextColor3 = Color3.fromRGB(61, 61, 61)
Separator.TextSize = 18.000
Separator.TextWrapped = true

UICorner.CornerRadius = UDim.new(0, 9)
UICorner.Parent = Separator

Title.Name = "Title"
Title.Parent = Main
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.BorderColor3 = Color3.fromRGB(255, 255, 255)
Title.Position = UDim2.new(0.303000003, 0, -0.0179999992, 0)
Title.Size = UDim2.new(0.39199999, 0, 0.130999997, 0)
Title.ZIndex = 2
Title.Font = Enum.Font.SourceSansBold
Title.Text = "Ghoul Hub - UTG"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextSize = 14.000
Title.TextStrokeColor3 = Color3.fromRGB(61, 61, 61)
Title.TextStrokeTransparency = 0.000
Title.TextWrapped = true

Version.Name = "Version"
Version.Parent = Main
Version.BackgroundColor3 = Color3.fromRGB(16, 148, 163)
Version.BackgroundTransparency = 1.000
Version.BorderColor3 = Color3.fromRGB(16, 148, 163)
Version.Position = UDim2.new(0.319999993, 0, 0.0599999987, 0)
Version.Size = UDim2.new(0.360000014, 0, 0.119999997, 0)
Version.ZIndex = 2
Version.Font = Enum.Font.SourceSansBold
Version.Text = "By Ghoul Scripts"
Version.TextColor3 = Color3.fromRGB(255, 255, 255)
Version.TextSize = 14.000
Version.TextStrokeColor3 = Color3.fromRGB(61, 61, 61)
Version.TextStrokeTransparency = 0.000

Netless.Name = "Netless"
Netless.Parent = Main
Netless.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Netless.Position = UDim2.new(0.00327270501, 10, 0.931999922, -280)
Netless.Size = UDim2.new(0, 73, 0, 32)
Netless.ZIndex = 7
Netless.Font = Enum.Font.SourceSansBold
Netless.Text = "Netless"
Netless.TextColor3 = Color3.fromRGB(61, 61, 61)
Netless.TextSize = 18.000
Netless.TextWrapped = true

RoundedBG_71.Name = "RoundedBG"
RoundedBG_71.Parent = Netless

Respawn.Name = "Respawn"
Respawn.Parent = Main
Respawn.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
Respawn.Position = UDim2.new(0.148727253, 10, 0.931999922, -280)
Respawn.Size = UDim2.new(0, 74, 0, 32)
Respawn.ZIndex = 7
Respawn.Font = Enum.Font.SourceSansBold
Respawn.Text = "Respawn"
Respawn.TextColor3 = Color3.fromRGB(61, 61, 61)
Respawn.TextSize = 18.000
Respawn.TextWrapped = true

RoundedBG_72.Name = "RoundedBG"
RoundedBG_72.Parent = Respawn

AntiFling.Name = "AntiFling"
AntiFling.Parent = Main
AntiFling.BackgroundColor3 = Color3.fromRGB(152, 255, 152)
AntiFling.Position = UDim2.new(0.403272718, 10, 1.64490306, -280)
AntiFling.Size = UDim2.new(0, 81, 0, 32)
AntiFling.ZIndex = 7
AntiFling.Font = Enum.Font.SourceSansBold
AntiFling.Text = "Anti Fling"
AntiFling.TextColor3 = Color3.fromRGB(61, 61, 61)
AntiFling.TextSize = 18.000
AntiFling.TextWrapped = true

RoundedBG_73.Name = "RoundedBG"
RoundedBG_73.Parent = AntiFling

-- Scripts:

local function VXFYCT_fake_script() -- NekoMaid.LocalScript 
	local script = Instance.new('LocalScript', NekoMaid)

	NekoMaid.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://paste.ee/d/6bCwm/0"))()
	end)
end
coroutine.wrap(VXFYCT_fake_script)()
local function RRKJZF_fake_script() -- GaleFighter.LocalScript 
	local script = Instance.new('LocalScript', GaleFighter)

	GaleFighter.MouseButton1Down:connect(function()
		--[[ Options ]]--
		_G.CharacterBug = false --Set to true if your uppertorso floats when you use the script with R15.
		_G.GodMode = true --Set to true if you want godmode.
		_G.R6 = true --Set to true if you wanna enable R15 to R6 when your R15.
		--[[Reanimate]]--
		loadstring(game:HttpGet("https://gist.githubusercontent.com/M6HqVBcddw2qaN4s/fc29cbf0eda6f8b129778b441be3128f/raw/6StQ2n56PnEHMhQ9"))()

		function LoadLibrary(a)
			local t = {}

			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------JSON Functions Begin----------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------

			--JSON Encoder and Parser for Lua 5.1
			-- 
			--Copyright 2007 Shaun Brown (http://www.chipmunkav.com)
			--All Rights Reserved.

			--Permission is hereby granted, free of charge, to any person
			--obtaining a copy of this software to deal in the Software without
			--restriction, including without limitation the rights to use,
			--copy, modify, merge, publish, distribute, sublicense, and/or
			--sell copies of the Software, and to permit persons to whom the
			--Software is furnished to do so, subject to the following conditions:

			--The above copyright notice and this permission notice shall be
			--included in all copies or substantial portions of the Software.
			--If you find this software useful please give www.chipmunkav.com a mention.

			--THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
			--EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
			--OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
			--IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR
			--ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
			--CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
			--CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

			local string = string
			local math = math
			local table = table
			local error = error
			local tonumber = tonumber
			local tostring = tostring
			local type = type
			local setmetatable = setmetatable
			local pairs = pairs
			local ipairs = ipairs
			local assert = assert


			local StringBuilder = {
				buffer = {}
			}

			function StringBuilder:New()
				local o = {}
				setmetatable(o, self)
				self.__index = self
				o.buffer = {}
				return o
			end

			function StringBuilder:Append(s)
				self.buffer[#self.buffer+1] = s
			end

			function StringBuilder:ToString()
				return table.concat(self.buffer)
			end

			local JsonWriter = {
				backslashes = {
					['\b'] = "\\b",
					['\t'] = "\\t",
					['\n'] = "\\n",
					['\f'] = "\\f",
					['\r'] = "\\r",
					['"'] = "\\\"",
					['\\'] = "\\\\",
					['/'] = "\\/"
				}
			}

			function JsonWriter:New()
				local o = {}
				o.writer = StringBuilder:New()
				setmetatable(o, self)
				self.__index = self
				return o
			end

			function JsonWriter:Append(s)
				self.writer:Append(s)
			end

			function JsonWriter:ToString()
				return self.writer:ToString()
			end

			function JsonWriter:Write(o)
				local t = type(o)
				if t == "nil" then
					self:WriteNil()
				elseif t == "boolean" then
					self:WriteString(o)
				elseif t == "number" then
					self:WriteString(o)
				elseif t == "string" then
					self:ParseString(o)
				elseif t == "table" then
					self:WriteTable(o)
				elseif t == "function" then
					self:WriteFunction(o)
				elseif t == "thread" then
					self:WriteError(o)
				elseif t == "userdata" then
					self:WriteError(o)
				end
			end

			function JsonWriter:WriteNil()
				self:Append("null")
			end

			function JsonWriter:WriteString(o)
				self:Append(tostring(o))
			end

			function JsonWriter:ParseString(s)
				self:Append('"')
				self:Append(string.gsub(s, "[%z%c\\\"/]", function(n)
					local c = self.backslashes[n]
					if c then return c end
					return string.format("\\u%.4X", string.byte(n))
				end))
				self:Append('"')
			end

			function JsonWriter:IsArray(t)
				local count = 0
				local isindex = function(k)
					if type(k) == "number" and k > 0 then
						if math.floor(k) == k then
							return true
						end
					end
					return false
				end
				for k,v in pairs(t) do
					if not isindex(k) then
						return false, '{', '}'
					else
						count = math.max(count, k)
					end
				end
				return true, '[', ']', count
			end

			function JsonWriter:WriteTable(t)
				local ba, st, et, n = self:IsArray(t)
				self:Append(st)
				if ba then
					for i = 1, n do
						self:Write(t[i])
						if i < n then
							self:Append(',')
						end
					end
				else
					local first = true;
					for k, v in pairs(t) do
						if not first then
							self:Append(',')
						end
						first = false;
						self:ParseString(k)
						self:Append(':')
						self:Write(v)
					end
				end
				self:Append(et)
			end

			function JsonWriter:WriteError(o)
				error(string.format(
					"Encoding of %s unsupported",
					tostring(o)))
			end

			function JsonWriter:WriteFunction(o)
				if o == Null then
					self:WriteNil()
				else
					self:WriteError(o)
				end
			end

			local StringReader = {
				s = "",
				i = 0
			}

			function StringReader:New(s)
				local o = {}
				setmetatable(o, self)
				self.__index = self
				o.s = s or o.s
				return o
			end

			function StringReader:Peek()
				local i = self.i + 1
				if i <= #self.s then
					return string.sub(self.s, i, i)
				end
				return nil
			end

			function StringReader:Next()
				self.i = self.i+1
				if self.i <= #self.s then
					return string.sub(self.s, self.i, self.i)
				end
				return nil
			end

			function StringReader:All()
				return self.s
			end

			local JsonReader = {
				escapes = {
					['t'] = '\t',
					['n'] = '\n',
					['f'] = '\f',
					['r'] = '\r',
					['b'] = '\b',
				}
			}

			function JsonReader:New(s)
				local o = {}
				o.reader = StringReader:New(s)
				setmetatable(o, self)
				self.__index = self
				return o;
			end

			function JsonReader:Read()
				self:SkipWhiteSpace()
				local peek = self:Peek()
				if peek == nil then
					error(string.format(
						"Nil string: '%s'",
						self:All()))
				elseif peek == '{' then
					return self:ReadObject()
				elseif peek == '[' then
					return self:ReadArray()
				elseif peek == '"' then
					return self:ReadString()
				elseif string.find(peek, "[%+%-%d]") then
					return self:ReadNumber()
				elseif peek == 't' then
					return self:ReadTrue()
				elseif peek == 'f' then
					return self:ReadFalse()
				elseif peek == 'n' then
					return self:ReadNull()
				elseif peek == '/' then
					self:ReadComment()
					return self:Read()
				else
					return nil
				end
			end

			function JsonReader:ReadTrue()
				self:TestReservedWord{'t','r','u','e'}
				return true
			end

			function JsonReader:ReadFalse()
				self:TestReservedWord{'f','a','l','s','e'}
				return false
			end

			function JsonReader:ReadNull()
				self:TestReservedWord{'n','u','l','l'}
				return nil
			end

			function JsonReader:TestReservedWord(t)
				for i, v in ipairs(t) do
					if self:Next() ~= v then
						error(string.format(
							"Error reading '%s': %s",
							table.concat(t),
							self:All()))
					end
				end
			end

			function JsonReader:ReadNumber()
				local result = self:Next()
				local peek = self:Peek()
				while peek ~= nil and string.find(
					peek,
					"[%+%-%d%.eE]") do
					result = result .. self:Next()
					peek = self:Peek()
				end
				result = tonumber(result)
				if result == nil then
					error(string.format(
						"Invalid number: '%s'",
						result))
				else
					return result
				end
			end

			function JsonReader:ReadString()
				local result = ""
				assert(self:Next() == '"')
				while self:Peek() ~= '"' do
					local ch = self:Next()
					if ch == '\\' then
						ch = self:Next()
						if self.escapes[ch] then
							ch = self.escapes[ch]
						end
					end
					result = result .. ch
				end
				assert(self:Next() == '"')
				local fromunicode = function(m)
					return string.char(tonumber(m, 16))
				end
				return string.gsub(
					result,
					"u%x%x(%x%x)",
					fromunicode)
			end

			function JsonReader:ReadComment()
				assert(self:Next() == '/')
				local second = self:Next()
				if second == '/' then
					self:ReadSingleLineComment()
				elseif second == '*' then
					self:ReadBlockComment()
				else
					error(string.format(
						"Invalid comment: %s",
						self:All()))
				end
			end

			function JsonReader:ReadBlockComment()
				local done = false
				while not done do
					local ch = self:Next()
					if ch == '*' and self:Peek() == '/' then
						done = true
					end
					if not done and
						ch == '/' and
						self:Peek() == "*" then
						error(string.format(
							"Invalid comment: %s, '/*' illegal.",
							self:All()))
					end
				end
				self:Next()
			end

			function JsonReader:ReadSingleLineComment()
				local ch = self:Next()
				while ch ~= '\r' and ch ~= '\n' do
					ch = self:Next()
				end
			end

			function JsonReader:ReadArray()
				local result = {}
				assert(self:Next() == '[')
				local done = false
				if self:Peek() == ']' then
					done = true;
				end
				while not done do
					local item = self:Read()
					result[#result+1] = item
					self:SkipWhiteSpace()
					if self:Peek() == ']' then
						done = true
					end
					if not done then
						local ch = self:Next()
						if ch ~= ',' then
							error(string.format(
								"Invalid array: '%s' due to: '%s'",
								self:All(), ch))
						end
					end
				end
				assert(']' == self:Next())
				return result
			end

			function JsonReader:ReadObject()
				local result = {}
				assert(self:Next() == '{')
				local done = false
				if self:Peek() == '}' then
					done = true
				end
				while not done do
					local key = self:Read()
					if type(key) ~= "string" then
						error(string.format(
							"Invalid non-string object key: %s",
							key))
					end
					self:SkipWhiteSpace()
					local ch = self:Next()
					if ch ~= ':' then
						error(string.format(
							"Invalid object: '%s' due to: '%s'",
							self:All(),
							ch))
					end
					self:SkipWhiteSpace()
					local val = self:Read()
					result[key] = val
					self:SkipWhiteSpace()
					if self:Peek() == '}' then
						done = true
					end
					if not done then
						ch = self:Next()
						if ch ~= ',' then
							error(string.format(
								"Invalid array: '%s' near: '%s'",
								self:All(),
								ch))
						end
					end
				end
				assert(self:Next() == "}")
				return result
			end

			function JsonReader:SkipWhiteSpace()
				local p = self:Peek()
				while p ~= nil and string.find(p, "[%s/]") do
					if p == '/' then
						self:ReadComment()
					else
						self:Next()
					end
					p = self:Peek()
				end
			end

			function JsonReader:Peek()
				return self.reader:Peek()
			end

			function JsonReader:Next()
				return self.reader:Next()
			end

			function JsonReader:All()
				return self.reader:All()
			end

			function Encode(o)
				local writer = JsonWriter:New()
				writer:Write(o)
				return writer:ToString()
			end

			function Decode(s)
				local reader = JsonReader:New(s)
				return reader:Read()
			end

			function Null()
				return Null
			end
			-------------------- End JSON Parser ------------------------

			t.DecodeJSON = function(jsonString)
				pcall(function() warn("RbxUtility.DecodeJSON is deprecated, please use Game:GetService('HttpService'):JSONDecode() instead.") end)

				if type(jsonString) == "string" then
					return Decode(jsonString)
				end
				print("RbxUtil.DecodeJSON expects string argument!")
				return nil
			end

			t.EncodeJSON = function(jsonTable)
				pcall(function() warn("RbxUtility.EncodeJSON is deprecated, please use Game:GetService('HttpService'):JSONEncode() instead.") end)
				return Encode(jsonTable)
			end








			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			--------------------------------------------Terrain Utilities Begin-----------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			--makes a wedge at location x, y, z
			--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously w
			--returns true if made a wedge, false if the cell remains a block
			t.MakeWedge = function(x, y, z, defaultmaterial)
				return game:GetService("Terrain"):AutoWedgeCell(x,y,z)
			end

			t.SelectTerrainRegion = function(regionToSelect, color, selectEmptyCells, selectionParent)
				local terrain = game:GetService("Workspace"):FindFirstChild("Terrain")
				if not terrain then return end

				assert(regionToSelect)
				assert(color)

				if not type(regionToSelect) == "Region3" then
					error("regionToSelect (first arg), should be of type Region3, but is type",type(regionToSelect))
				end
				if not type(color) == "BrickColor" then
					error("color (second arg), should be of type BrickColor, but is type",type(color))
				end

				-- frequently used terrain calls (speeds up call, no lookup necessary)
				local GetCell = terrain.GetCell
				local WorldToCellPreferSolid = terrain.WorldToCellPreferSolid
				local CellCenterToWorld = terrain.CellCenterToWorld
				local emptyMaterial = Enum.CellMaterial.Empty

				-- container for all adornments, passed back to user
				local selectionContainer = Instance.new("Model")
				selectionContainer.Name = "SelectionContainer"
				selectionContainer.Archivable = false
				if selectionParent then
					selectionContainer.Parent = selectionParent
				else
					selectionContainer.Parent = game:GetService("Workspace")
				end

				local updateSelection = nil -- function we return to allow user to update selection
				local currentKeepAliveTag = nil -- a tag that determines whether adorns should be destroyed
				local aliveCounter = 0 -- helper for currentKeepAliveTag
				local lastRegion = nil -- used to stop updates that do nothing
				local adornments = {} -- contains all adornments
				local reusableAdorns = {}

				local selectionPart = Instance.new("Part")
				selectionPart.Name = "SelectionPart"
				selectionPart.Transparency = 1
				selectionPart.Anchored = true
				selectionPart.Locked = true
				selectionPart.CanCollide = false
				selectionPart.Size = Vector3.new(4.2,4.2,4.2)

				local selectionBox = Instance.new("SelectionBox")

				-- srs translation from region3 to region3int16
				local function Region3ToRegion3int16(region3)
					local theLowVec = region3.CFrame.p - (region3.Size/2) + Vector3.new(2,2,2)
					local lowCell = WorldToCellPreferSolid(terrain,theLowVec)

					local theHighVec = region3.CFrame.p + (region3.Size/2) - Vector3.new(2,2,2)
					local highCell = WorldToCellPreferSolid(terrain, theHighVec)

					local highIntVec = Vector3int16.new(highCell.x,highCell.y,highCell.z)
					local lowIntVec = Vector3int16.new(lowCell.x,lowCell.y,lowCell.z)

					return Region3int16.new(lowIntVec,highIntVec)
				end

				-- helper function that creates the basis for a selection box
				function createAdornment(theColor)
					local selectionPartClone = nil
					local selectionBoxClone = nil

					if #reusableAdorns > 0 then
						selectionPartClone = reusableAdorns[1]["part"]
						selectionBoxClone = reusableAdorns[1]["box"]
						table.remove(reusableAdorns,1)

						selectionBoxClone.Visible = true
					else
						selectionPartClone = selectionPart:Clone()
						selectionPartClone.Archivable = false

						selectionBoxClone = selectionBox:Clone()
						selectionBoxClone.Archivable = false

						selectionBoxClone.Adornee = selectionPartClone
						selectionBoxClone.Parent = selectionContainer

						selectionBoxClone.Adornee = selectionPartClone

						selectionBoxClone.Parent = selectionContainer
					end

					if theColor then
						selectionBoxClone.Color = theColor
					end

					return selectionPartClone, selectionBoxClone
				end

				-- iterates through all current adornments and deletes any that don't have latest tag
				function cleanUpAdornments()
					for cellPos, adornTable in pairs(adornments) do

						if adornTable.KeepAlive ~= currentKeepAliveTag then -- old news, we should get rid of this
							adornTable.SelectionBox.Visible = false
							table.insert(reusableAdorns,{part = adornTable.SelectionPart, box = adornTable.SelectionBox})
							adornments[cellPos] = nil
						end
					end
				end

				-- helper function to update tag
				function incrementAliveCounter()
					aliveCounter = aliveCounter + 1
					if aliveCounter > 1000000 then
						aliveCounter = 0
					end
					return aliveCounter
				end

				-- finds full cells in region and adorns each cell with a box, with the argument color
				function adornFullCellsInRegion(region, color)
					local regionBegin = region.CFrame.p - (region.Size/2) + Vector3.new(2,2,2)
					local regionEnd = region.CFrame.p + (region.Size/2) - Vector3.new(2,2,2)

					local cellPosBegin = WorldToCellPreferSolid(terrain, regionBegin)
					local cellPosEnd = WorldToCellPreferSolid(terrain, regionEnd)

					currentKeepAliveTag = incrementAliveCounter()
					for y = cellPosBegin.y, cellPosEnd.y do
						for z = cellPosBegin.z, cellPosEnd.z do
							for x = cellPosBegin.x, cellPosEnd.x do
								local cellMaterial = GetCell(terrain, x, y, z)

								if cellMaterial ~= emptyMaterial then
									local cframePos = CellCenterToWorld(terrain, x, y, z)
									local cellPos = Vector3int16.new(x,y,z)

									local updated = false
									for cellPosAdorn, adornTable in pairs(adornments) do
										if cellPosAdorn == cellPos then
											adornTable.KeepAlive = currentKeepAliveTag
											if color then
												adornTable.SelectionBox.Color = color
											end
											updated = true
											break
										end
									end

									if not updated then
										local selectionPart, selectionBox = createAdornment(color)
										selectionPart.Size = Vector3.new(4,4,4)
										selectionPart.CFrame = CFrame.new(cframePos)
										local adornTable = {SelectionPart = selectionPart, SelectionBox = selectionBox, KeepAlive = currentKeepAliveTag}
										adornments[cellPos] = adornTable
									end
								end
							end
						end
					end
					cleanUpAdornments()
				end


				------------------------------------- setup code ------------------------------
				lastRegion = regionToSelect

				if selectEmptyCells then -- use one big selection to represent the area selected
					local selectionPart, selectionBox = createAdornment(color)

					selectionPart.Size = regionToSelect.Size
					selectionPart.CFrame = regionToSelect.CFrame

					adornments.SelectionPart = selectionPart
					adornments.SelectionBox = selectionBox

					updateSelection =
						function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
							lastRegion = newRegion
							selectionPart.Size = newRegion.Size
							selectionPart.CFrame = newRegion.CFrame
						end
						if color then
							selectionBox.Color = color
						end
					end
				else -- use individual cell adorns to represent the area selected
					adornFullCellsInRegion(regionToSelect, color)
					updateSelection =
						function (newRegion, color)
						if newRegion and newRegion ~= lastRegion then
							lastRegion = newRegion
							adornFullCellsInRegion(newRegion, color)
						end
					end

				end

				local destroyFunc = function()
					updateSelection = nil
					if selectionContainer then selectionContainer:Destroy() end
					adornments = nil
				end

				return updateSelection, destroyFunc
			end

			-----------------------------Terrain Utilities End-----------------------------







			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------Signal class begin------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
--[[
A 'Signal' object identical to the internal RBXScriptSignal object in it's public API and semantics. This function
can be used to create "custom events" for user-made code.
API:
Method :connect( function handler )
Arguments: The function to connect to.
Returns: A new connection object which can be used to disconnect the connection
Description: Connects this signal to the function specified by |handler|. That is, when |fire( ... )| is called for
the signal the |handler| will be called with the arguments given to |fire( ... )|. Note, the functions
connected to a signal are called in NO PARTICULAR ORDER, so connecting one function after another does
NOT mean that the first will be called before the second as a result of a call to |fire|.
 
Method :disconnect()
Arguments: None
Returns: None
Description: Disconnects all of the functions connected to this signal.
 
Method :fire( ... )
Arguments: Any arguments are accepted
Returns: None
Description: Calls all of the currently connected functions with the given arguments.
 
Method :wait()
Arguments: None
Returns: The arguments given to fire
Description: This call blocks until
]]

			function t.CreateSignal()
				local this = {}

				local mBindableEvent = Instance.new('BindableEvent')
				local mAllCns = {} --all connection objects returned by mBindableEvent::connect

				--main functions
				function this:connect(func)
					if self ~= this then error("connect must be called with `:`, not `.`", 2) end
					if type(func) ~= 'function' then
						error("Argument #1 of connect must be a function, got a "..type(func), 2)
					end
					local cn = mBindableEvent.Event:Connect(func)
					mAllCns[cn] = true
					local pubCn = {}
					function pubCn:disconnect()
						cn:Disconnect()
						mAllCns[cn] = nil
					end
					pubCn.Disconnect = pubCn.disconnect

					return pubCn
				end

				function this:disconnect()
					if self ~= this then error("disconnect must be called with `:`, not `.`", 2) end
					for cn, _ in pairs(mAllCns) do
						cn:Disconnect()
						mAllCns[cn] = nil
					end
				end

				function this:wait()
					if self ~= this then error("wait must be called with `:`, not `.`", 2) end
					return mBindableEvent.Event:Wait()
				end

				function this:fire(...)
					if self ~= this then error("fire must be called with `:`, not `.`", 2) end
					mBindableEvent:Fire(...)
				end

				this.Connect = this.connect
				this.Disconnect = this.disconnect
				this.Wait = this.wait
				this.Fire = this.fire

				return this
			end

			------------------------------------------------- Sigal class End ------------------------------------------------------




			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			-----------------------------------------------Create Function Begins---------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
--[[
A "Create" function for easy creation of Roblox instances. The function accepts a string which is the classname of
the object to be created. The function then returns another function which either accepts accepts no arguments, in
which case it simply creates an object of the given type, or a table argument that may contain several types of data,
in which case it mutates the object in varying ways depending on the nature of the aggregate data. These are the
type of data and what operation each will perform:
1) A string key mapping to some value:
Key-Value pairs in this form will be treated as properties of the object, and will be assigned in NO PARTICULAR
ORDER. If the order in which properties is assigned matter, then they must be assigned somewhere else than the
|Create| call's body.
 
2) An integral key mapping to another Instance:
Normal numeric keys mapping to Instances will be treated as children if the object being created, and will be
parented to it. This allows nice recursive calls to Create to create a whole hierarchy of objects without a
need for temporary variables to store references to those objects.
 
3) A key which is a value returned from Create.Event( eventname ), and a value which is a function function
The Create.E( string ) function provides a limited way to connect to signals inside of a Create hierarchy
for those who really want such a functionality. The name of the event whose name is passed to
Create.E( string )
 
4) A key which is the Create function itself, and a value which is a function
The function will be run with the argument of the object itself after all other initialization of the object is
done by create. This provides a way to do arbitrary things involving the object from withing the create
hierarchy.
Note: This function is called SYNCHRONOUSLY, that means that you should only so initialization in
it, not stuff which requires waiting, as the Create call will block until it returns. While waiting in the
constructor callback function is possible, it is probably not a good design choice.
Note: Since the constructor function is called after all other initialization, a Create block cannot have two
constructor functions, as it would not be possible to call both of them last, also, this would be unnecessary.
 
 
Some example usages:
 
A simple example which uses the Create function to create a model object and assign two of it's properties.
local model = Create'Model'{
Name = 'A New model',
Parent = game.Workspace,
}
 
 
An example where a larger hierarchy of object is made. After the call the hierarchy will look like this:
Model_Container
|-ObjectValue
| |
| `-BoolValueChild
`-IntValue
 
local model = Create'Model'{
Name = 'Model_Container',
Create'ObjectValue'{
Create'BoolValue'{
Name = 'BoolValueChild',
},
},
Create'IntValue'{},
}
 
 
An example using the event syntax:
 
local part = Create'Part'{
[Create.E'Touched'] = function(part)
print("I was touched by "..part.Name)
end,
}
 
 
An example using the general constructor syntax:
 
local model = Create'Part'{
[Create] = function(this)
print("Constructor running!")
this.Name = GetGlobalFoosAndBars(this)
end,
}
 
 
Note: It is also perfectly legal to save a reference to the function returned by a call Create, this will not cause
any unexpected behavior. EG:
local partCreatingFunction = Create'Part'
local part = partCreatingFunction()
]]

			--the Create function need to be created as a functor, not a function, in order to support the Create.E syntax, so it
			--will be created in several steps rather than as a single function declaration.
			local function Create_PrivImpl(objectType)
				if type(objectType) ~= 'string' then
					error("Argument of Create must be a string", 2)
				end
				--return the proxy function that gives us the nice Create'string'{data} syntax
				--The first function call is a function call using Lua's single-string-argument syntax
				--The second function call is using Lua's single-table-argument syntax
				--Both can be chained together for the nice effect.
				return function(dat)
					--default to nothing, to handle the no argument given case
					dat = dat or {}

					--make the object to mutate
					local obj = Instance.new(objectType)
					local parent = nil

					--stored constructor function to be called after other initialization
					local ctor = nil

					for k, v in pairs(dat) do
						--add property
						if type(k) == 'string' then
							if k == 'Parent' then
								-- Parent should always be set last, setting the Parent of a new object
								-- immediately makes performance worse for all subsequent property updates.
								parent = v
							else
								obj[k] = v
							end


							--add child
						elseif type(k) == 'number' then
							if type(v) ~= 'userdata' then
								error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
							end
							v.Parent = obj


							--event connect
						elseif type(k) == 'table' and k.__eventname then
							if type(v) ~= 'function' then
								error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
got: "..tostring(v), 2)
							end
							obj[k.__eventname]:connect(v)


							--define constructor function
						elseif k == t.Create then
							if type(v) ~= 'function' then
								error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
got: "..tostring(v), 2)
							elseif ctor then
								--ctor already exists, only one allowed
								error("Bad entry in Create body: Only one constructor function is allowed", 2)
							end
							ctor = v


						else
							error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
						end
					end

					--apply constructor function if it exists
					if ctor then
						ctor(obj)
					end

					if parent then
						obj.Parent = parent
					end

					--return the completed object
					return obj
				end
			end

			--now, create the functor:
			t.Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})

			--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
			--function can recognize as special.
			t.Create.E = function(eventName)
				return {__eventname = eventName}
			end

			-------------------------------------------------Create function End----------------------------------------------------




			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------Documentation Begin-----------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------
			------------------------------------------------------------------------------------------------------------------------

			t.Help =
				function(funcNameOrFunc)
				--input argument can be a string or a function. Should return a description (of arguments and expected side effects)
				if funcNameOrFunc == "DecodeJSON" or funcNameOrFunc == t.DecodeJSON then
					return "Function DecodeJSON. " ..
						"Arguments: (string). " ..
						"Side effect: returns a table with all parsed JSON values"
				end
				if funcNameOrFunc == "EncodeJSON" or funcNameOrFunc == t.EncodeJSON then
					return "Function EncodeJSON. " ..
						"Arguments: (table). " ..
						"Side effect: returns a string composed of argument table in JSON data format"
				end
				if funcNameOrFunc == "MakeWedge" or funcNameOrFunc == t.MakeWedge then
					return "Function MakeWedge. " ..
						"Arguments: (x, y, z, [default material]). " ..
						"Description: Makes a wedge at location x, y, z. Sets cell x, y, z to default material if "..
						"parameter is provided, if not sets cell x, y, z to be whatever material it previously was. "..
						"Returns true if made a wedge, false if the cell remains a block "
				end
				if funcNameOrFunc == "SelectTerrainRegion" or funcNameOrFunc == t.SelectTerrainRegion then
					return "Function SelectTerrainRegion. " ..
						"Arguments: (regionToSelect, color, selectEmptyCells, selectionParent). " ..
						"Description: Selects all terrain via a series of selection boxes within the regionToSelect " ..
						"(this should be a region3 value). The selection box color is detemined by the color argument " ..
						"(should be a brickcolor value). SelectionParent is the parent that the selection model gets placed to (optional)." ..
						"SelectEmptyCells is bool, when true will select all cells in the " ..
						"region, otherwise we only select non-empty cells. Returns a function that can update the selection," ..
						"arguments to said function are a new region3 to select, and the adornment color (color arg is optional). " ..
						"Also returns a second function that takes no arguments and destroys the selection"
				end
				if funcNameOrFunc == "CreateSignal" or funcNameOrFunc == t.CreateSignal then
					return "Function CreateSignal. "..
						"Arguments: None. "..
						"Returns: The newly created Signal object. This object is identical to the RBXScriptSignal class "..
						"used for events in Objects, but is a Lua-side object so it can be used to create custom events in"..
						"Lua code. "..
						"Methods of the Signal object: :connect, :wait, :fire, :disconnect. "..
						"For more info you can pass the method name to the Help function, or view the wiki page "..
						"for this library. EG: Help('Signal:connect')."
				end
				if funcNameOrFunc == "Signal:connect" then
					return "Method Signal:connect. "..
						"Arguments: (function handler). "..
						"Return: A connection object which can be used to disconnect the connection to this handler. "..
						"Description: Connectes a handler function to this Signal, so that when |fire| is called the "..
						"handler function will be called with the arguments passed to |fire|."
				end
				if funcNameOrFunc == "Signal:wait" then
					return "Method Signal:wait. "..
						"Arguments: None. "..
						"Returns: The arguments passed to the next call to |fire|. "..
						"Description: This call does not return until the next call to |fire| is made, at which point it "..
						"will return the values which were passed as arguments to that |fire| call."
				end
				if funcNameOrFunc == "Signal:fire" then
					return "Method Signal:fire. "..
						"Arguments: Any number of arguments of any type. "..
						"Returns: None. "..
						"Description: This call will invoke any connected handler functions, and notify any waiting code "..
						"attached to this Signal to continue, with the arguments passed to this function. Note: The calls "..
						"to handlers are made asynchronously, so this call will return immediately regardless of how long "..
						"it takes the connected handler functions to complete."
				end
				if funcNameOrFunc == "Signal:disconnect" then
					return "Method Signal:disconnect. "..
						"Arguments: None. "..
						"Returns: None. "..
						"Description: This call disconnects all handlers attacched to this function, note however, it "..
						"does NOT make waiting code continue, as is the behavior of normal Roblox events. This method "..
						"can also be called on the connection object which is returned from Signal:connect to only "..
						"disconnect a single handler, as opposed to this method, which will disconnect all handlers."
				end
				if funcNameOrFunc == "Create" then
					return "Function Create. "..
						"Arguments: A table containing information about how to construct a collection of objects. "..
						"Returns: The constructed objects. "..
						"Descrition: Create is a very powerfull function, whose description is too long to fit here, and "..
						"is best described via example, please see the wiki page for a description of how to use it."
				end
			end

			--------------------------------------------Documentation Ends----------------------------------------------------------

			return t
		end

		--[[ Name : Gale Fighter ]]--
		-------------------------------------------------------
		--A Collaboration Between makhail07 and KillerDarkness0105

		--Base Animaion by makhail07, attacks by KillerDarkness0105
		-------------------------------------------------------


		local FavIDs = {
			340106355, --Nefl Crystals
			927529620, --Dimension
			876981900, --Fantasy
			398987889, --Ordinary Days
			1117396305, --Oh wait, it's you.
			885996042, --Action Winter Journey
			919231299, --Sprawling Idiot Effigy
			743466274, --Good Day Sunshine
			727411183, --Knife Fight
			1402748531, --The Earth Is Counting On You!
			595230126 --Robot Language
		}



		--The reality of my life isn't real but a Universe -makhail07
		wait(0.2)
		local plr = game:GetService("Players").LocalPlayer
		print('Local User is '..plr.Name)
		print('Gale Fighter Loaded')
		print('The Fighter that is as fast as wind, a true Fighter')
		local char = plr.Character.NullwareReanim
		local hum = char.Humanoid
		local hed = char.Head
		local root = char.HumanoidRootPart
		local rootj = root.RootJoint
		local tors = char.Torso
		local ra = char["Right Arm"]
		local la = char["Left Arm"]
		local rl = char["Right Leg"]
		local ll = char["Left Leg"]
		local neck = tors["Neck"]
		local mouse = plr:GetMouse()
		local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
		local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
		local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)
		local maincolor = BrickColor.new("Institutional white")
		hum.MaxHealth = 200
		hum.Health = 200

		local hrp = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart

		hrp.Name = "HumanoidRootPart"
		hrp.Transparency = 0.5
		hrp.Anchored = false
		if hrp:FindFirstChildOfClass("AlignPosition") then
			hrp:FindFirstChildOfClass("AlignPosition"):Destroy()
		end
		if hrp:FindFirstChildOfClass("AlignOrientation") then
			hrp:FindFirstChildOfClass("AlignOrientation"):Destroy()
		end
		local bp = Instance.new("BodyPosition", hrp)
		bp.Position = hrp.Position
		bp.D = 9999999
		bp.P = 999999999999999
		bp.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		local flinger = Instance.new("BodyAngularVelocity",hrp)
		flinger.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
		flinger.P = 1000000000000000000000000000
		flinger.AngularVelocity = Vector3.new(10000,10000,10000)

		spawn(function()
			while game:GetService("RunService").Heartbeat:Wait() do
				bp.Position = game:GetService("Players").LocalPlayer.Character["NullwareReanim"].Torso.Position
			end
		end)

		-------------------------------------------------------
		--Start Good Stuff--
		-------------------------------------------------------
		cam = game.Workspace.CurrentCamera
		CF = CFrame.new
		angles = CFrame.Angles
		attack = false
		Euler = CFrame.fromEulerAnglesXYZ
		Rad = math.rad
		IT = Instance.new
		BrickC = BrickColor.new
		Cos = math.cos
		Acos = math.acos
		Sin = math.sin
		Asin = math.asin
		Abs = math.abs
		Mrandom = math.random
		Floor = math.floor
		-------------------------------------------------------
		--End Good Stuff--
		-------------------------------------------------------
		necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		RSH, LSH = nil, nil
		RW = Instance.new("Weld")
		LW = Instance.new("Weld")
		RH = tors["Right Hip"]
		LH = tors["Left Hip"]
		RSH = tors["Right Shoulder"]
		LSH = tors["Left Shoulder"]
		RSH.Parent = nil
		LSH.Parent = nil
		RW.Name = "RW"
		RW.Part0 = tors
		RW.C0 = CF(1.5, 0.5, 0)
		RW.C1 = CF(0, 0.5, 0)
		RW.Part1 = ra
		RW.Parent = tors
		LW.Name = "LW"
		LW.Part0 = tors
		LW.C0 = CF(-1.5, 0.5, 0)
		LW.C1 = CF(0, 0.5, 0)
		LW.Part1 = la
		LW.Parent = tors
		vt = Vector3.new
		Effects = {}
		-------------------------------------------------------
		--Start HeartBeat--
		-------------------------------------------------------
		ArtificialHB = Instance.new("BindableEvent", script)
		ArtificialHB.Name = "Heartbeat"
		script:WaitForChild("Heartbeat")

		frame = 1 / 90
		tf = 0
		allowframeloss = false
		tossremainder = false


		lastframe = tick()
		script.Heartbeat:Fire()


		game:GetService("RunService").Heartbeat:connect(function(s, p)
			tf = tf + s
			if tf >= frame then
				if allowframeloss then
					script.Heartbeat:Fire()
					lastframe = tick()
				else
					for i = 1, math.floor(tf / frame) do
						script.Heartbeat:Fire()
					end
					lastframe = tick()
				end
				if tossremainder then
					tf = 0
				else
					tf = tf - frame * math.floor(tf / frame)
				end
			end
		end)
		-------------------------------------------------------
		--End HeartBeat--
		-------------------------------------------------------



		-------------------------------------------------------
		--Start Combo Function--
		-------------------------------------------------------
		local comboing = false
		local combohits = 0
		local combotime = 0
		local maxtime = 65



		function sandbox(var,func)
			local env = getfenv(func)
			local newenv = setmetatable({},{
				__index = function(self,k)
					if k=="script" then
						return var
					else
						return env[k]
					end
				end,
			})
			setfenv(func,newenv)
			return func
		end
		cors = {}
		mas = Instance.new("Model",game:GetService("Lighting"))
		comboframe = Instance.new("ScreenGui")
		Frame1 = Instance.new("Frame")
		Frame2 = Instance.new("Frame")
		TextLabel3 = Instance.new("TextLabel")
		comboframe.Name = "combinserter"
		comboframe.Parent = mas
		Frame1.Name = "combtimegui"
		Frame1.Parent = comboframe
		Frame1.Size = UDim2.new(0, 300, 0, 14)
		Frame1.Position = UDim2.new(0, 900, 0.629999971, 0)
		Frame1.BackgroundColor3 = Color3.new(0, 0, 0)
		Frame1.BorderColor3 = Color3.new(0.0313726, 0.0470588, 0.0627451)
		Frame1.BorderSizePixel = 5
		Frame2.Name = "combtimeoverlay"
		Frame2.Parent = Frame1
		Frame2.Size = UDim2.new(0, 0, 0, 14)
		Frame2.BackgroundColor3 = Color3.new(0, 1, 0)
		Frame2.ZIndex = 2
		TextLabel3.Parent = Frame2
		TextLabel3.Transparency = 0
		TextLabel3.Size = UDim2.new(0, 300, 0, 50)
		TextLabel3.Text ="Hits: "..combohits
		TextLabel3.Position = UDim2.new(0, 0, -5.5999999, 0)
		TextLabel3.BackgroundColor3 = Color3.new(1, 1, 1)
		TextLabel3.BackgroundTransparency = 1
		TextLabel3.Font = Enum.Font.Bodoni
		TextLabel3.FontSize = Enum.FontSize.Size60
		TextLabel3.TextColor3 = Color3.new(0, 1, 0)
		TextLabel3.TextStrokeTransparency = 0
		gui = game:GetService("Players").LocalPlayer.PlayerGui
		for i,v in pairs(mas:GetChildren()) do
			v.Parent = game:GetService("Players").LocalPlayer.PlayerGui
			pcall(function() v:MakeJoints() end)
		end
		mas:Destroy()
		for i,v in pairs(cors) do
			spawn(function()
				pcall(v)
			end)
		end





		coroutine.resume(coroutine.create(function()
			while true do
				wait()


				if combotime>65 then
					combotime = 65
				end





				if combotime>.1 and comboing == true then
					TextLabel3.Transparency = 0
					TextLabel3.TextStrokeTransparency = 0
					TextLabel3.BackgroundTransparency = 1
					Frame1.Transparency = 0
					Frame2.Transparency = 0
					TextLabel3.Text ="Hits: "..combohits
					combotime = combotime - .34
					Frame2.Size = Frame2.Size:lerp(UDim2.new(0, combotime/maxtime*300, 0, 14),0.42)
				end




				if combotime<.1 then
					TextLabel3.BackgroundTransparency = 1
					TextLabel3.Transparency = 1
					TextLabel3.TextStrokeTransparency = 1

					Frame2.Size = UDim2.new(0, 0, 0, 14)
					combotime = 0
					comboing = false
					Frame1.Transparency = 1
					Frame2.Transparency = 1
					combohits = 0

				end
			end
		end))



		-------------------------------------------------------
		--End Combo Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--Start Important Functions--
		-------------------------------------------------------
		function swait(num)
			if num == 0 or num == nil then
				game:service("RunService").Stepped:wait(0)
			else
				for i = 0, num do
					game:service("RunService").Stepped:wait(0)
				end
			end
		end
		function thread(f)
			coroutine.resume(coroutine.create(f))
		end
		function clerp(a, b, t)
			local qa = {
				QuaternionFromCFrame(a)
			}
			local qb = {
				QuaternionFromCFrame(b)
			}
			local ax, ay, az = a.x, a.y, a.z
			local bx, by, bz = b.x, b.y, b.z
			local _t = 1 - t
			return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
		end
		function QuaternionFromCFrame(cf)
			local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
			local trace = m00 + m11 + m22
			if trace > 0 then
				local s = math.sqrt(1 + trace)
				local recip = 0.5 / s
				return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
			else
				local i = 0
				if m00 < m11 then
					i = 1
				end
				if m22 > (i == 0 and m00 or m11) then
					i = 2
				end
				if i == 0 then
					local s = math.sqrt(m00 - m11 - m22 + 1)
					local recip = 0.5 / s
					return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
				elseif i == 1 then
					local s = math.sqrt(m11 - m22 - m00 + 1)
					local recip = 0.5 / s
					return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
				elseif i == 2 then
					local s = math.sqrt(m22 - m00 - m11 + 1)
					local recip = 0.5 / s
					return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
				end
			end
		end
		function QuaternionToCFrame(px, py, pz, x, y, z, w)
			local xs, ys, zs = x + x, y + y, z + z
			local wx, wy, wz = w * xs, w * ys, w * zs
			local xx = x * xs
			local xy = x * ys
			local xz = x * zs
			local yy = y * ys
			local yz = y * zs
			local zz = z * zs
			return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
		end
		function QuaternionSlerp(a, b, t)
			local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
			local startInterp, finishInterp
			if cosTheta >= 1.0E-4 then
				if 1 - cosTheta > 1.0E-4 then
					local theta = math.acos(cosTheta)
					local invSinTheta = 1 / Sin(theta)
					startInterp = Sin((1 - t) * theta) * invSinTheta
					finishInterp = Sin(t * theta) * invSinTheta
				else
					startInterp = 1 - t
					finishInterp = t
				end
			elseif 1 + cosTheta > 1.0E-4 then
				local theta = math.acos(-cosTheta)
				local invSinTheta = 1 / Sin(theta)
				startInterp = Sin((t - 1) * theta) * invSinTheta
				finishInterp = Sin(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
			end
			return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
		end
		function rayCast(Position, Direction, Range, Ignore)
			return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
		end
		local RbxUtility = LoadLibrary("RbxUtility")
		local Create = RbxUtility.Create

		-------------------------------------------------------
		--Start Damage Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--End Damage Function--
		-------------------------------------------------------

		-------------------------------------------------------
		--Start Damage Function Customization--
		-------------------------------------------------------
		function ShowDamage(Pos, Text, Time, Color)
			local Rate = (1 / 30)
			local Pos = (Pos or Vector3.new(0, 0, 0))
			local Text = (Text or "")
			local Time = (Time or 2)
			local Color = (Color or Color3.new(1, 0, 1))
			local EffectPart = CFuncs.Part.Create(workspace, "SmoothPlastic", 0, 1, BrickColor.new(Color), "Effect", Vector3.new(0, 0, 0))
			EffectPart.Anchored = true
			local BillboardGui = Create("BillboardGui"){
				Size = UDim2.new(3, 0, 3, 0),
				Adornee = EffectPart,
				Parent = EffectPart,
			}
			local TextLabel = Create("TextLabel"){
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 1, 0),
				Text = Text,
				Font = "Bodoni",
				TextColor3 = Color,
				TextScaled = true,
				TextStrokeColor3 = Color3.fromRGB(0,0,0),
				Parent = BillboardGui,
			}
			game.Debris:AddItem(EffectPart, (Time))
			EffectPart.Parent = game:GetService("Workspace")
			delay(0, function()
				local Frames = (Time / Rate)
				for Frame = 1, Frames do
					wait(Rate)
					local Percent = (Frame / Frames)
					EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
					TextLabel.TextTransparency = Percent
				end
				if EffectPart and EffectPart.Parent then
					EffectPart:Destroy()
				end
			end)
		end
		-------------------------------------------------------
		--End Damage Function Customization--
		-------------------------------------------------------

		CFuncs = {
			Part = {
				Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
					local Part = Create("Part")({
						Parent = Parent,
						Reflectance = Reflectance,
						Transparency = Transparency,
						CanCollide = false,
						Locked = true,
						BrickColor = BrickColor.new(tostring(BColor)),
						Name = Name,
						Size = Size,
						Material = Material
					})
					RemoveOutlines(Part)
					return Part
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Mesh = {
				Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)
					local Msh = Create(Mesh)({
						Parent = Part,
						Offset = OffSet,
						Scale = Scale
					})
					if Mesh == "SpecialMesh" then
						Msh.MeshType = MeshType
						Msh.MeshId = MeshId
					end
					return Msh
				end
			},
			Weld = {
				Create = function(Parent, Part0, Part1, C0, C1)
					local Weld = Create("Weld")({
						Parent = Parent,
						Part0 = Part0,
						Part1 = Part1,
						C0 = C0,
						C1 = C1
					})
					return Weld
				end
			},
			Sound = {
				Create = function(id, par, vol, pit)
					coroutine.resume(coroutine.create(function()
						local S = Create("Sound")({
							Volume = vol,
							Pitch = pit or 1,
							SoundId = id,
							Parent = par or workspace
						})
						wait()
						S:play()
						game:GetService("Debris"):AddItem(S, 6)
					end))
				end
			},
			ParticleEmitter = {
				Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)
					local fp = Create("ParticleEmitter")({
						Parent = Parent,
						Color = ColorSequence.new(Color1, Color2),
						LightEmission = LightEmission,
						Size = Size,
						Texture = Texture,
						Transparency = Transparency,
						ZOffset = ZOffset,
						Acceleration = Accel,
						Drag = Drag,
						LockedToPart = LockedToPart,
						VelocityInheritance = VelocityInheritance,
						EmissionDirection = EmissionDirection,
						Enabled = Enabled,
						Lifetime = LifeTime,
						Rate = Rate,
						Rotation = Rotation,
						RotSpeed = RotSpeed,
						Speed = Speed,
						VelocitySpread = VelocitySpread
					})
					return fp
				end
			}
		}
		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end
		function CreatePart(FormFactor, Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part")({
				formFactor = FormFactor,
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material
			})
			RemoveOutlines(Part)
			return Part
		end
		function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh)({
				Parent = Part,
				Offset = OffSet,
				Scale = Scale
			})
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end
		function CreateWeld(Parent, Part0, Part1, C0, C1)
			local Weld = Create("Weld")({
				Parent = Parent,
				Part0 = Part0,
				Part1 = Part1,
				C0 = C0,
				C1 = C1
			})
			return Weld
		end


		-------------------------------------------------------
		--Start Effect Function--
		-------------------------------------------------------
		EffectModel = Instance.new("Model", char)
		Effects = {
			Block = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					if Type == 1 or Type == nil then
						table.insert(Effects, {
							prt,
							"Block1",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					elseif Type == 2 then
						table.insert(Effects, {
							prt,
							"Block2",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					else
						table.insert(Effects, {
							prt,
							"Block3",
							delay,
							x3,
							y3,
							z3,
							msh
						})
					end
				end
			},
			Sphere = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Cylinder = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Wave = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1 / 60, y1 / 60, z1 / 60))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3 / 60,
						y3 / 60,
						z3 / 60,
						msh
					})
				end
			},
			Ring = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://3270017", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Break = {
				Create = function(brickcolor, cframe, x1, y1, z1)
					local prt = CFuncs.Part.Create(EffectModel, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
					prt.Anchored = true
					prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					local num = math.random(10, 50) / 1000
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Shatter",
						num,
						prt.CFrame,
						math.random() - math.random(),
						0,
						math.random(50, 100) / 100
					})
				end
			},
			Spiral = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://1051557", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			},
			Push = {
				Create = function(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
					local prt = CFuncs.Part.Create(EffectModel, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
					prt.Anchored = true
					prt.CFrame = cframe
					local msh = CFuncs.Mesh.Create("SpecialMesh", prt, "FileMesh", "rbxassetid://437347603", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
					game:GetService("Debris"):AddItem(prt, 10)
					table.insert(Effects, {
						prt,
						"Cylinder",
						delay,
						x3,
						y3,
						z3,
						msh
					})
				end
			}
		}
		function part(formfactor ,parent, reflectance, transparency, brickcolor, name, size)
			local fp = IT("Part")
			fp.formFactor = formfactor
			fp.Parent = parent
			fp.Reflectance = reflectance
			fp.Transparency = transparency
			fp.CanCollide = false
			fp.Locked = true
			fp.BrickColor = brickcolor
			fp.Name = name
			fp.Size = size
			fp.Position = tors.Position
			RemoveOutlines(fp)
			fp.Material = "SmoothPlastic"
			fp:BreakJoints()
			return fp
		end

		function mesh(Mesh,part,meshtype,meshid,offset,scale)
			local mesh = IT(Mesh)
			mesh.Parent = part
			if Mesh == "SpecialMesh" then
				mesh.MeshType = meshtype
				if meshid ~= "nil" then
					mesh.MeshId = "http://www.roblox.com/asset/?id="..meshid
				end
			end
			mesh.Offset = offset
			mesh.Scale = scale
			return mesh
		end

		function Magic(bonuspeed, type, pos, scale, value, color, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = scale
			local scaler2 = 1
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, scaler2 * bonuspeed)
				end
				rng:Destroy()
			end))
		end

		function Eviscerate(dude)
			if dude.Name ~= char then
				local bgf = IT("BodyGyro", dude.Head)
				bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local ds = coroutine.wrap(function()
					dude:WaitForChild("Head"):BreakJoints()
					wait(0.5)
					target = nil
					coroutine.resume(coroutine.create(function()
						for i, v in pairs(dude:GetChildren()) do
							if v:IsA("Accessory") then
								v:Destroy()
							end
							if v:IsA("Humanoid") then
								v:Destroy()
							end
							if v:IsA("CharacterMesh") then
								v:Destroy()
							end
							if v:IsA("Model") then
								v:Destroy()
							end
							if v:IsA("Part") or v:IsA("MeshPart") then
								for x, o in pairs(v:GetChildren()) do
									if o:IsA("Decal") then
										o:Destroy()
									end
								end
								coroutine.resume(coroutine.create(function()
									v.Material = "Neon"
									v.CanCollide = false
									local PartEmmit1 = IT("ParticleEmitter", v)
									PartEmmit1.LightEmission = 1
									PartEmmit1.Texture = "rbxassetid://284205403"
									PartEmmit1.Color = ColorSequence.new(maincolor.Color)
									PartEmmit1.Rate = 150
									PartEmmit1.Lifetime = NumberRange.new(1)
									PartEmmit1.Size = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0.75, 0),
										NumberSequenceKeypoint.new(1, 0, 0)
									})
									PartEmmit1.Transparency = NumberSequence.new({
										NumberSequenceKeypoint.new(0, 0, 0),
										NumberSequenceKeypoint.new(1, 1, 0)
									})
									PartEmmit1.Speed = NumberRange.new(0, 0)
									PartEmmit1.VelocitySpread = 30000
									PartEmmit1.Rotation = NumberRange.new(-500, 500)
									PartEmmit1.RotSpeed = NumberRange.new(-500, 500)
									local BodPoss = IT("BodyPosition", v)
									BodPoss.P = 3000
									BodPoss.D = 1000
									BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
									BodPoss.position = v.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
									v.Color = maincolor.Color
									coroutine.resume(coroutine.create(function()
										for i = 0, 49 do
											swait(1)
											v.Transparency = v.Transparency + 0.08
										end
										wait(0.5)
										PartEmmit1.Enabled = false
										wait(3)
										v:Destroy()
										dude:Destroy()
									end))
								end))
							end
						end
					end))
				end)
				ds()
			end
		end

		function FindNearestHead(Position, Distance, SinglePlayer)
			if SinglePlayer then
				return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
			end
			local List = {}
			for i, v in pairs(workspace:GetChildren()) do
				if v:IsA("Model") and v:findFirstChild("Head") and v ~= char and Distance >= (v.Head.Position - Position).magnitude then
					table.insert(List, v)
				end
			end
			return List
		end

		function Aura(bonuspeed, FastSpeed, type, pos, x1, y1, z1, value, color, outerpos, MType)
			local type = type
			local rng = Instance.new("Part", char)
			rng.Anchored = true
			rng.BrickColor = color
			rng.CanCollide = false
			rng.FormFactor = 3
			rng.Name = "Ring"
			rng.Material = "Neon"
			rng.Size = Vector3.new(1, 1, 1)
			rng.Transparency = 0
			rng.TopSurface = 0
			rng.BottomSurface = 0
			rng.CFrame = pos
			rng.CFrame = rng.CFrame + rng.CFrame.lookVector * outerpos
			local rngm = Instance.new("SpecialMesh", rng)
			rngm.MeshType = MType
			rngm.Scale = Vector3.new(x1, y1, z1)
			local scaler2 = 1
			local speeder = FastSpeed
			if type == "Add" then
				scaler2 = 1 * value
			elseif type == "Divide" then
				scaler2 = 1 / value
			end
			coroutine.resume(coroutine.create(function()
				for i = 0, 10 / bonuspeed, 0.1 do
					swait()
					if type == "Add" then
						scaler2 = scaler2 - 0.01 * value / bonuspeed
					elseif type == "Divide" then
						scaler2 = scaler2 - 0.01 / value * bonuspeed
					end
					speeder = speeder - 0.01 * FastSpeed * bonuspeed
					rng.CFrame = rng.CFrame + rng.CFrame.lookVector * speeder * bonuspeed
					rng.Transparency = rng.Transparency + 0.01 * bonuspeed
					rngm.Scale = rngm.Scale + Vector3.new(scaler2 * bonuspeed, scaler2 * bonuspeed, 0)
				end
				rng:Destroy()
			end))
		end

		function SoulSteal(dude)
			if dude.Name ~= char then
				local bgf = IT("BodyGyro", dude.Head)
				bgf.CFrame = bgf.CFrame * CFrame.fromEulerAnglesXYZ(Rad(-90), 0, 0)
				local val = IT("BoolValue", dude)
				val.Name = "IsHit"
				local torso = (dude:FindFirstChild'Head' or dude:FindFirstChild'Torso' or dude:FindFirstChild'UpperTorso' or dude:FindFirstChild'LowerTorso' or dude:FindFirstChild'HumanoidRootPart')
				local soulst = coroutine.wrap(function()
					local soul = Instance.new("Part",dude)
					soul.Size = Vector3.new(1,1,1)
					soul.CanCollide = false
					soul.Anchored = false
					soul.Position = torso.Position
					soul.Transparency = 1
					local PartEmmit1 = IT("ParticleEmitter", soul)
					PartEmmit1.LightEmission = 1
					PartEmmit1.Texture = "rbxassetid://569507414"
					PartEmmit1.Color = ColorSequence.new(maincolor.Color)
					PartEmmit1.Rate = 250
					PartEmmit1.Lifetime = NumberRange.new(1.6)
					PartEmmit1.Size = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 1, 0),
						NumberSequenceKeypoint.new(1, 0, 0)
					})
					PartEmmit1.Transparency = NumberSequence.new({
						NumberSequenceKeypoint.new(0, 0, 0),
						NumberSequenceKeypoint.new(1, 1, 0)
					})
					PartEmmit1.Speed = NumberRange.new(0, 0)
					PartEmmit1.VelocitySpread = 30000
					PartEmmit1.Rotation = NumberRange.new(-360, 360)
					PartEmmit1.RotSpeed = NumberRange.new(-360, 360)
					local BodPoss = IT("BodyPosition", soul)
					BodPoss.P = 3000
					BodPoss.D = 1000
					BodPoss.maxForce = Vector3.new(50000000000, 50000000000, 50000000000)
					BodPoss.position = torso.Position + Vector3.new(Mrandom(-15, 15), Mrandom(-15, 15), Mrandom(-15, 15))
					wait(1.6)
					soul.Touched:connect(function(hit)
						if hit.Parent == char then
							soul:Destroy()
						end
					end)
					wait(1.2)
					while soul do
						swait()
						PartEmmit1.Color = ColorSequence.new(maincolor.Color)
						BodPoss.Position = tors.Position
					end
				end)
				soulst()
			end
		end




		--killer's effects





		function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
			local Part = Create("Part"){
				Parent = Parent,
				Reflectance = Reflectance,
				Transparency = Transparency,
				CanCollide = false,
				Locked = true,
				BrickColor = BrickColor.new(tostring(BColor)),
				Name = Name,
				Size = Size,
				Material = Material,
			}
			RemoveOutlines(Part)
			return Part
		end

		function CreateMesh(Mesh, Part, MeshType, MeshId, OffSet, Scale)
			local Msh = Create(Mesh){
				Parent = Part,
				Offset = OffSet,
				Scale = Scale,
			}
			if Mesh == "SpecialMesh" then
				Msh.MeshType = MeshType
				Msh.MeshId = MeshId
			end
			return Msh
		end



		function BlockEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay, Type)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("BlockMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			if Type == 1 or Type == nil then
				table.insert(Effects, {
					prt,
					"Block1",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			elseif Type == 2 then
				table.insert(Effects, {
					prt,
					"Block2",
					delay,
					x3,
					y3,
					z3,
					msh
				})
			end
		end

		function SphereEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end

		function RingEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt=CreatePart(workspace,"Neon",0,0,brickcolor,"Effect",vt(.5,.5,.5))--part(3,workspace,"SmoothPlastic",0,0,brickcolor,"Effect",vt(0.5,0.5,0.5))
			prt.Anchored=true
			prt.CFrame=cframe
			msh=CreateMesh("SpecialMesh",prt,"FileMesh","http://www.roblox.com/asset/?id=3270017",vt(0,0,0),vt(x1,y1,z1))
			game:GetService("Debris"):AddItem(prt,2)
			coroutine.resume(coroutine.create(function(Part,Mesh,num)
				for i=0,1,delay do
					swait()
					Part.Transparency=i
					Mesh.Scale=Mesh.Scale+vt(x3,y3,z3)
				end
				Part.Parent=nil
			end),prt,msh,(math.random(0,1)+math.random())/5)
		end

		function CylinderEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "SmoothPlastic", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("CylinderMesh", prt, "", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end

		function WaveEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://20329976", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end

		function SpecialEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://24388358", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end


		function MoonEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "FileMesh", "rbxassetid://259403370", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end

		function HeadEffect(brickcolor, cframe, x1, y1, z1, x3, y3, z3, delay)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new())
			prt.Anchored = true
			prt.CFrame = cframe
			local msh = CreateMesh("SpecialMesh", prt, "Head", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Cylinder",
				delay,
				x3,
				y3,
				z3,
				msh
			})
		end

		function BreakEffect(brickcolor, cframe, x1, y1, z1)
			local prt = CreatePart(workspace, "Neon", 0, 0, brickcolor, "Effect", Vector3.new(0.5, 0.5, 0.5))
			prt.Anchored = true
			prt.CFrame = cframe * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
			local msh = CreateMesh("SpecialMesh", prt, "Sphere", "", Vector3.new(0, 0, 0), Vector3.new(x1, y1, z1))
			local num = math.random(10, 50) / 1000
			game:GetService("Debris"):AddItem(prt, 10)
			table.insert(Effects, {
				prt,
				"Shatter",
				num,
				prt.CFrame,
				math.random() - math.random(),
				0,
				math.random(50, 100) / 100
			})
		end





		so = function(id,par,vol,pit)
			coroutine.resume(coroutine.create(function()
				local sou = Instance.new("Sound",par or workspace)
				sou.Volume=vol
				sou.Pitch=pit or 1
				sou.SoundId=id
				sou:play()
				game:GetService("Debris"):AddItem(sou,8)
			end))
		end


		--end of killer's effects


		function FaceMouse()
			local Cam = workspace.CurrentCamera
			return {
				CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
				Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
			}
		end
		-------------------------------------------------------
		--End Effect Function--
		-------------------------------------------------------
		function Cso(ID, PARENT, VOLUME, PITCH)
			local NSound = nil
			coroutine.resume(coroutine.create(function()
				NSound = IT("Sound", PARENT)
				NSound.Volume = VOLUME
				NSound.Pitch = PITCH
				NSound.SoundId = "http://www.roblox.com/asset/?id="..ID
				swait()
				NSound:play()
				game:GetService("Debris"):AddItem(NSound, 10)
			end))
			return NSound
		end
		function CameraEnshaking(Length, Intensity)
			coroutine.resume(coroutine.create(function()
				local intensity = 1 * Intensity
				local rotM = 0.01 * Intensity
				for i = 0, Length, 0.1 do
					swait()
					intensity = intensity - 0.05 * Intensity / Length
					rotM = rotM - 5.0E-4 * Intensity / Length
					hum.CameraOffset = Vector3.new(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)))
					cam.CFrame = cam.CFrame * CF(Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity)), Rad(Mrandom(-intensity, intensity))) * Euler(Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM, Rad(Mrandom(-intensity, intensity)) * rotM)
				end
				hum.CameraOffset = Vector3.new(0, 0, 0)
			end))
		end
		-------------------------------------------------------
		--End Important Functions--
		-------------------------------------------------------


		-------------------------------------------------------
		--Start Customization--
		-------------------------------------------------------
		local Player_Size = 1
		if Player_Size ~= 1 then
			root.Size = root.Size * Player_Size
			tors.Size = tors.Size * Player_Size
			hed.Size = hed.Size * Player_Size
			ra.Size = ra.Size * Player_Size
			la.Size = la.Size * Player_Size
			rl.Size = rl.Size * Player_Size
			ll.Size = ll.Size * Player_Size
			----------------------------------------------------------------------------------
			rootj.Parent = root
			neck.Parent = tors
			RW.Parent = tors
			LW.Parent = tors
			RH.Parent = tors
			LH.Parent = tors
			----------------------------------------------------------------------------------
			rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
			neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
			neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
			RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
			LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
			----------------------------------------------------------------------------------
			RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
			--hat.Parent = Character
		end
		----------------------------------------------------------------------------------
		local SONG = 900817147 --900817147
		local SONG2 = 0
		local Music = Instance.new("Sound",tors)
		Music.Volume = 0.7
		Music.Looped = true
		Music.Pitch = 1 --Pitcher
		----------------------------------------------------------------------------------
		local equipped = false
		local idle = 0
		local change = 1
		local val = 0
		local toim = 0
		local idleanim = 0.4
		local sine = 0
		local Sit = 1
		local attacktype = 1
		local attackdebounce = false
		local euler = CFrame.fromEulerAnglesXYZ
		local cankick = false
		----------------------------------------------------------------------------------
		hum.WalkSpeed = 8
		hum.JumpPower = 57
--[[
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
]]
		local ANIMATOR = hum.Animator
		local ANIMATE = char.Animate
		ANIMATE.Parent = nil
		ANIMATOR.Parent = nil
		-------------------------------------------------------
		--End Customization--
		-------------------------------------------------------


		-------------------------------------------------------
		--Start Attacks N Stuff--
		-------------------------------------------------------

		--pls be proud mak i did my best



		function attackone()

			attack = true

			for i = 0, 1.35, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4-2*i), math.rad(4+2*i), math.rad(-40-11*i)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(40+11*i)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.6, 0.2) * angles(math.rad(90+4*i), math.rad(-43), math.rad(16+6*i)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-43)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, 0) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, -0.2) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
			end

			so("http://roblox.com/asset/?id=1340545854",ra,1,math.random(0.7,1))


			con5=ra.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true

						so("http://roblox.com/asset/?id=636494529",ra,2,1)

						RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("White"),ra.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
							end
						end))


						wait(0.34)
						attackdebounce = false

					end
				end
			end)
			for i = 0, 1.12, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(6), math.rad(23)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(-23)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.3, 0.6, -0.8) * angles(math.rad(110), math.rad(23), math.rad(2)), 0.4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0.2) * angles(math.rad(-37), math.rad(0), math.rad(-13)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, -0.3) * RHCF * angles(math.rad(-4), math.rad(0), math.rad(6)), 0.3)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, 0.05) * LHCF * angles(math.rad(-22), math.rad(0), math.rad(23)), 0.3)
			end

			con5:Disconnect()
			attack = false

		end












		function attacktwo()

			attack = true

			for i = 0, 1.35, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(46)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(6)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-24), math.rad(0), math.rad(0)), 0.2)
			end

			so("http://roblox.com/asset/?id=1340545854",la,1,math.random(0.7,1))


			con5=la.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true

						so("http://roblox.com/asset/?id=636494529",la,2,1)

						RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("White"),la.CFrame*CFrame.new(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
							end
						end))


						wait(0.34)
						attackdebounce = false

					end
				end
			end)




			for i = 0, 1.12, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.9, -0) * angles(math.rad(14), math.rad(-6), math.rad(-27)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-4), math.rad(0), math.rad(27)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0.16) * angles(math.rad(-33), math.rad(0), math.rad(23)), 0.4)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.3, 0.67, -0.9) * angles(math.rad(116), math.rad(-28), math.rad(1)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -1, 0.05) * RHCF * angles(math.rad(-22), math.rad(0), math.rad(-18)), 0.3)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -1, -0.3) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(4)), 0.3)
			end

			con5:Disconnect()
			attack = false

		end





		function attackthree()

			attack = true


			for i = 0, 1.14, 0.1 do
				swait()
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-4), math.rad(-4), math.rad(40)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(-40)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(90), math.rad(0), math.rad(-46)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.6, 0.2) * angles(math.rad(90), math.rad(23), math.rad(36)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.7, -0.2) * RHCF * angles(math.rad(-34), math.rad(0), math.rad(-17)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-12), math.rad(0), math.rad(34)), 0.2)
			end

			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true

						so("http://roblox.com/asset/?id=636494529",ll,2,1)

						RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("White"),ll.CFrame*CF(0,-1,0)*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
							end
						end))


						wait(0.34)
						attackdebounce = false

					end
				end
			end)

			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 0, 9.14, 0.3 do
				swait()
				BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-54*i)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
			end
			attack = false
			con5:disconnect()
		end



		function attackfour()

			attack = true
			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
			WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
			for i = 0, 5.14, 0.1 do
				swait()
				SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24+4*i), math.rad(0), math.rad(0)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0+11*i), math.rad(0), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(36+4*i)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(0-6*i), math.rad(0), math.rad(-36-4*i)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28+4*i)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34-4*i)), 0.2)
			end
			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			local velo=Instance.new("BodyVelocity")
			velo.velocity=vt(0,25,0)
			velo.P=8000
			velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
			velo.Parent=root
			game:GetService("Debris"):AddItem(velo,0.7)



			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.6,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,1)
						RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8),math.random(-0.75*1.8,0.75*1.8)),0.44)
							end
						end))


						wait(0.14)
						attackdebounce = false
					end
				end
			end)

			for i = 0, 5.11, 0.15 do
				swait()
				BlockEffect(BrickColor.new("White"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.2*i) * angles(math.rad(-10-80*i), math.rad(0), math.rad(0)), 0.42)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
			end


			attack = false
			con5:disconnect()
		end





		local cooldown = false
		function quickkick()
			attack = true


			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true

						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.3,-1.8)
							end
						end))

						so("http://roblox.com/asset/?id=636494529",rl,2,1)
						RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8),math.random(-0.8*1.8,0.8*1.8)),0.44)
							end
						end))


						wait(0.08)
						attackdebounce = false
					end
				end
			end)

			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 0, 11.14, 0.3 do
				swait()
				root.Velocity = root.CFrame.lookVector * 30
				BlockEffect(BrickColor.new("White"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-90*i)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
			end
			attack = false
			con5:disconnect()
		end








		function Taunt()
			attack = true
			hum.WalkSpeed = 0
			Cso("1535995570", hed, 8.45, 1)
			for i = 0, 8.2, 0.1 do
				swait()
				hum.WalkSpeed = 0
				rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25), Rad(0), Rad(16 * Cos(sine / 12))), 0.2)
				RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
				LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(0)), 0.1)
				RW.C0 = clerp(RW.C0, CF(1.1* Player_Size, 0.5 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(180), Rad(6), Rad(-56)), 0.1)
				LW.C0 = clerp(LW.C0, CF(-1* Player_Size, 0.1 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(45), Rad(6), Rad(86)), 0.1)
			end
			attack = false
			hum.WalkSpeed = 8
		end







		function Hyperkickcombo()

			attack = true
			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
			WaveEffect(BrickColor.new("White"), root.CFrame * CFrame.new(0, -1, 0) * euler(0, math.random(-50, 50), 0), 1, 1, 1, 1, 0.5, 1, 0.05)
			for i = 0, 7.14, 0.1 do
				swait()
				SphereEffect(BrickColor.new("White"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(36)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-20), math.rad(0), math.rad(-36)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
			end
			local Cracking = Cso("292536356", tors, 10, 1)
			for i = 0, 7.14, 0.1 do
				swait()
				hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
				Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Lime green", 0, "Sphere")
				WaveEffect(BrickColor.new("Lime green"), root.CFrame * CFrame.new(0, -6, 0) * euler(0, math.random(-25, 25), 0), 1, 1, 1, 1, 0.2, 1, 0.05)
				SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				SphereEffect(BrickColor.new("Lime green"),ll.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.8) * angles(math.rad(24), math.rad(0), math.rad(0)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(30), math.rad(0), math.rad(0)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(36)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(20), math.rad(0), math.rad(-36)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.6, -0.3) * RHCF * angles(math.rad(0), math.rad(0), math.rad(-28)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.2, -0.5) * LHCF * angles(math.rad(0), math.rad(0), math.rad(-34)), 0.2)
			end
			Cracking.Playing = false
			so("http://www.roblox.com/asset/?id=197161452", char, 3, 0.8)
			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			SphereEffect(BrickColor.new("Lime green"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)
			local velo=Instance.new("BodyVelocity")
			velo.velocity=vt(0,27,0)
			velo.P=11000
			velo.maxForce=Vector3.new(math.huge, math.huge, math.huge)
			velo.Parent=root
			game:GetService("Debris"):AddItem(velo,1.24)



			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,3.4,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))


						wait(0.09)
						attackdebounce = false
					end
				end
			end)

			for i = 0, 9.11, 0.2 do
				swait()
				BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, 0.1+0.12*i) * angles(math.rad(-10-95*i), math.rad(0), math.rad(0)), 0.42)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(-43), math.rad(0), math.rad(0)), 0.42)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(60)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(-8), math.rad(0), math.rad(-60)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.5, 0) * RHCF * angles(math.rad(0), math.rad(0), math.rad(20+10*i)), 0.42)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.5, -0.4) * LHCF * angles(math.rad(0), math.rad(0), math.rad(24)), 0.42)
			end




			con5:disconnect()






			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))


						wait(0.08)
						attackdebounce = false
					end
				end
			end)



			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 0, 9.14, 0.3 do
				swait()
				root.Velocity = root.CFrame.lookVector * 20
				BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(53), math.rad(8), math.rad(0-54*i)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
			end



			con5:disconnect()



			con5=hum.Touched:connect(function(hit)
				if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
					if attackdebounce == false then
						attackdebounce = true
						coroutine.resume(coroutine.create(function()
							for i = 0,1.5,0.1 do
								swait()
								hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
							end
						end))
						so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
						SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



						coroutine.resume(coroutine.create(function()
							for i = 0,1,0.1 do
								swait()
								hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
							end
						end))


						wait(0.05)
						attackdebounce = false
					end
				end
			end)


			so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
			for i = 0, 15.14, 0.32 do
				swait()
				root.Velocity = root.CFrame.lookVector * 20
				BlockEffect(BrickColor.new("Lime green"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-50*i), math.rad(8+20*i), math.rad(0-90*i)), 0.35)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
				RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
				RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-2*i), math.rad(0), math.rad(0-4*i)), 0.35)
			end

			attack = false
			con5:disconnect()

		end





		local ultra = false

		function Galekicks()

			attack = true
			so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 3, 1)
			for i = 0, 1.65, 0.1 do
				swait()
				root.Velocity = root.CFrame.lookVector * 0
				SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
				rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
				tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
				RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
				LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
				RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
				LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
			end


			for i = 1, 17 do

				con5=hum.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if attackdebounce == false then
							attackdebounce = true
							coroutine.resume(coroutine.create(function()
								for i = 0,1.5,0.1 do
									swait()
									hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
								end
							end))
							so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
							RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							RingEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							SphereEffect(BrickColor.new("Lime green"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



							coroutine.resume(coroutine.create(function()
								for i = 0,1,0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
								end
							end))


							wait(0.05)
							attackdebounce = false
						end
					end
				end)

				for i = 0, .1, 0.2 do
					swait()
					BlockEffect(BrickColor.new("Lime green"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
					root.Velocity = root.CFrame.lookVector * 10
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
				end

				so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))

				for i = 0, 0.4, 0.2 do
					swait()
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end
				con5:disconnect()
			end


			u = mouse.KeyDown:connect(function(key)
				if key == 'r' and combohits >= 150 then
					ultra = true
					SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,15,15,15,0.04)
				end
			end)
			wait(0.3)
			if ultra == true then
				combohits = 0
				wait(0.1)
				for i = 0, 1.65, 0.1 do
					swait()
					root.Velocity = root.CFrame.lookVector * 0
					SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end


				so("http://roblox.com/asset/?id=146094803",hed,1,1.2)

				for i = 1, 65 do
					--Aura(5, 0.15, "Add" , root.CFrame * CF(Mrandom(-12, 12), -6, Mrandom(-12, 12)) * angles(Rad(90 + Mrandom(-12, 12)), 0, 0), 1.5, 1.5, 10, -0.015, BrickC"Really red", 0, "Brick")
					con5=hum.Touched:connect(function(hit)
						if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
							if attackdebounce == false then
								attackdebounce = true
								coroutine.resume(coroutine.create(function()
									for i = 0,1.5,0.1 do
										swait()
										hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
									end
								end))
								so("http://roblox.com/asset/?id=636494529",rl,2,1.6)
								RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
								RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
								SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)



								coroutine.resume(coroutine.create(function()
									for i = 0,1,0.1 do
										swait()
										hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
									end
								end))


								wait(0.05)
								attackdebounce = false
							end
						end
					end)

					for i = 0, .03, 0.1 do
						swait()
						BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
						root.Velocity = root.CFrame.lookVector * 10
						rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-44), math.rad(-2), math.rad(90)), 0.7)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-24), math.rad(-90)), 0.7)
						RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.7)
						LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.7)
						RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0) * RHCF * angles(math.rad(math.random(-100,-10)), math.rad(0), math.rad(2)), 0.7)
						LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-34), math.rad(0), math.rad(0)), 0.7)
					end

					so("http://roblox.com/asset/?id=1340545854",rl,1,math.random(0.7,1))

					for i = 0, 0.07, 0.1 do
						swait()
						rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
						RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
						LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
						RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
						LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
					end
					con5:disconnect()
				end

				for i = 0, 1.65, 0.1 do
					swait()
					root.Velocity = root.CFrame.lookVector * 0
					SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-50,50),math.random(-50,50),math.random(-50,50)),1,5,1,.05,4,.05,0.03)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0.7, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, .62 , -0.3) * RHCF * angles(math.rad(-40), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end

				con5=hum.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if attackdebounce == false then
							attackdebounce = true
							coroutine.resume(coroutine.create(function()
								for i = 0,1.5,0.1 do
									swait()
									--hit.Parent.Head.CFrame = root.CFrame * CFrame.new(0,1.1,-1.8)
								end
							end))
							so("http://roblox.com/asset/?id=636494529",rl,2,.63)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							RingEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,.2,2,.2,0.06)
							SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,3,3,3,0.06)


							coroutine.resume(coroutine.create(function()
								for i = 0,1,0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8),math.random(-0.55*1.8,0.55*1.8)),0.34)
								end
							end))


							wait(0.05)
							attackdebounce = false
						end
					end
				end)

				so("http://www.roblox.com/asset/?id=1452040709", RightLeg, 1, 1.4)
				SphereEffect(BrickColor.new("Really red"),rl.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,38,38,38,0.08)

				for i = 0, 2, 0.1 do
					swait()
					--BlockEffect(BrickColor.new("Really red"), rl.CFrame*CF(0,-1,0), 2, 2, 2, 1.5, 1.5, 1.5, 0.03)
					rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, -0.5, -0.3) * angles(math.rad(-32), math.rad(-2), math.rad(90)), 0.2)
					tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(0), math.rad(-17), math.rad(-90)), 0.2)
					RW.C0 = clerp(RW.C0, CFrame.new(1.1, 0.5, -0.6) * angles(math.rad(90), math.rad(0), math.rad(-56)), 0.3)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.2, 0.6, -0.5) * angles(math.rad(90), math.rad(0), math.rad(56)), 0.3)
					RH.C0 = clerp(RH.C0, CFrame.new(1, -.6 , 0.2) * RHCF * angles(math.rad(-50), math.rad(0), math.rad(2)), 0.2)
					LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.7, 0) * LHCF * angles(math.rad(-28), math.rad(0), math.rad(0)), 0.2)
				end
				SphereEffect(BrickColor.new("Really red"),tors.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)

				wait(0.25)
				con5:Disconnect()




				con5=hum.Touched:connect(function(hit)
					if hit.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
						if attackdebounce == false then
							attackdebounce = true

							so("http://roblox.com/asset/?id=565207203",ll,7,0.63)

							RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
							RingEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,2.2,6,2.2,0.04)
							SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
							SpecialEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,8,8,8,0.04)
							SphereEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,5,18,5,0.04)
							WaveEffect(BrickColor.new("Really red"),ll.CFrame*angles(math.random(-360,360),math.random(-360,360),math.random(-360,360)),1,5,1,1.5,16,1.5,0.04)

							coroutine.resume(coroutine.create(function()
								for i = 0,1,0.1 do
									swait()
									hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8),math.random(-0.35*1.8,0.35*1.8)),0.24)
								end
							end))

							wait(0.06)
							attackdebounce = false

						end
					end
				end)

				coroutine.resume(coroutine.create(function()
					while ultra == true do
						swait()
						root.CFrame = root.CFrame*CFrame.new(math.random(-3,3),math.random(-2,2),math.random(-3,3))
					end
				end))


				so("http://www.roblox.com/asset/?id=158475221", RightLeg, 1, 1.3)
				for i = 1,3 do
					for i = 0, 9.14, 0.45 do
						swait()
						root.Velocity = root.CFrame.lookVector * 30
						BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
						rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(8), math.rad(8), math.rad(0-94*i)), 0.35)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
						RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
						LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
						RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(7), math.rad(0), math.rad(4)), 0.35)
						LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-64-7*i), math.rad(0), math.rad(0-9*i)), 0.35)
					end
				end


				for i = 1,3 do
					for i = 0, 11.14, 0.45 do
						swait()
						root.Velocity = root.CFrame.lookVector * 30
						BlockEffect(BrickColor.new("Really red"), ll.CFrame*CF(0,-1,0), 2, 2, 2, 3.5, 3.5, 3.5, 0.05)
						rootj.C0 = clerp(rootj.C0, RootCF * CFrame.new(0, 0, -0.87) * angles(math.rad(-21-30*i), math.rad(8+10*i), math.rad(0-110*i)), 0.35)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko * angles(math.rad(12), math.rad(0), math.rad(24)), 0.35)
						RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(12), math.rad(0), math.rad(62)), 0.35)
						LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.3, 0) * angles(math.rad(12), math.rad(0), math.rad(-23)), 0.35)
						RH.C0 = clerp(RH.C0, CFrame.new(1, -0.17, -0.4) * RHCF * angles(math.rad(27), math.rad(0), math.rad(74)), 0.35)
						LH.C0 = clerp(LH.C0, CFrame.new(-1, -0.13, -0.6) * LHCF * angles(math.rad(-34-2*i), math.rad(0), math.rad(0-9*i)), 0.35)
					end



				end
				so("http://www.roblox.com/asset/?id=197161452", char, 0.5, 0.8)
				con5:disconnect()


			end -- combo hit end
			attack = false
			ultra = false
			u:disconnect()

		end




		-------------------------------------------------------
		--End Attacks N Stuff--
		-------------------------------------------------------
		mouse.KeyDown:connect(function(key)
			if string.byte(key) == 48 then
				Swing = 2
				hum.WalkSpeed = 24.82
			end
		end)
		mouse.KeyUp:connect(function(key)
			if string.byte(key) == 48 then
				Swing = 1
				hum.WalkSpeed = 8
			end
		end)







		mouse.Button1Down:connect(function()
			if attack==false then
				if attacktype==1 then
					attack=true
					attacktype=2
					attackone()
				elseif attacktype==2 then
					attack=true
					attacktype=3
					attacktwo()
				elseif attacktype==3 then
					attack=true
					attacktype=4
					attackthree()
				elseif attacktype==4 then
					attack=true
					attacktype=1
					attackfour()
				end
			end
		end)




		mouse.KeyDown:connect(function(key)
			if key == 'e' and attack == false and cankick == true and cooldown == false then
				quickkick()
				cooldown = true

				coroutine.resume(coroutine.create(function()
					wait(2)
					cooldown = false
				end))



			end
		end)








		mouse.KeyDown:connect(function(key)
			if attack == false then
				if key == 't' then
					Taunt()
				elseif key == 'f' then
					Hyperkickcombo()
				elseif key == 'r' then
					Galekicks()
				end
			end
		end)

		-------------------------------------------------------
		--Start Animations--
		-------------------------------------------------------
		print("By Makhail07 and KillerDarkness0105")
		print("Basic Animations by Makhail07")
		print("Attack Animations by KillerDarkness0105")
		print("This is pretty much our final script together")
		print("--------------------------------")
		print("Attacks")
		print("E in air: Quick Kicks")
		print("Left Mouse: 4 click combo")
		print("F: Hyper Kicks")
		print("R: Gale Kicks, Spam R if your combo is over 150 to do an ultra combo")
		print("--------------------------------")
		while true do
			swait()
			sine = sine + change
			local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
			local velderp = root.Velocity.y
			hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)

			if hitfloor == nil then
				cankick = true
			else
				cankick = false
			end


			if equipped == true or equipped == false then
				if attack == false then
					idle = idle + 1
				else
					idle = 0
				end
				if 1 < root.Velocity.y and hitfloor == nil then
					Anim = "Jump"
					if attack == false then
						hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 20), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(13 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-13 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif -1 > root.Velocity.y and hitfloor == nil then
					Anim = "Fall"
					if attack == false then
						hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
						neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(65), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(55), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
					end
				elseif torvel < 1 and hitfloor ~= nil then
					Anim = "Idle"
					change = 1
					if attack == false then
						hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(20)), 0.1)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-6.5 * Sin(sine / 12)), Rad(0), Rad(-20)), 0.1)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(110), Rad(6 + 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.3* Player_Size, 0.2 + 0.05 * Sin(sine / 12)* Player_Size, -0.5* Player_Size) * angles(Rad(110), Rad(6 - 6.5 * Sin(sine / 12)), Rad(25)), 0.1)
					end
				elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
					Anim = "Walk"
					change = 1
					if attack == false then
						hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-1), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 15 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 15 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 75), 0.1)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-56) * Cos(sine / 7) , Rad(10 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 75), 0.1)
					end
				elseif torvel >= 22 and hitfloor ~= nil then
					Anim = "Sprint"
					change = 1.35
					if attack == false then
						hum.CameraOffset = hum.CameraOffset:lerp(Vector3.new(0,0,0),0.15)
						rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.025 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(26 - 4.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(15 * Cos(sine / 7))), 0.15)
						tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-8.5 - 2 * Sin(sine / 20)), Rad(0), Rad(0) - hed.RotVelocity.Y / 15), 0.15)
						RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.925 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 - 55 * Cos(sine / 7)) - rl.RotVelocity.Y / 75 + -Sin(sine / 7) / 2.5, Rad(90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
						LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.925 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.7 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-15 + 55 * Cos(sine / 7)) + ll.RotVelocity.Y / 75 + Sin(sine / 7) / 2.5, Rad(-90 - 0.1 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 0.1 * Cos(sine / 7)), Rad(0), Rad(0)), 0.3)
						RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, 0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0), Rad(13) - ra.RotVelocity.Y / 75), 0.15)
						LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 30)* Player_Size, -0.34 * Cos(sine / 7* Player_Size)) * angles(Rad(-65) , Rad(0) , Rad(-13) + la.RotVelocity.Y / 75), 0.15)
					end
				end
			end
			Music.SoundId = "rbxassetid://"..SONG
			Music.Looped = true
			Music.Pitch = 1
			Music.Volume = 0.7
			Music.Parent = tors
			Music:Resume()
			if 0 < #Effects then
				for e = 1, #Effects do
					if Effects[e] ~= nil then
						local Thing = Effects[e]
						if Thing ~= nil then
							local Part = Thing[1]
							local Mode = Thing[2]
							local Delay = Thing[3]
							local IncX = Thing[4]
							local IncY = Thing[5]
							local IncZ = Thing[6]
							if 1 >= Thing[1].Transparency then
								if Thing[2] == "Block1" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50))
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block2" then
									Thing[1].CFrame = Thing[1].CFrame + Vector3.new(0, 0, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Block3" then
									Thing[1].CFrame = Thing[1].CFrame * CFrame.fromEulerAnglesXYZ(math.random(-50, 50), math.random(-50, 50), math.random(-50, 50)) + Vector3.new(0, 0.15, 0)
									local Mesh = Thing[7]
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Cylinder" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Blood" then
									local Mesh = Thing[7]
									Thing[1].CFrame = Thing[1].CFrame * Vector3.new(0, 0.5, 0)
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[4], Thing[5], Thing[6])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Elec" then
									local Mesh = Thing[1].Mesh
									Mesh.Scale = Mesh.Scale + Vector3.new(Thing[7], Thing[8], Thing[9])
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Disappear" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
								elseif Thing[2] == "Shatter" then
									Thing[1].Transparency = Thing[1].Transparency + Thing[3]
									Thing[4] = Thing[4] * CFrame.new(0, Thing[7], 0)
									Thing[1].CFrame = Thing[4] * CFrame.fromEulerAnglesXYZ(Thing[6], 0, 0)
									Thing[6] = Thing[6] + Thing[5]
								end
							else
								Part.Parent = nil
								table.remove(Effects, e)
							end
						end
					end
				end
			end
		end
		-------------------------------------------------------
		--End Animations And Script--
		-------------------------------------------------------
	end)
end
coroutine.wrap(RRKJZF_fake_script)()
local function AXKQ_fake_script() -- ServerAdmin.LocalScript 
	local script = Instance.new('LocalScript', ServerAdmin)

	ServerAdmin.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
	end)
end
coroutine.wrap(AXKQ_fake_script)()
local function TTPX_fake_script() -- Flash.LocalScript 
	local script = Instance.new('LocalScript', Flash)

	Flash.MouseButton1Down:connect(function()
		wait()
		Player = game.Players.LocalPlayer
		Object = Player.Character.HumanoidRootPart
		Arm1 = Player.Character["Right Arm"]
		PreviousA1 = Arm1.CFrame.p
		Arm2 = Player.Character["Left Arm"]
		PreviousA2 = Arm2.CFrame.p

		Leg1 = Player.Character["Right Leg"]
		PreviousL1 = Leg1.CFrame.p
		Leg2 = Player.Character["Left Leg"]
		PreviousL2 = Leg2.CFrame.p

		Run = game["Run Service"]

		PreviousP = Object.CFrame.p
		Running = false
		Phase = false
		PhaseActive = false
		Morph = false
		MorphActive = false
		Tornado = false
		TornadoRadius = 50
		TornadoActive = false
		Portal = false
		PortalEnd = false
		MaxZ = 15
		MinZ = -15
		LightMaxX = 3
		LightMinX = 1
		LightMaxX2 = -1
		LightMinX2 = -3
		LightMaxY = 3
		LightMinY = -1
		Rotation = 0
		Length = 10
		Color = BrickColor.Yellow()
		PColor = Color3.new(255,255,0)
		PrevPoint1 = nil
		PrevPoint2 = nil
		PrevPoint3 = nil
		PrevPoint4 = nil
		PrevPoint5 = nil
		PrevPoint6 = nil
		PrevPoint7 = nil
		PrevPoint8 = nil
		PrevPoint9 = nil
		PrevPoint10 = nil
		PrevPoint11 = nil
		PrevPoint12 = nil
		angle = 0
		Mouse = Player:GetMouse()
		Player.Character.Humanoid.WalkSpeed = 100

		Nil = function()
			PrevPoint1 = "Empty"
			PrevPoint2 = "Empty"
			PrevPoint3 = "Empty"
			PrevPoint4 = "Empty"
			PrevPoint5 = "Empty"
			PrevPoint6 = "Empty"
			PrevPoint7 = "Empty"
			PrevPoint8 = "Empty"
			PrevPoint9 = "Empty"
			PrevPoint10 = "Empty"
			PrevPoint11 = "Empty"
			PrevPoint12 = "Empty"
		end

		local Lightning = coroutine.wrap(function()
			while wait() do
				if Portal == false then
					angle = angle + 0.6
					local Model = Instance.new("Model",workspace)
					Model.Name = "Lightning"
					local Point1 = Instance.new("Part",Model)
					Point1.Transparency = 1
					Point1.Size = Vector3.new(0.2,0.2,0.2)
					Point1.CFrame = Object.CFrame * CFrame.new(0,0,-(Object.Size.Z/2+Point1.Size.Z/2))
					Point1.Anchored = true
					Point1.CanCollide = false
					Point1.CFrame = Point1.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),-math.random(0,2))

					local Point2 = Instance.new("Part",Model)
					Point2.Transparency = 1
					Point2.Size = Vector3.new(0.2,0.2,0.2)
					Point2.CFrame = Object.CFrame * CFrame.new(0,0,-(Object.Size.Z/2+Point2.Size.Z/2))
					Point2.Anchored = true
					Point2.CanCollide = false
					Point2.CFrame = Point2.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),-math.random(0,2))

					local Point3 = Instance.new("Part",Model)
					Point3.Transparency = 1
					Point3.Size = Vector3.new(0.2,0.2,0.2)
					Point3.CFrame = Object.CFrame * CFrame.new(0,0,-(Object.Size.Z/2+Point3.Size.Z/2))
					Point3.Anchored = true
					Point3.CanCollide = false
					Point3.CFrame = Point3.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),-math.random(0,2))

					local distance = (Point2.CFrame.p - Point1.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point2.CFrame.p , Point1.CFrame.p) * CFrame.new(0,0,-distance/2)

					local distance2 = (Point3.CFrame.p - Point2.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance2)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point3.CFrame.p , Point2.CFrame.p) * CFrame.new(0,0,-distance2/2)

					local Point1 = Instance.new("Part",Model)
					Point1.Transparency = 1
					Point1.Size = Vector3.new(0.2,0.2,0.2)
					Point1.CFrame = Object.CFrame * CFrame.new(0,0,(Object.Size.Z/2+Point1.Size.Z/2))
					Point1.Anchored = true
					Point1.CanCollide = false
					Point1.CFrame = Point1.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),math.random(0,2))

					local Point2 = Instance.new("Part",Model)
					Point2.Transparency = 1
					Point2.Size = Vector3.new(0.2,0.2,0.2)
					Point2.CFrame = Object.CFrame * CFrame.new(0,0,(Object.Size.Z/2+Point2.Size.Z/2))
					Point2.Anchored = true
					Point2.CanCollide = false
					Point2.CFrame = Point2.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),math.random(0,2))

					local Point3 = Instance.new("Part",Model)
					Point3.Transparency = 1
					Point3.Size = Vector3.new(0.2,0.2,0.2)
					Point3.CFrame = Object.CFrame * CFrame.new(0,0,(Object.Size.Z/2+Point3.Size.Z/2))
					Point3.Anchored = true
					Point3.CanCollide = false
					Point3.CFrame = Point3.CFrame * CFrame.new(math.random(-2,2),math.random(-2,2),math.random(0,2))

					local distance = (Point2.CFrame.p - Point1.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point2.CFrame.p , Point1.CFrame.p) * CFrame.new(0,0,-distance/2)

					local distance2 = (Point3.CFrame.p - Point2.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.3,0.3,distance2)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point3.CFrame.p , Point2.CFrame.p) * CFrame.new(0,0,-distance2/2)

					local Point1 = Instance.new("Part",Model)
					Point1.Transparency = 1
					Point1.Size = Vector3.new(0.2,0.2,0.2)
					Point1.CFrame = Object.CFrame * CFrame.new((Object.Size.X/2+Point1.Size.X/2),0,0)
					Point1.Anchored = true
					Point1.CanCollide = false
					Point1.CFrame = Point1.CFrame * CFrame.new(math.random(0,2),math.random(-2,2),math.random(-2,2))

					local Point2 = Instance.new("Part",Model)
					Point2.Transparency = 1
					Point2.Size = Vector3.new(0.2,0.2,0.2)
					Point2.CFrame = Object.CFrame * CFrame.new((Object.Size.X/2+Point1.Size.X/2),0,0)
					Point2.Anchored = true
					Point2.CanCollide = false
					Point2.CFrame = Point2.CFrame * CFrame.new(math.random(0,2),math.random(-2,2),math.random(-2,2))

					local Point3 = Instance.new("Part",Model)
					Point3.Transparency = 1
					Point3.Size = Vector3.new(0.2,0.2,0.2)
					Point3.CFrame = Object.CFrame * CFrame.new((Object.Size.X/2+Point1.Size.X/2),0,0)
					Point3.Anchored = true
					Point3.CanCollide = false
					Point3.CFrame = Point3.CFrame * CFrame.new(math.random(0,2),math.random(-2,2),math.random(-2,2))

					local distance = (Point2.CFrame.p - Point1.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point2.CFrame.p , Point1.CFrame.p) * CFrame.new(0,0,-distance/2)

					local distance2 = (Point3.CFrame.p - Point2.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance2)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point3.CFrame.p , Point2.CFrame.p) * CFrame.new(0,0,-distance2/2)

					local Point1 = Instance.new("Part",Model)
					Point1.Transparency = 1
					Point1.Size = Vector3.new(0.2,0.2,0.2)
					Point1.CFrame = Object.CFrame * CFrame.new(-(Object.Size.X/2+Point1.Size.X/2),0,0)
					Point1.Anchored = true
					Point1.CanCollide = false
					Point1.CFrame = Point1.CFrame * CFrame.new(-math.random(0,2),math.random(-2,2),math.random(-2,2))

					local Point2 = Instance.new("Part",Model)
					Point2.Transparency = 1
					Point2.Size = Vector3.new(0.2,0.2,0.2)
					Point2.CFrame = Object.CFrame * CFrame.new(-(Object.Size.X/2+Point1.Size.X/2),0,0)
					Point2.Anchored = true
					Point2.CanCollide = false
					Point2.CFrame = Point2.CFrame * CFrame.new(-math.random(0,2),math.random(-2,2),math.random(-2,2))

					local Point3 = Instance.new("Part",Model)
					Point3.Transparency = 1
					Point3.Size = Vector3.new(0.2,0.2,0.2)
					Point3.CFrame = Object.CFrame * CFrame.new(-(Object.Size.X/2+Point1.Size.X/2),0,0)
					Point3.Anchored = true
					Point3.CanCollide = false
					Point3.CFrame = Point3.CFrame * CFrame.new(-math.random(0,2),math.random(-2,2),math.random(-2,2))

					local distance = (Point2.CFrame.p - Point1.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point2.CFrame.p , Point1.CFrame.p) * CFrame.new(0,0,-distance/2)

					local distance2 = (Point3.CFrame.p - Point2.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					local PointLight = Instance.new("PointLight",Light)
					PointLight.Range = 5
					PointLight.Color = PColor
					Light.Transparency = 0.5
					Light.BrickColor = Color
					Light.Material = "Neon"
					Light.Size = Vector3.new(0.25,0.25,distance2)
					Light.Anchored = true
					Light.CanCollide = false
					Light.CFrame = CFrame.new(Point3.CFrame.p , Point2.CFrame.p) * CFrame.new(0,0,-distance2/2)

					local Children = Model:GetChildren()
					wait(0.1)
					for i = 1,#Children do
						if Children[i]:IsA("Part") then
							Children[i].Transparency = 1
						end
						game.Debris:AddItem(Children[i],0)
					end

				end
			end
		end)
		Lightning()

		TornadoFunction = function()
			local TornadoModel = Instance.new("Model",workspace)
			local Center = Instance.new("Part",TornadoModel)
			Center.Anchored = true
			Center.CanCollide = false
			Center.Transparency = 1
			Center.Size = Vector3.new(2,2,2)
			Center.CFrame = Object.CFrame * CFrame.new(0,0,-20)
			local Death = Instance.new("Part",TornadoModel)
			Death.Anchored = true
			Death.CanCollide = false
			Death.Transparency = 1
			Death.Size = Vector3.new(TornadoRadius+10,TornadoRadius+10,TornadoRadius+10)
			Death.CFrame = Center.CFrame
			Death.Touched:connect(function(Touch)
				if Touch.Parent:FindFirstChild("Humanoid") ~= nil and Touch.Parent.Name ~= Player.Name then
					Touch.Parent.Humanoid.Health = 0
				end
			end)
			local TornadoFunc = function()
				local Tornanimation = coroutine.wrap(function()
					while Run.Stepped:wait() do
						if Tornado == false then Death:Destroy() break end
						angle = angle + 0.1
						Object.Anchored = false
						Object.CFrame = Center.CFrame * CFrame.Angles(0,angle,0) * CFrame.new(0,0,TornadoRadius)
						Object.CFrame = Object.CFrame * CFrame.Angles(0,-math.rad(90),0)
					end
				end)
				Tornanimation()
			end
			TornadoFunc()
		end

		PhaseFunction = function()
			local Phase = coroutine.wrap(function()
				while wait() do
					if Phase == false then break end
					if Player.Character.Humanoid.WalkSpeed > 50 and Phase == true then
						Object.CFrame = Object.CFrame * CFrame.new(0,0,-Player.Character.Humanoid.WalkSpeed/20)
					end
				end
			end)
			Phase()
		end


		PortalFunction = function()
			local PortalBlock = Instance.new("Part",workspace)
			PortalBlock.CFrame = Object.CFrame * CFrame.new(0,0,-100)
			PortalBlock.Transparency = 1
			PortalBlock.Anchored = true
			PortalBlock.CanCollide = false
			PortalBlock.Size = Vector3.new(20,20,0.2)
			PortalBlock.CFrame = PortalBlock.CFrame * CFrame.new(0,(PortalBlock.Size.Y/2),0)
			local Gui = Instance.new("SurfaceGui",PortalBlock)
			local Img = Instance.new("ImageLabel",Gui)
			Img.Size = UDim2.new(2,0,2,0)
			Img.Position = UDim2.new(-0.5,0,-0.5,0)
			Img.Transparency = 1
			Img.Image = "http://www.roblox.com/asset/?id=21315275"
			local Gui = Instance.new("SurfaceGui",PortalBlock)                          
			Gui.Face = "Back"
			local Img = Instance.new("ImageLabel",Gui)
			Img.Size = UDim2.new(2,0,2,0)
			Img.Position = UDim2.new(-0.5,0,-0.5,0)
			Img.Transparency = 1
			Img.Image = "http://www.roblox.com/asset/?id=21315275"
			Object.CFrame = PortalBlock.CFrame
			local Face = Object.Parent.Head.face.Texture
			local ObjectC = Object.Parent:GetChildren()
			for i = 1,#ObjectC do
				if ObjectC[i]:IsA("Part") and ObjectC[i].Name ~= "HumanoidRootPart" then
					ObjectC[i].Transparency = 1
				elseif ObjectC[i]:IsA("Hat") then
					ObjectC[i].Handle.Transparency = 1
				end
				if ObjectC[i].Name == "Head" then
					ObjectC[i].face.Texture = ""
				end
			end

			local PortalR = coroutine.wrap(function()
				wait(0.1)
				Portal = true
				PortalEnd = true
				while wait(0.001) do
					if Portal == false then
						break
					end
					Nil()
					PortalBlock.CFrame = PortalBlock.CFrame * CFrame.Angles(0,0,-0.1)
					wait(0.01)
				end
				PortalBlock:Destroy()
				for i = 1,#ObjectC do
					if ObjectC[i]:IsA("Part") and ObjectC[i].Name ~= "HumanoidRootPart" then
						ObjectC[i].Transparency = 0
					elseif ObjectC[i]:IsA("Hat") then
						ObjectC[i].Handle.Transparency = 0
					end
					if ObjectC[i].Name == "Head" then
						ObjectC[i].face.Texture = Face
					end
				end
				game.Players.LocalPlayer.Character.Part.Transparency = 1
				local PortalBlock = Instance.new("Part",workspace)
				PortalBlock.CFrame = Object.CFrame * CFrame.new(0,0,0)
				PortalBlock.Transparency = 1
				PortalBlock.Anchored = true
				PortalBlock.CanCollide = false
				PortalBlock.Size = Vector3.new(20,20,0.2)
				PortalBlock.CFrame = PortalBlock.CFrame * CFrame.new(0,(PortalBlock.Size.Y/2),0)
				local Gui = Instance.new("SurfaceGui",PortalBlock)
				local Img = Instance.new("ImageLabel",Gui)
				Img.Size = UDim2.new(2,0,2,0)
				Img.Position = UDim2.new(-0.5,0,-0.5,0)
				Img.Transparency = 1
				Img.Image = "http://www.roblox.com/asset/?id=21315275"
				local Gui = Instance.new("SurfaceGui",PortalBlock)
				Gui.Face = "Back"
				local Img = Instance.new("ImageLabel",Gui)
				Img.Size = UDim2.new(2,0,2,0)
				Img.Position = UDim2.new(-0.5,0,-0.5,0)
				Img.Transparency = 1
				Img.Image = "http://www.roblox.com/asset/?id=21315275"
				Object.CFrame = PortalBlock.CFrame
				PreviousA1 = Arm1.CFrame.p
				PreviousA2 = Arm2.CFrame.p
				PreviousL1 = Leg1.CFrame.p
				PreviousL2 = Leg2.CFrame.p
				PreviousP = Object.CFrame.p
				PortalEnd = false
				wait(2)
				PortalBlock:Destroy()
			end)
			PortalR()
		end

		MorphFunction = function()
			local MaxX = 100
			local MinX = -100
			local MaxY = 100
			local MinY = -100
			local MaxZ = 100
			local MinZ = -100
			local Morph = coroutine.wrap(function()
				while Run.Stepped:wait(0.1) do
					if Morph == false then break end
					local Model = Instance.new("Model",workspace)
					if Player.Character:FindFirstChild("Shirt") then
						local Shirt = Player.Character.Shirt:Clone()
						Shirt.Parent = Model
					end
					if Player.Character:FindFirstChild("Pants") then
						local Pants = Player.Character.Pants:Clone()
						Pants.Parent = Model
					end
					local Humanoid = Instance.new("Humanoid",Model)
					local LeftArm = Player.Character["Left Arm"]:Clone()
					LeftArm.Parent = Model
					LeftArm.Transparency = 0.4
					LeftArm.Anchored = true
					LeftArm.CFrame = Player.Character["Left Arm"].CFrame * CFrame.new(math.random(MinX,MaxX)*0.003,math.random(MinY,MaxY)*0.003,math.random(MinZ,MaxZ)*0.003)
					local RightArm = Player.Character["Right Arm"]:Clone()
					RightArm.Parent = Model
					RightArm.Transparency = 0.4
					RightArm.Anchored = true
					RightArm.CFrame = Player.Character["Right Arm"].CFrame * CFrame.new(math.random(MinX,MaxX)*0.003,math.random(MinY,MaxY)*0.003,math.random(MinZ,MaxZ)*0.003)
					local LeftLeg = Player.Character["Left Leg"]:Clone()
					LeftLeg.Parent = Model
					LeftLeg.Transparency = 0.4
					LeftLeg.Anchored = true
					LeftLeg.CFrame = Player.Character["Left Leg"].CFrame * CFrame.new(math.random(MinX,MaxX)*0.003,math.random(MinY,MaxY)*0.003,math.random(MinZ,MaxZ)*0.003)
					local RightLeg = Player.Character["Right Leg"]:Clone()
					RightLeg.Parent = Model
					RightLeg.Transparency = 0.4
					RightLeg.Anchored = true   
					RightLeg.CFrame = Player.Character["Right Leg"].CFrame * CFrame.new(math.random(MinX,MaxX)*0.003,math.random(MinY,MaxY)*0.003,math.random(MinZ,MaxZ)*0.003)
					local Children = Model:GetChildren()
					wait(0.01)
					for i = 1,#Children do
						if Children[i]:IsA("Part") then
							Children[i].Transparency = 1
						end
						game.Debris:AddItem(Children[i],0)
					end
				end
			end)
			Morph()
		end

		local Guis = coroutine.wrap(function()
			local Gui = Instance.new("ScreenGui",Player.PlayerGui)
			local TextBox = Instance.new("TextBox",Gui)
			TextBox.Text = "Speed"
			TextBox.BackgroundColor3 = Color3.new(255,255,255)
			TextBox.BorderColor3 = Color3.new(0,0,0)
			TextBox.Size = UDim2.new(0,200,0,25)
			TextBox.Position = UDim2.new(0,10,0.5,-12.5)
			TextBox.FocusLost:connect(function(EnterPressed)
				if EnterPressed then
					Player.Character.Humanoid.WalkSpeed = TextBox.Text
				end
			end)
			local Flash = Instance.new("TextButton",Gui)
			Flash.BackgroundColor3 = Color3.new(255,255,255)
			Flash.BorderColor3 = Color3.new(0,0,0)
			Flash.Size = UDim2.new(0,200,0,25)
			Flash.Position = UDim2.new(0,10,0.5,22.5)
			Flash.Text = "The Flash"
			Flash.MouseButton1Click:connect(function()
				Color = BrickColor.Yellow()
				PColor = Color3.new(255,255,0)
			end)
			local RFlash = Instance.new("TextButton",Gui)
			RFlash.BackgroundColor3 = Color3.new(255,255,255)
			RFlash.BorderColor3 = Color3.new(0,0,0)
			RFlash.Size = UDim2.new(0,200,0,25)
			RFlash.Position = UDim2.new(0,10,0.5,57.5)
			RFlash.Text = "The Reverse Flash"
			RFlash.MouseButton1Click:connect(function()
				Color = BrickColor.new("Really red")
				PColor = Color3.new(255,0,0)
			end)
			local Zoom = Instance.new("TextButton",Gui)
			Zoom.BackgroundColor3 = Color3.new(255,255,255)
			Zoom.BorderColor3 = Color3.new(0,0,0)
			Zoom.Size = UDim2.new(0,200,0,25)
			Zoom.Position = UDim2.new(0,10,0.5,92.5)
			Zoom.Text = "Zoom"
			Zoom.MouseButton1Click:connect(function()
				Color = BrickColor.new("Cyan")
				PColor = Color3.new(0,170,255)
			end)
			local Radius = Instance.new("TextBox",Gui)
			Radius.Text = "Tornado Radius"
			Radius.BackgroundColor3 = Color3.new(255,255,255)
			Radius.BorderColor3 = Color3.new(0,0,0)
			Radius.Size = UDim2.new(0,200,0,25)
			Radius.Position = UDim2.new(0,10,0.5,127.5)
			Radius.FocusLost:connect(function(EnterPressed)
				if EnterPressed then
					TornadoRadius = Radius.Text
				end
			end)
			Mouse.KeyDown:connect(function(Key)
				if Key == "f" then
					if Portal == false then
						PortalFunction()
						Nil()
					else
						Portal = false
					end
				end
				if Key == "r" then
					if Phase == false then
						Phase = true
						PhaseFunction()
						print "PhaseFunction"
					else
						Phase = false
					end
				end
				if Key == "e" then
					if Tornado == false then
						Tornado = true
						TornadoFunction()
					else
						Tornado = false
					end
				end
				if Key == "t" then
					if Morph == false then
						Morph = true
						MorphFunction()
					else
						Morph = false
					end
				end
			end)
		end)
		Guis()

		Run.RenderStepped:connect(function()
			if (Object.CFrame.p - PreviousP).magnitude > 7 and Player.Character.Humanoid.WalkSpeed > 25 and Portal == false and PortalEnd == false then
				local Model = Instance.new("Model",workspace)
				Model.Name = "Ray"
				local Humanoid = Instance.new("Humanoid",Model)
				if Player.Character:FindFirstChild("Shirt") ~= nil then
					Player.Character.Shirt:Clone().Parent = Model
				end
				if Player.Character:FindFirstChild("Pants") ~= nil then
					Player.Character.Pants:Clone().Parent = Model
				end
				local distance = (Object.CFrame.p - PreviousP).magnitude
				local Light = Instance.new("Part",Model)
				Light.Anchored = true
				Light.CanCollide = false
				Light.TopSurface = "SmoothNoOutlines"
				Light.BottomSurface = "SmoothNoOutlines"
				Light.BackSurface = "SmoothNoOutlines"
				Light.FrontSurface = "SmoothNoOutlines"
				Light.LeftSurface = "SmoothNoOutlines"
				Light.RightSurface = "SmoothNoOutlines"
				Light.Transparency = 1
				Light.BrickColor = BrickColor.Black()
				Light.Size = Vector3.new(2,2,distance)
				Light.CFrame = CFrame.new(Object.CFrame.p , PreviousP) * CFrame.new(0,0,-distance/2)

				local PointLight = Instance.new("PointLight",Light)
				PointLight.Range = 15
				PointLight.Brightness = 100
				PointLight.Color = PColor

				local distance = (Arm1.CFrame.p - PreviousA1).magnitude

				local Arm1Light = Instance.new("Part",Model)
				Arm1Light.Name = "Right Arm"
				Arm1Light.Anchored = true
				Arm1Light.CanCollide = false
				Arm1Light.TopSurface = "SmoothNoOutlines"
				Arm1Light.BottomSurface = "SmoothNoOutlines"
				Arm1Light.BackSurface = "SmoothNoOutlines"
				Arm1Light.FrontSurface = "SmoothNoOutlines"
				Arm1Light.LeftSurface = "SmoothNoOutlines"
				Arm1Light.RightSurface = "SmoothNoOutlines"
				Arm1Light.Transparency = 0.5
				Arm1Light.BrickColor = BrickColor.Black()
				Arm1Light.Size = Vector3.new(1,2,distance)
				Arm1Light.CFrame = CFrame.new(Arm1.CFrame.p , PreviousA1) * CFrame.new(0,0,-distance/2) * CFrame.Angles(0,math.rad(180),0)

				local distance = (Arm2.CFrame.p - PreviousA2).magnitude

				local Arm2Light = Instance.new("Part",Model)
				Arm2Light.Name = "Left Arm"
				Arm2Light.Anchored = true
				Arm2Light.CanCollide = false
				Arm2Light.TopSurface = "SmoothNoOutlines"
				Arm2Light.BottomSurface = "SmoothNoOutlines"
				Arm2Light.BackSurface = "SmoothNoOutlines"
				Arm2Light.FrontSurface = "SmoothNoOutlines"
				Arm2Light.LeftSurface = "SmoothNoOutlines"
				Arm2Light.RightSurface = "SmoothNoOutlines"
				Arm2Light.Transparency = 0.5
				Arm2Light.BrickColor = BrickColor.Black()
				Arm2Light.Size = Vector3.new(1,2,distance)
				Arm2Light.CFrame = CFrame.new(Arm2.CFrame.p , PreviousA2) * CFrame.new(0,0,-distance/2) * CFrame.Angles(0,math.rad(180),0)

				local distance = (Leg1.CFrame.p - PreviousL1).magnitude

				local Leg1Light = Instance.new("Part",Model)
				Leg1Light.Name = "Right Leg"
				Leg1Light.Anchored = true
				Leg1Light.CanCollide = false
				Leg1Light.TopSurface = "SmoothNoOutlines"
				Leg1Light.BottomSurface = "SmoothNoOutlines"
				Leg1Light.BackSurface = "SmoothNoOutlines"
				Leg1Light.FrontSurface = "SmoothNoOutlines"
				Leg1Light.LeftSurface = "SmoothNoOutlines"
				Leg1Light.RightSurface = "SmoothNoOutlines"
				Leg1Light.Transparency = 0.5
				Leg1Light.BrickColor = BrickColor.Black()
				Leg1Light.Size = Vector3.new(1,2,distance)
				Leg1Light.CFrame = CFrame.new(Leg1.CFrame.p , PreviousL1) * CFrame.new(0,0,-distance/2) * CFrame.Angles(0,math.rad(180),0)

				local distance = (Leg2.CFrame.p - PreviousL2).magnitude

				local Leg1Light = Instance.new("Part",Model)
				Leg1Light.Name = "Left Leg"
				Leg1Light.Anchored = true
				Leg1Light.CanCollide = false
				Leg1Light.TopSurface = "SmoothNoOutlines"
				Leg1Light.BottomSurface = "SmoothNoOutlines"
				Leg1Light.BackSurface = "SmoothNoOutlines"
				Leg1Light.FrontSurface = "SmoothNoOutlines"
				Leg1Light.LeftSurface = "SmoothNoOutlines"
				Leg1Light.RightSurface = "SmoothNoOutlines"
				Leg1Light.Transparency = 0.5
				Leg1Light.BrickColor = BrickColor.Black()
				Leg1Light.Size = Vector3.new(1,2,distance)
				Leg1Light.CFrame = CFrame.new(Leg2.CFrame.p , PreviousL2) * CFrame.new(0,0,-distance/2) * CFrame.Angles(0,math.rad(180),0)

				local Point1 = Instance.new("Part",Model)
				Point1.Transparency = 1
				Point1.Anchored = true
				Point1.CanCollide = false
				Point1.Size = Vector3.new(0.2,0.2,0.2)
				Point1.CFrame = Light.CFrame * CFrame.new(0,0,-Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point2 = Instance.new("Part",Model)
				Point2.Transparency = 1
				Point2.Anchored = true
				Point2.CanCollide = false
				Point2.Size = Vector3.new(0.2,0.2,0.2)
				Point2.CFrame = Light.CFrame * CFrame.new(0,0,Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point5 = Instance.new("Part",Model)
				Point5.Transparency = 1
				Point5.Anchored = true
				Point5.CanCollide = false
				Point5.Size = Vector3.new(0.2,0.2,0.2)
				Point5.CFrame = Light.CFrame * CFrame.new(0,0,-Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point6 = Instance.new("Part",Model)
				Point6.Transparency = 1
				Point6.Anchored = true
				Point6.CanCollide = false
				Point6.Size = Vector3.new(0.2,0.2,0.2)
				Point6.CFrame = Light.CFrame * CFrame.new(0,0,Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point3 = Instance.new("Part",Model)
				Point3.Transparency = 1
				Point3.Anchored = true
				Point3.CanCollide = false
				Point3.Size = Vector3.new(0.2,0.2,0.2)
				Point3.CFrame = Light.CFrame * CFrame.new(0,0,-Light.Size.Z/2)
					* CFrame.new(-Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point4 = Instance.new("Part",Model)
				Point4.Transparency = 1
				Point4.Anchored = true
				Point4.CanCollide = false
				Point4.Size = Vector3.new(0.2,0.2,0.2)
				Point4.CFrame = Light.CFrame * CFrame.new(0,0,Light.Size.Z/2)
					* CFrame.new(-Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point7 = Instance.new("Part",Model)
				Point7.Transparency = 1
				Point7.Anchored = true
				Point7.CanCollide = false
				Point7.Size = Vector3.new(0.2,0.2,0.2)
				Point7.CFrame = Light.CFrame * CFrame.new(0,0,-Light.Size.Z/2)
					* CFrame.new(-Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point8 = Instance.new("Part",Model)
				Point8.Transparency = 1
				Point8.Anchored = true
				Point8.CanCollide = false
				Point8.Size = Vector3.new(0.2,0.2,0.2)
				Point8.CFrame = Light.CFrame * CFrame.new(0,0,Light.Size.Z/2)
					* CFrame.new(-Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point9 = Instance.new("Part",Model)
				Point9.Transparency = 1
				Point9.Anchored = true
				Point9.CanCollide = false
				Point9.Size = Vector3.new(0.2,0.2,0.2)
				Point9.CFrame = Light.CFrame * CFrame.new(0,-1,-Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,-2 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point10 = Instance.new("Part",Model)
				Point10.Transparency = 1
				Point10.Anchored = true
				Point10.CanCollide = false
				Point10.Size = Vector3.new(0.2,0.2,0.2)
				Point10.CFrame = Light.CFrame * CFrame.new(0,-1,Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,0 ,0)
					* CFrame.new(math.random(LightMinX,LightMaxX),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point11 = Instance.new("Part",Model)
				Point11.Transparency = 1
				Point11.Anchored = true
				Point11.CanCollide = false
				Point11.Size = Vector3.new(0.2,0.2,0.2)
				Point11.CFrame = Light.CFrame * CFrame.new(0,-1,-Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,-2 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				local Point12 = Instance.new("Part",Model)
				Point12.Transparency = 1
				Point12.Anchored = true
				Point12.CanCollide = false
				Point12.Size = Vector3.new(0.2,0.2,0.2)
				Point12.CFrame = Light.CFrame * CFrame.new(0,-1,Light.Size.Z/2)
					* CFrame.new(Light.Size.X/2 ,-2 ,0)
					* CFrame.new(math.random(LightMinX2,LightMaxX2),0,0)
					* CFrame.new(0,math.random(LightMinY,LightMaxY),0)

				if PrevPoint2 == nil or PrevPoint2 == "Empty" then
					local distance = (Point2.CFrame.p - Point1.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point2.CFrame.p , Point1.CFrame.p) * CFrame.new(0,0,-distance/2)
				elseif PrevPoint2 ~= nil then
					local distance = (Point2.CFrame.p - PrevPoint2).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point2.CFrame.p , PrevPoint2) * CFrame.new(0,0,-distance/2)      
				end

				if PrevPoint4 == nil or PrevPoint4 == "Empty" then
					local distance = (Point4.CFrame.p - Point3.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point4.CFrame.p , Point3.CFrame.p) * CFrame.new(0,0,-distance/2) 
				elseif PrevPoint4 ~= nil then
					local distance = (Point4.CFrame.p - PrevPoint4).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point4.CFrame.p , PrevPoint4) * CFrame.new(0,0,-distance/2)  
				end


				if PrevPoint6 == nil or PrevPoint6 == "Empty" then
					local distance = (Point6.CFrame.p - Point5.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point6.CFrame.p , Point5.CFrame.p) * CFrame.new(0,0,-distance/2) 
				elseif PrevPoint6 ~= nil then
					local distance = (Point6.CFrame.p - PrevPoint6).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point6.CFrame.p , PrevPoint6) * CFrame.new(0,0,-distance/2)  
				end

				if PrevPoint8 == nil or PrevPoint8 == "Empty" then
					local distance = (Point8.CFrame.p - Point7.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point8.CFrame.p , Point7.CFrame.p) * CFrame.new(0,0,-distance/2) 
				elseif PrevPoint8 ~= nil then
					local distance = (Point8.CFrame.p - PrevPoint8).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point8.CFrame.p , PrevPoint8) * CFrame.new(0,0,-distance/2)
				end

				if PrevPoint10 == nil or PrevPoint10 == "Empty" then
					local distance = (Point10.CFrame.p - Point9.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point10.CFrame.p , Point9.CFrame.p) * CFrame.new(0,0,-distance/2)
				elseif PrevPoint10 ~= nil then
					local distance = (Point10.CFrame.p - PrevPoint10).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point10.CFrame.p , PrevPoint10) * CFrame.new(0,0,-distance/2)
				end


				if PrevPoint12 == nil or PrevPoint12 == "Empty" then
					local distance = (Point12.CFrame.p - Point11.CFrame.p).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point12.CFrame.p , Point11.CFrame.p) * CFrame.new(0,0,-distance/2)   
				elseif PrevPoint12 ~= nil then
					local distance = (Point12.CFrame.p - PrevPoint12).magnitude
					local Light = Instance.new("Part",Model)
					Light.Anchored = true
					Light.CanCollide = false
					Light.TopSurface = "SmoothNoOutlines"
					Light.BottomSurface = "SmoothNoOutlines"
					Light.BackSurface = "SmoothNoOutlines"
					Light.FrontSurface = "SmoothNoOutlines"
					Light.LeftSurface = "SmoothNoOutlines"
					Light.RightSurface = "SmoothNoOutlines"
					Light.Transparency = 0
					Light.Size = Vector3.new(0.4,0.4,distance)
					Light.Material = "Neon"
					Light.BrickColor = Color
					Light.CFrame = CFrame.new(Point12.CFrame.p , PrevPoint12) * CFrame.new(0,0,-distance/2)
				end
				PreviousP = Object.CFrame.p
				PreviousA1 = Arm1.CFrame.p
				PreviousA2 = Arm2.CFrame.p
				PreviousL1 = Leg1.CFrame.p
				PreviousL2 = Leg2.CFrame.p
				PrevPoint1 = Point1.CFrame.p
				PrevPoint2 = Point2.CFrame.p
				PrevPoint3 = Point3.CFrame.p
				PrevPoint4 = Point4.CFrame.p
				PrevPoint5 = Point5.CFrame.p
				PrevPoint6 = Point6.CFrame.p
				PrevPoint7 = Point7.CFrame.p
				PrevPoint8 = Point8.CFrame.p
				PrevPoint9 = Point9.CFrame.p
				PrevPoint10 = Point10.CFrame.p
				PrevPoint11 = Point11.CFrame.p
				PrevPoint12 = Point12.CFrame.p
				local Children = Model:GetChildren()
				wait(1)
				for i = 1,10 do
					local Remove = coroutine.wrap(function()
						for i = 1,#Children do
							if Children[i]:IsA("Part") then
								Children[i].Transparency = Children[i].Transparency + 0.1
								if Children[i].Transparency >= 1 and Children[i] ~= Light and Children[i] ~= Point1 and Children[i] ~= Point2 and Children[i] ~= Point3
									and Children[i] ~= Point4 and Children[i] ~= Point5 and Children[i] ~= Point6 and Children[i] ~= Point7 and Children[i] ~= Point8
									and Children[i] ~= Point9 and Children[i] ~= Point10 and Children[i] ~= Point11 and Children[i] ~= Point12 then
									game.Debris:AddItem(Children[i],0)
								end
							end
							if Children[i].ClassName ~= "Part" then
								game.Debris:AddItem(Children[i],0)
							end
						end        
					end)
					Remove()
					wait(0.05)
				end
				game.Debris:AddItem(Light,0)
				game.Debris:AddItem(Point1,0)
				game.Debris:AddItem(Point2,0)
				game.Debris:AddItem(Point3,0)
				game.Debris:AddItem(Point4,0)
				game.Debris:AddItem(Point5,0)
				game.Debris:AddItem(Point6,0)
				game.Debris:AddItem(Point7,0)
				game.Debris:AddItem(Point8,0)
				game.Debris:AddItem(Point9,0)
				game.Debris:AddItem(Point10,0)
				game.Debris:AddItem(Point11,0)
				game.Debris:AddItem(Point12,0)
			end
		end)
	end)
end
coroutine.wrap(TTPX_fake_script)()
local function LVUHF_fake_script() -- UltimateMemeDance.LocalScript 
	local script = Instance.new('LocalScript', UltimateMemeDance)

	UltimateMemeDance.MouseButton1Down:connect(function()
		Bypass = "death"
		FELOADLIBRARY = {}
		loadstring(game:GetObjects("rbxassetid://5209815302")[1].Source)()
		loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()

		local model = workspace.non
		local mouse = game:GetService("Players").LocalPlayer:GetMouse()
		local Torso = model.Torso
		local RS = Torso:FindFirstChild("Right Shoulder")
		local LS = Torso:FindFirstChild("Left Shoulder")
		local RH = Torso:FindFirstChild("Right Hip")
		local LH = Torso:FindFirstChild("Left Hip")
		local Neck = Torso:FindFirstChild("Neck")
		local Torso = model.Torso
		local Head = model.Head
		local Humanoid = model.Humanoid
		local LeftArm = model["Left Arm"]
		local LeftLeg = model["Left Leg"]
		local RightArm = model["Right Arm"]
		local RightLeg = model["Right Leg"]
		local RootPart = model.HumanoidRootPart
		local attack = false
		local idle = 0
		local Gen = "Girl"
		local ToolMode = 1
		local sprintmode=false
		local jp = 50
		local ws = 6
		local inAir=true
		local inAir2=true
		local equipped = true
		local MoveTH = true
		local MoveArms = true
		local MoveLegs = true
		local toolAon = false
		local stopTA = false
		local sine = 0
		local change = 1
		local toolAnim = "None"
		local toolAnimTime = 0
		local Anim="Idle"
		local RJ = model.HumanoidRootPart:FindFirstChild("RootJoint")
		local cn = CFrame.new
		local cf = CFrame.new
		local ca2 = CFrame.Angles
		local mf = math.floor
		local Create = FELOADLIBRARY.Create
		local canstoptuant1 = false
		local stoptuant1 = false
		local MenyOpen = false
		function swait(num)
			if num == 0 or num == nil then
				game:service'RunService'.RenderStepped:wait(0)
			else
				for i = 0, num do
					game:service'RunService'.RenderStepped:wait(0)
				end
			end
		end

		function stopAnimations()
			coroutine.resume(coroutine.create(function()
				model.Animate:Destroy()
			end))
			coroutine.resume(coroutine.create(function()
				for _,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
					v:Stop()

				end
			end))
		end


		stopAnimations()
		wait(.1)

		local rayCast = function(Pos, Dir, Max, Ignore)
			return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore)
		end
		RS.C1 = cn(0, 0.5, 0) 
		LS.C1 = cn(0, 0.5, 0) 
		RH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		LH.C1 = cn(0, 1, 0) *CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
		local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14) 
		local NeckCF = cn(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
		local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)





		function RemoveOutlines(part)
			part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
		end


		CFuncs = {
			Part = {Create = function(Parent, Material, Reflectance, Transparency, BColor, Name, Size)

				local Part = Create("Part")({Parent = Parent, Reflectance = Reflectance, Transparency = Transparency, CanCollide = false, Locked = true, BrickColor = BrickColor.new(tostring(BColor)), Name = Name, Size = Size, Material = Material})
				RemoveOutlines(Part)
				return Part
			end
			}
			, 
			Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)

				local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
			}
			, 
			Mesh = {Create = function(Mesh, Part, MeshType, MeshId, OffSet, Scale)

				local Msh = Create(Mesh)({Parent = Part, Offset = OffSet, Scale = Scale})
				if Mesh == "SpecialMesh" then
					Msh.MeshType = MeshType
					Msh.MeshId = MeshId
				end
				return Msh
			end
			}
			, 
			Weld = {Create = function(Parent, Part0, Part1, C0, C1)

				local Weld = Create("Weld")({Parent = Parent, Part0 = Part0, Part1 = Part1, C0 = C0, C1 = C1})
				return Weld
			end
			}
			, 
			Sound = {Create = function(id, par, vol, pit)

				coroutine.resume(coroutine.create(function()

					local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, 6)
				end
				))
			end
			}
			, 

			Sound2 = {Create = function(id, par, vol, pit, SoundTime)

				coroutine.resume(coroutine.create(function()

					local S = Create("Sound")({Volume = vol, Pitch = pit or 1, SoundId  = "http://www.roblox.com/asset/?id="..id, Parent = par or workspace})
					wait()
					S:play()
					game:GetService("Debris"):AddItem(S, SoundTime)
				end
				))
			end
			}
			, 
			ParticleEmitter = {Create = function(Parent, Color1, Color2, LightEmission, Size, Texture, Transparency, ZOffset, Accel, Drag, LockedToPart, VelocityInheritance, EmissionDirection, Enabled, LifeTime, Rate, Rotation, RotSpeed, Speed, VelocitySpread)

				local fp = Create("ParticleEmitter")({Parent = Parent, Color = ColorSequence.new(Color1, Color2), LightEmission = LightEmission, Size = Size, Texture = Texture, Transparency = Transparency, ZOffset = ZOffset, Acceleration = Accel, Drag = Drag, LockedToPart = LockedToPart, VelocityInheritance = VelocityInheritance, EmissionDirection = EmissionDirection, Enabled = Enabled, Lifetime = LifeTime, Rate = Rate, Rotation = Rotation, RotSpeed = RotSpeed, Speed = Speed, VelocitySpread = VelocitySpread})
				return fp
			end
			}
		}

		local so = function(id, par, vol, pit, AlTime)

			if AlTime ~= nil then

				CFuncs.Sound2.Create(id, par, vol, pit, AlTime)	

			else
				CFuncs.Sound.Create(id, par, vol, pit)
			end

		end



		local ParticEffect1 = Create("ParticleEmitter"){
			Color = ColorSequence.new(Color3.new (0, 1, 0), Color3.new (0, 0, 0)),
			Transparency =  NumberSequence.new({NumberSequenceKeypoint.new(0,1),NumberSequenceKeypoint.new(0.2,0),NumberSequenceKeypoint.new(1,1)}),
			Size = NumberSequence.new({NumberSequenceKeypoint.new(0,.15),NumberSequenceKeypoint.new(0.5,.01),NumberSequenceKeypoint.new(1,0)}),
			Texture = "rbxassetid://596872069",
			Lifetime = NumberRange.new(0.8),
			Rate = 100,
			VelocitySpread = 360,
			RotSpeed = NumberRange.new(-100,100),
			Speed = NumberRange.new(2),
			LightEmission = 1,
			LockedToPart = false,
			Acceleration = Vector3.new(0, -5, 0),
			EmissionDirection = "Back",

		}	

--[[
fat = Instance.new("BindableEvent", script)
fat.Name = "Heartbeat"
script:WaitForChild("Heartbeat")
frame = 1/30
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.Heartbeat:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
  
  tf = tf + s
  if frame <= tf then
    if allowframeloss then
      script.Heartbeat:Fire()
      lastframe = tick()
    else
      for i = 1, math.floor(tf / frame) do
        script.Heartbeat:Fire()
      end
      lastframe = tick()
    end
    if tossremainder then
      tf = 0
    else
      tf = tf - frame * math.floor(tf / frame)
    end
  end
end
)















--]]

		Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)


		for i = 1,3,.1 do
			swait()
			Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),1)
			LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
			RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),1)
			LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),1)



		end












		local function JumpAfterEffect()
			if attack == false then
				attack = true

				if RootPart.Velocity.y < -65  then
					Humanoid.WalkSpeed= 0
					Humanoid.JumpPower= 0	
					for i = 1,3,.1 do
						swait()	
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .3, -.8 +-.05 * math.cos(sine / 15.5)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(20)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)

					end

				else
					if sprintmode == true then
						Humanoid.WalkSpeed= 10
					else
						Humanoid.WalkSpeed= 3
					end
					Humanoid.JumpPower= 0	
					for i = 1,2,.1 do
						swait()	
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .3, -.6 +-.05 * math.cos(sine / 15.5)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(20)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .7- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(-20)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.65+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.65+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.2)

					end

				end
				attack = false
			end
		end



		local function SlashAnim()
			if toolAon == false then
				toolAon= true
				MoveArms = false
				for i = 1,2,.1 do
					if stopTA == false then
						swait()	
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.8- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(160- 1 * math.cos(sine / 20)),math.rad(-10),math.rad(5- 1 * math.cos(sine / 20))),.2)
					end



				end	

				for i = 1,3,.1 do
					if stopTA == false then
						swait()	
						RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.3- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(0- 1 * math.cos(sine / 20)),math.rad(10),math.rad(-20- 1 * math.cos(sine / 20))),.5)

					end


				end	

				toolAnim = "None"
				toolAon = false


			end
		end



		local function LungeAnim()
			stopTA = true
			MoveArms = false		 

			swait(10)
			if toolAon == false then

				toolAon= true

				for i = 1,3,.1 do
					toolAon= true

					swait()		
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.7- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(170- 1 * math.cos(sine / 20)),math.rad(0),math.rad(0- 1 * math.cos(sine / 20))),.1)




				end	

				for i = 1,2,.1 do
					swait()	
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(30- 1 * math.cos(sine / 20)),math.rad(10),math.rad(-20- 1 * math.cos(sine / 20))),.2)


					toolAon= true	

				end	


				toolAnim = "None"
				toolAon = false
				stopTA = false
			end
		end




		local function getTool()	
			for _, kid in ipairs(model:GetChildren()) do
				if kid.className == "Tool" then return kid end
			end
			return nil
		end
		local function getToolAnim(tool)
			for _, c in ipairs(tool:GetChildren()) do
				if c.Name == "toolanim" and c.className == "StringValue" then
					return c
				end
			end
			return nil
		end
		local function animateTool()

			if (toolAnim == "None") then
				if ToolMode == 1 then
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.6- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(75- 1 * math.cos(sine / 20)),math.rad(20),math.rad(-15- 1 * math.cos(sine / 20))),.1)
				elseif  ToolMode == 2 then 
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.55- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90- 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
				elseif  ToolMode == 3 then  			
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(90 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      			
				elseif  ToolMode == 4 then  
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(0 - 1 * math.cos(sine / 20)),math.rad(0),math.rad(0 - 1 * math.cos(sine / 20))),.1)	      
				elseif  ToolMode == 5 then     
					MoveArms = true		



				end		
				return
			end

			if (toolAnim == "Slash") then
				SlashAnim()

				return
			end

			if (toolAnim == "Lunge") then
				LungeAnim()
				return
			end
		end



		game:GetService'RunService'.Stepped:connect(function()

			sine = sine + change

			local torvel = (RootPart.Velocity * Vector3.new(1, 0, 1)).magnitude
			local velderp = RootPart.Velocity.y
			local hitfloor = rayCast(RootPart.Position, CFrame.new(RootPart.Position, RootPart.Position - Vector3.new(0, 1, 0)).lookVector, 4, model)


			if sprintmode == true then
				jp = 60
				ws = 24
			else	
				jp = 50
				ws = 6
			end

			if hitfloor ~= nil then
				inAir = true
			else
				inAir = false	
			end

			if inAir == true then
				if inAir2 == false then	


					JumpAfterEffect()

				end	
			end

			if hitfloor ~= nil then
				inAir2 = true
			else
				inAir2 = false	
			end
			--[

			if RootPart.Velocity.y > 1 and hitfloor == nil then
				Anim = "Jump"
			elseif RootPart.Velocity.y < -1 and hitfloor == nil then
				Anim = "Fall"
			elseif Humanoid.Sit == true then
				Anim = "Sit"	
			elseif torvel < 1 and hitfloor ~= nil then
				Anim = "Idle"
			elseif torvel > 2 and  hitfloor ~= nil then
				if sprintmode == true then
					Anim = "Run"
				else
					Anim = "Walk"
				end	
			else
				Anim = ""

			end



			--]]









			if attack == false then
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws	

				local tool = getTool()
				if tool and tool:FindFirstChild("Handle") then

					MoveArms = false

					local animStringValueObject = getToolAnim(tool)

					if animStringValueObject then
						toolAnim = animStringValueObject.Value
						-- message recieved, delete StringValue
						animStringValueObject.Parent = nil

					end



					animateTool()	


					if ToolMode == 1 or ToolMode == 2 then
						if Anim == "Jump" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 -1* math.cos(sine / 10)),math.rad(0),math.rad(-5)),.3)
						elseif Anim == "Fall" then	
							LS.C0 = LS.C0:lerp(CFrame.new(-1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 -1* math.cos(sine / 10)),math.rad(0),math.rad(-100)),.05)
						elseif Anim == "Idle" then
							if Gen == "Boy" then
								LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
							end
							if Gen == "Girl" then
								LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.3- .03 * math.cos(sine / 26),  .1) * CFrame.Angles(math.rad(6),math.rad(20),math.rad(23+ 0 * math.cos(sine / 25))),.1)
							end
						elseif Anim == "Sit" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						elseif Anim == "Walk" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(0)),.1)
						elseif Anim == "Run" then
							LS.C0 = LS.C0:lerp(CFrame.new(-1.49, 0.6, 0) * CFrame.Angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .3)
						else
							LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),.05)
						end
					end


				else
					MoveArms = true
				end


				--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				if Anim == "Jump" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 1.3 +-.05 * math.cos(sine / 15)) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.15)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 +1* math.cos(sine / 10)),math.rad(0),math.rad(5)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(20 -1* math.cos(sine / 10)),math.rad(0),math.rad(-5)),.3)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.85+ .05 * math.cos(sine / 15), -.2) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.35+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-25 +1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.2)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Fall" then	
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then		
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(25-3 * math.cos(sine / 15)),math.rad(0),math.rad(0)),.05)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3 +-.05 * math.cos(sine / 15)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.08)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 +1* math.cos(sine / 10)),math.rad(0),math.rad(100)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, 1- .03 * math.cos(sine / 15), .3) * CFrame.Angles(math.rad(15 -1* math.cos(sine / 10)),math.rad(0),math.rad(-100)),.05)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.15+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-15 -1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.55+ .05 * math.cos(sine / 15), -.4) * CFrame.Angles(math.rad(-0 +1* math.cos(sine / 10)),math.rad(0),math.rad(0)),.1)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Sit" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if MoveTH == true then
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					end
					if MoveArms == true then
						if Gen == "Girl" then
							RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.3- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-30- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.3- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(30+ 1 * math.cos(sine / 20))),.1)
						end
						if Gen == "Boy" then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-0- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), -.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0+ 1 * math.cos(sine / 20))),.1)
						end

					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.85+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.85+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Idle" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if Gen == "Girl" then

						if MoveTH == true then
							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 25)),math.rad(-7 * math.cos(sine / 26)),math.rad(2 * math.cos(sine / 26))),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.07 * math.cos(sine / 26), 0, -.1 +-.03 * math.cos(sine / 25)) * CFrame.Angles(math.rad(0),math.rad(4 * math.cos(sine / 26)),math.rad(-3 * math.cos(sine / 26))),.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .01 * math.cos(sine / 25), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 2 * math.cos(sine / 26))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.3- .03 * math.cos(sine / 26),  .1) * CFrame.Angles(math.rad(6),math.rad(20),math.rad(23+ 0 * math.cos(sine / 25))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 25), .02) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(2.5- 0.0 * math.cos(sine / 25)))*CFrame.new(0, -.03 * math.cos(sine / 26), 0-0.03 * math.cos(sine / 26)) * CFrame.Angles(math.rad(0.5 * math.cos(sine / 26)),math.rad(2 * math.cos(sine / 26)),math.rad(-4 * math.cos(sine / 26))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 25), -.25) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 25)))*CFrame.new(0, .03 * math.cos(sine / 26), 0) * CFrame.Angles(math.rad(-0 -2 * math.cos(sine / 26)),math.rad(-20 +2 * math.cos(sine / 26)),math.rad(-4 * math.cos(sine / 26))),.15)
						end

					end





					if Gen == "Boy" then
						if MoveTH == true then
							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						end







					end

					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Walk" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					if Gen == "Girl" then

						if MoveTH == true then	
							Neck.C0 = Neck.C0:lerp(NeckCF * cf(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * CFrame.Angles(math.rad(0 - 1.5 * math.cos(sine / 3.5)), math.rad(5.5 * math.cos(sine / 7) ), math.rad(-7.5 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 14), 0.15)
							RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.075 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * CFrame.Angles(math.rad(3 - 2.5 * math.cos(sine / 3.5)), math.rad(-5 * math.cos(sine / 7)), math.rad(10 * math.cos(sine / 7))), 0.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(30 * math.cos(sine / 7)),math.rad(0),math.rad(4 * math.cos(sine / 7))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(4 * math.cos(sine / 7))),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp( cf(.5, -0.925 - 0.5 * math.cos(sine / 7) / 2,-0.1+ 0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(-90), math.rad(5 * math.cos(sine / 7))), 0.15)
							LH.C0 = LH.C0:lerp( cf(-.5, -0.925 + 0.5 * math.cos(sine / 7) / 2,-0.1+ -0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(90), math.rad(5 * math.cos(sine / 7))), 0.15)
						end	

					end


					if Gen == "Boy" then
						if MoveTH == true then	
							Neck.C0 = Neck.C0:lerp(NeckCF * cf(0, 0, 0 + 0.025 * math.cos(sine / 3.5)) * CFrame.Angles(math.rad(0 - 1.5 * math.cos(sine / 3.5)), math.rad(1.5 * math.cos(sine / 7) ), math.rad(-7.5 * math.cos(sine / 7)) + RootPart.RotVelocity.Y / 14), 0.15)
							RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.075 + 0.025 * math.cos(sine / 3.5) + -math.sin(sine / 3.5) / 7) * CFrame.Angles(math.rad(3 - 2.5 * math.cos(sine / 3.5)), math.rad(0), math.rad(10 * math.cos(sine / 7))), 0.15)
						end
						if MoveArms == true then
							RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(30 * math.cos(sine / 7)),math.rad(0),math.rad(-0)),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 15), 0) * CFrame.Angles(math.rad(-30 * math.cos(sine / 7)),math.rad(0),math.rad(0)),.1)
						end
						if MoveLegs == true then
							RH.C0 = RH.C0:lerp( cf(.5, -0.925 - 0.5 * math.cos(sine / 7) / 2,-0.1+ 0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 - 15 * math.cos(sine / 7)) + -math.sin(sine / 7) / 2.5, math.rad(90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 + 2.5 * math.cos(sine / 7)), math.rad(-90), math.rad(0)), 0.15)
							LH.C0 = LH.C0:lerp( cf(-.5, -0.925 + 0.5 * math.cos(sine / 7) / 2,-0.1+ -0.5 * math.cos(sine / 7) / 2) * CFrame.Angles(math.rad(-7.5 + 15 * math.cos(sine / 7)) + math.sin(sine / 7) / 2.5, math.rad(-90 - 10 * math.cos(sine / 7)), math.rad(0)) * CFrame.Angles(math.rad(0 - 2.5 * math.cos(sine / 7)), math.rad(90), math.rad(0)), 0.15)
						end
					end
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				elseif Anim == "Run" then
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------

					if MoveTH == true then	
						Neck.C0 = Neck.C0:lerp(NeckCF * CFrame.Angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 14), .3)
						RJ.C0 = RJ.C0:lerp(RootCF * cf(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * CFrame.Angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .4)
					end
					if MoveArms == true then
						RS.C0 = RS.C0:lerp(CFrame.new(1.49, 0.62, .3*math.cos(sine / 4)) * CFrame.Angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.49, 0.62, -.3*math.cos(sine / 4)) * CFrame.Angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .3)
					end
					if MoveLegs == true then
						RH.C0 = RH.C0:lerp( cf(.5, -1.0 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * CFrame.Angles(math.rad(-10 + 50 * math.cos(sine / 4)), math.rad(0), math.rad(2)), .4)
						LH.C0 = LH.C0:lerp( cf(-.5, -1.0 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * CFrame.Angles(math.rad(10 -50 * math.cos(sine / 4)), math.rad(0), math.rad(-2)), .4)
					end


--[[

					RootJoint.C0 = clerp(RootJoint.C0, RootCF * cn(0, 0, -0.1 + 0.15 * math.cos(sine / 3)) * angles(math.rad(15), math.rad(0) + RootPart.RotVelocity.Y / 30, math.rad(10 * math.cos(sine / 4))), .5)
					Torso.Neck.C0 = clerp(Torso.Neck.C0, NeckCF * angles(math.rad(-3), math.rad(0), math.rad(-8.5 * math.cos(sine / 4)) + RootPart.RotVelocity.Y / 9), .4)
					RW.C0 = clerp(RW.C0, CFrame.new(1.5, 0.5, 0) * angles(math.rad(10+-75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(2+10*math.cos(sine / 4))), .4)
					LW.C0 = clerp(LW.C0, CFrame.new(-1.5, 0.5, 0) * angles(math.rad(10+75*math.cos(sine / 4)), math.rad(5+-35*math.cos(sine / 4)), math.rad(-2+10*math.cos(sine / 4))), .4)
					RH.C0 = clerp(RH.C0, cn(1, -1.0 - -0.3 * math.cos(sine / 4), -.1 - 0.1 * math.cos(sine / 4)) * RHCF * angles(math.rad(-2), math.rad(0), math.rad(-10 + 50 * math.cos(sine / 4))), .5)
					LH.C0 = clerp(LH.C0, cn(-1, -1.0 + -0.3 * math.cos(sine / 4), -.1 + 0.1 * math.cos(sine / 4)) * LHCF * angles(math.rad(-2), math.rad(0), math.rad(10 +50 * math.cos(sine / 4))), .5)



--]]







				else
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------	
					--                   If anim is an false value so errors will not come
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(35)),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.8, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-35)),.05)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10)),.05)
					--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
				end
			end

			if Humanoid.Health < 0.1 and attack == false then
				attack = true 


				for i = 1,3,.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.07)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -1, -1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.07)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(10)),.07)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-10)),.07)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.07)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0)),.07)



				end
				for i = 1,15,.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.07)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -2.5) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),.07)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(0)),.07)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)),.07)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5)),.07)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5)),.07)



				end
				Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
				Humanoid.Health = 0
			end

		end)








		mouse.KeyDown:connect(function(k)
			if k == "0" and attack == false then	
				sprintmode=true	
			end
			if k == "9" and attack == false then	
				if Gen == "Boy" then
					Gen = "Girl"
				else
					Gen = "Boy"	
				end
				print(Gen.." Anims")
			end
			if k == "8" and attack == false then	

				ToolMode = ToolMode + 1	

				if ToolMode >5 then

					ToolMode = 1	
				end
				print("Tool Anim "..ToolMode)
			end


		end)
		mouse.KeyUp:connect(function(k)
			if k == "0" and attack == false then	
				sprintmode=false	
			end

		end)

		mouse.KeyDown:connect(function(k)

			if k == "t" and attack == false then	
				local Song = Instance.new("Sound", Torso)
				Song.SoundId  = "http://www.roblox.com/asset/?id=748575516"


				Song.Volume = 10

				attack= true
				--[






				Song:Play()
				Humanoid.JumpPower=0
				Humanoid.WalkSpeed=0	
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,10,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(50)),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, .5, 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-50)),.05)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end
				for i = 0,12,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(0)),.02)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.02)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(0)),.02)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-40),math.rad(0),math.rad(-0)),.02)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.02)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.02)

				end
				for i = 0,15,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.01)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.02)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.01)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.01)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.02)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.02)

				end

				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 0,5.25,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 2, -2.2) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.1)

				end
				for i = 0,0.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.3) * CFrame.Angles(math.rad(130),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,0.2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.4) * CFrame.Angles(math.rad(125),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(85),math.rad(0),math.rad(4)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(85),math.rad(0),math.rad(-4)),.1)

				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.3) * CFrame.Angles(math.rad(130),math.rad(0),math.rad(0)),.3)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.6, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-4)),.3)

				end
				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(-25),math.rad(10),math.rad(180)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(-25),math.rad(-10),math.rad(180)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.3) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(25),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.4) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.2) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, .5, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-20)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, .5, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(20)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

				end
				local Model2 = Instance.new("Model", model)
				game:GetService("Debris"):AddItem(Model2, 20)	
				local Rleg2 = Instance.new("Part", Model2)
				local Lleg2 = Instance.new("Part", Model2)
				local NewPantsHum = Instance.new("Humanoid", Model2)
				Rleg2.Size = RightLeg.Size
				Rleg2.BrickColor = RightLeg.BrickColor
				Rleg2.CFrame = RightLeg.CFrame
				Rleg2.Name = RightLeg.Name
				Lleg2.Size = LeftLeg.Size
				Lleg2.BrickColor = LeftLeg.BrickColor
				Lleg2.CFrame = LeftLeg.CFrame
				Lleg2.Name = LeftLeg.Name

				Lleg2.CanCollide = false	
				Rleg2.CanCollide = false
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(model:GetChildren()) do
						if v:isA("Pants") then
							v:Clone().Parent = Model2 	
						end
						if v:isA("CharacterMesh") then
							v:Clone().Parent = Model2 	
						end		

					end

				end))

				local RLW = Instance.new("Weld")
				RLW.Name = "Pants Weld"
				RLW.Part0 = RightLeg 
				RLW.C0 = cn(0, 0, 0)
				RLW.C1 = cn(0, 0, 0) 
				RLW.Part1 = Rleg2
				RLW.Parent = RightLeg 
				local LLW = Instance.new("Weld")
				LLW.Name = "Pants Weld"
				LLW.Part0 = LeftLeg 
				LLW.C0 = cn(0, 0, 0)
				LLW.C1 = cn(0, 0, 0) 
				LLW.Part1 = Lleg2
				LLW.Parent = LeftLeg 
				game:GetService("Debris"):AddItem(RLW, 4)	
				game:GetService("Debris"):AddItem(LLW, 4)	

				local lval = 0
				for i = 0,3,0.1 do
					swait()
					lval = .5*i/1.5
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(lval, -1, -0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-lval, -1, -0) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)


					Rleg2.Size = RightLeg.Size*i
					Lleg2.Size = LeftLeg.Size*i
					local RLW = Instance.new("Weld")
					RLW.Name = "Pants Weld"
					RLW.Part0 = RightLeg 
					RLW.C0 = cn(0, 0-i/1.51, 0)
					RLW.C1 = cn(0, 0, 0) 
					RLW.Part1 = Rleg2
					RLW.Parent = RightLeg 
					local LLW = Instance.new("Weld")
					LLW.Name = "Pants Weld"
					LLW.Part0 = LeftLeg 
					LLW.C0 = cn(0, 0-i/1.51, 0)
					LLW.C1 = cn(0, 0, 0) 
					LLW.Part1 = Lleg2
					LLW.Parent = LeftLeg 
					game:GetService("Debris"):AddItem(RLW, 4)	
					game:GetService("Debris"):AddItem(LLW, 4)	
				end



				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 1,6 do
					for i = 0,.6,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, 0+lval*4) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.6,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0+lval*4) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2+lval*4) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-lval, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 1,2 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.8,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-25),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-10),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(140),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.8, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.8,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 0,2.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.5, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(4)),.2)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.5, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-4)),.2)

				end
				for i = 0,3.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end

				for i = 1,3 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(1, 0, -1) * CFrame.Angles(math.rad(-0),math.rad(45),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end


					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-1, 0, -1) * CFrame.Angles(math.rad(-0),math.rad(-45),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(180)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

				end

				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
					LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

				end
				for i = 1,2 do
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2.3, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end	
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2.3, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2, 0, -1.5) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-45)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(-45)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.2, .5, -.1) * CFrame.Angles(math.rad(89),math.rad(0),math.rad(45)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(45)),.1)
						LH.C0 = LH.C0:lerp(CFrame.new(-.25, .1, -0.3) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-45)),.1)

					end

				end

				for i = 0,3.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.05)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.05)

				end

				for i = 1,4 do
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-75),math.rad(0),math.rad(10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.5, 0, -0) * CFrame.Angles(math.rad(5),math.rad(5),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,2,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-75),math.rad(0),math.rad(-10)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.5, 0, -0) * CFrame.Angles(math.rad(5),math.rad(-5),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-10)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(-1),math.rad(0),math.rad(-4)),.3)

					end
				end

				for i = 1,14 do
					for i = 0,.3,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(5)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(.5, 0, -0) * CFrame.Angles(math.rad(20),math.rad(15),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(27),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.3,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20),math.rad(0),math.rad(-5)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.5, 0, -0) * CFrame.Angles(math.rad(20),math.rad(-15),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(10)),.5)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5, -.2) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(-10)),.5)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
					for i = 0,.1,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.4)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0.3) * CFrame.Angles(math.rad(27),math.rad(0),math.rad(0)),.5)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-10)),.3)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(14)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.7, -.1) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-14)),.3)

					end
				end
				--]]
				local Paper = Instance.new("Part", model)


				Paper.Size = Vector3.new(0.1,1,1.5)
				Paper.BrickColor = BrickColor.new("White")
				Paper.CFrame = RightArm.CFrame
				Paper.Name = "Note"

				local PLW = Instance.new("Weld")
				PLW.Name = "Shirt Weld"
				PLW.Part0 = RightArm 
				PLW.C0 = cn(0, -1, 0)*CFrame.Angles(math.rad(0),math.rad(-0),math.rad(-45))
				PLW.C1 = cn(0, 0, 0) 
				PLW.Part1 = Paper
				PLW.Parent = RightArm 

				game:GetService("Debris"):AddItem(PLW, 1.6)	
				game:GetService("Debris"):AddItem(Paper, 3)



				for i = 0,8,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(0)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, .5, -.3) * CFrame.Angles(math.rad(75),math.rad(0),math.rad(-30)),.5)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end
				PLW.C0 = cn(0, -1, 0)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(-0))
				for i = 0,2,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(10)),.3)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, .5, -.4) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-50)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end

				local bodyVelocity = Create("BodyVelocity")({velocity = Vector3.new(0, 10, 0)+Paper.CFrame.lookVector*50, P = 5000, maxForce = Vector3.new(8000, 8000, 8000), Parent = Paper})
				game:GetService("Debris"):AddItem(bodyVelocity, 0.1)
				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5),math.rad(0),math.rad(-30)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, -.0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45)),.5)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.5)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.5)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.5)

				end


				local Model2 = Instance.new("Model", model)
				game:GetService("Debris"):AddItem(Model2, 20)	
				local Rleg2 = Instance.new("Part", Model2)

				local NewShirtHum = Instance.new("Humanoid", Model2)
				Rleg2.Size = Torso.Size
				Rleg2.BrickColor = Torso.BrickColor
				Rleg2.CFrame = Torso.CFrame
				Rleg2.Name = Torso.Name

				Rleg2.CanCollide = false
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(model:GetChildren()) do
						if v:isA("Shirt") then
							v:Clone().Parent = Model2 	
						end
						if v:isA("CharacterMesh") then
							v:Clone().Parent = Model2 	
						end		

					end

				end))

				local RLW = Instance.new("Weld")
				RLW.Name = "Shirt Weld"
				RLW.Part0 = Torso 
				RLW.C0 = cn(0, 0, 0)
				RLW.C1 = cn(0, 0, 0) 
				RLW.Part1 = Rleg2
				RLW.Parent = Torso 
				Torso.Transparency = 1
				game:GetService("Debris"):AddItem(RLW, 4)	



				local TorH = 0

				for i = 0,3,0.1 do
					swait()
					TorH =  i

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.5)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					Rleg2.Size = Vector3.new(Torso.Size.x,Torso.Size.y+i,Torso.Size.z)
					local RLW = Instance.new("Weld")
					RLW.Name = "Shirt Weld"
					RLW.Part0 = Torso 
					RLW.C0 = cn(0, 0+i/2, 0)
					RLW.C1 = cn(0, 0, 0) 
					RLW.Part1 = Rleg2
					RLW.Parent = Torso 
					Torso.Transparency = 1
					game:GetService("Debris"):AddItem(RLW, 14)
				end

				for i = 0,1,0.1 do
					swait()
					Torso.Transparency = 1

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end

				for i = 1,4 do
					for i = 0,1.7,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(1)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(2),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.1, .5+TorH, -.2) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-40)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.5,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,1.7,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(-5),math.rad(0),math.rad(-1)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(-2),math.rad(0)),.3)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.1, .5+TorH, -.2) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(40)),.2)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-4)),.3)

					end
					for i = 0,.5,0.1 do
						swait()
						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(-10)),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -.1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

					end
				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -1.0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(120),math.rad(0),math.rad(-10)),.3)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -.2, -.2) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-4)),.3)

				end
				for i = 0,1.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0+TorH) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5+TorH, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-0)),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-4)),.3)

				end
				Torso.Transparency = 0
				coroutine.resume(coroutine.create(function()	
					Model2:Destroy()	
					Torso.Transparency = 0	


				end))
				--]]
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

				end






				coroutine.resume(coroutine.create(function()	
					Torso.Transparency = 0
					Head.Transparency = 0
					RightArm.Transparency = 1
					LeftArm.Transparency = 1
					RightLeg.Transparency = 1
					LeftLeg.Transparency = 1

				end))

				local TorColor = nil
				TorColor=Torso.BrickColor

				coroutine.resume(coroutine.create(function()
					TorColor = model["Body Colors"].TorsoColor
				end))
				local NewTorsoMesh= Instance.new("SpecialMesh", Torso)
				NewTorsoMesh.MeshId = "rbxassetid://502406430"
				NewTorsoMesh.Scale = Vector3.new(3,3,2)




				Torso.BrickColor = BrickColor.new("New Yeller")
				coroutine.resume(coroutine.create(function()

					model["Body Colors"].TorsoColor = BrickColor.new("New Yeller")
				end))

				for i = 0,3,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)

				end
				--Front
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				--Front
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end

				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -2, -0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,.5,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				--Left
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(2, -0, -0) * CFrame.Angles(math.rad(0),math.rad(45),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				--Right
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-2, -0, -0) * CFrame.Angles(math.rad(0),math.rad(-45),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end
				for i = 0,1,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				for i = 0,55,0.1 do
					swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, -.5, -1) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0)),.2)	
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 5+.5 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(i*25)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-0)),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.4, .5, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(4)),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -1, -0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-4)),.3)
				end



				coroutine.resume(coroutine.create(function()
					NewTorsoMesh:Destroy()





				end))
				Torso.BrickColor = TorColor

				coroutine.resume(coroutine.create(function()

					model["Body Colors"].TorsoColor = TorColor

				end))
				coroutine.resume(coroutine.create(function()	
					Torso.Transparency = 0
					Head.Transparency = 0
					RightArm.Transparency = 0
					LeftArm.Transparency = 0
					RightLeg.Transparency = 0
					LeftLeg.Transparency = 0

				end))

				attack= false	
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws	
				Song:Destroy()
			end



			if k == " " and canstoptuant1 == true then	
				wait(.3)
				print(1)
				stoptuant1 = true	
				Humanoid.JumpPower=jp
				Humanoid.WalkSpeed=ws		


			end



			if k == "b"  and attack == false then
				attack = true
				Humanoid.JumpPower=0
				Humanoid.WalkSpeed=0.01	
				local GunPart = Instance.new("Part",model)	
				GunPart.Transparency = 0
				GunPart.CanCollide = false
				GunPart.Anchored = false
				GunPart.CFrame = CFrame.new(0,0,0)
				GunPart.Size = Vector3.new(0.85,.85,.05)
				GunPart.Material = "Neon"
				GunPart.BrickColor = BrickColor.new("Shamrock")
				local GunPartWeld = Instance.new("Weld",GunPart)	
				GunPartWeld.C0 = CFrame.new(0,0,0.99) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
				GunPartWeld.Part0 = GunPart
				GunPartWeld.Part1 = RightArm


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.15)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end



				for i = 1,1 do
					for i = 0,1.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.2)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	






					coroutine.resume(coroutine.create(function()	

						local Glow1 = Color3.new(0,1,0)
						local Glow2 = Color3.new(0,1,0)
						local hitray,pos = rayCast(GunPart.Position, GunPart.CFrame.lookVector, 5000, model)

						so("138335183", RightArm, 10, .9)

						local WalkPart = Instance.new("Part",model)	
						WalkPart.Transparency = 1
						WalkPart.CanCollide = false
						WalkPart.Anchored = true
						WalkPart.CFrame = CFrame.new(0,0,0)
						WalkPart.Size = Vector3.new(.1,.1,.1)
						local WalkPart2 = Instance.new("Part",model)	
						WalkPart2.Transparency = 1
						WalkPart2.CanCollide = false
						WalkPart2.Anchored = true
						WalkPart2.CFrame = GunPart.CFrame
						WalkPart2.Size = Vector3.new(.1,.1,.1)

						local Attach1 = Instance.new("Attachment",WalkPart2)	
						local Attach2 = Instance.new("Attachment",WalkPart)	
						local Beam1 = Instance.new("Beam",WalkPart)	
						Attach2.Position = pos
						Attach1.Position = Vector3.new(0,0,0)


						Beam1.Texture = "rbxassetid://1134824633"
						Beam1.Width0 = .0
						Beam1.Width1 = .0
						Beam1.FaceCamera = true	
						Beam1.Color = ColorSequence.new(Glow1,Glow2)
						Beam1.Transparency = NumberSequence.new(0,0)
						Beam1.TextureLength = 1
						Beam1.Attachment0 = Attach1
						Beam1.Attachment1 = Attach2
						Beam1.TextureSpeed = 10
						Beam1.LightEmission = 1





						local HitModel = nil



						if hitray ~= nil then
							HitModel = hitray.Parent

							if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
								HitModel = hitray.Parent.Parent	
							end
						end			
						local HasHum = false
						local ModelCanSlap = false
						local slaped2 = nil
						coroutine.resume(coroutine.create(function()	

							for _,v in pairs(HitModel:GetChildren()) do
								if v:isA("Humanoid") then
									v.Parent:BreakJoints()
									v.Health = 0
								end

							end

						end))



						coroutine.resume(coroutine.create(function()	
							if hitray ~= nil then

								local HitEffectPart = Instance.new("Part",model)		

								HitEffectPart.Transparency = 1
								HitEffectPart.CanCollide = false
								HitEffectPart.Anchored = true
								HitEffectPart.CFrame =CFrame.new(0,0,0)+pos
								HitEffectPart.Size = Vector3.new(.05,.05,.05)


								local NewParticEffect1=ParticEffect1:Clone()
								NewParticEffect1.Parent=	HitEffectPart


								game:GetService("Debris"):AddItem(HitEffectPart, 5)	
								coroutine.resume(coroutine.create(function()	
									for i = 1,0,-0.1 do
										wait()
										NewParticEffect1.Rate = i*100
									end

								end))
							end

							for i = 0,1,0.1 do
								swait(.7)
								Beam1.Transparency = NumberSequence.new(i,i)

								GunPart.Transparency = i*1.5
								GunPart.Size = Vector3.new(0.85-i,.85-i,.05)
								local GunPartWeld = Instance.new("Weld",GunPart)	
								GunPartWeld.C0 = CFrame.new(0,0,0.99) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(0))
								GunPartWeld.Part0 = GunPart
								GunPartWeld.Part1 = RightArm
								Beam1.Width0 = 1 - i
								Beam1.Width1 = 1 - i



							end
							game:GetService("Debris"):AddItem(GunPart, .4)
							game:GetService("Debris"):AddItem(WalkPart2, .4)	
							game:GetService("Debris"):AddItem(WalkPart, .4)	
							game:GetService("Debris"):AddItem(Attach1, .4)	
							game:GetService("Debris"):AddItem(Attach2, .4)	

						end))








					end))
					for i = 0,1,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(10)),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					so("165487479", Torso, 9, 1)	
					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,3,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-40)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(40)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(20)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(40),math.rad(0),math.rad(-10)),.05)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	

					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.15)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,.5,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.4- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end	
					for i = 0,2,.1 do swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10)),.3)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end		
				end
				attack = false	
			end





			if k == "f" then	
				local hitray = rayCast(RootPart.Position, RootPart.CFrame.lookVector, 6, model)
				local HitModel = nil



				if hitray ~= nil then
					HitModel = hitray.Parent

					if hitray.Parent:isA("Accessory") or hitray.Parent:isA("Hat") then
						HitModel = hitray.Parent.Parent	
					end
				end			
				local HasHum = false
				local ModelCanSlap = false
				local slaped2 = nil
				coroutine.resume(coroutine.create(function()	

					for _,v in pairs(HitModel:GetChildren()) do
						if v:isA("Humanoid") then
							HasHum = true	
						end
						if v:isA("BoolValue")then if v.Name == "Slap" and v.Value == false then
								ModelCanSlap= true	
								slaped2 = v
							end	
						end


					end

				end))



				if canstoptuant1 == false and attack == false then


					canstoptuant1 = true
					attack = true
					Humanoid.JumpPower=0
					Humanoid.WalkSpeed=0	

					local slaped = Instance.new("BoolValue",model)
					slaped.Name = "Slap"
					for i = 0,0.5,0.1 do
						swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

					end


					if HasHum == true and 	ModelCanSlap == true and slaped2 ~= nil  then
					else
						so("887591869", Torso, 10, 1)		

					end

					while   slaped.Value == false do


						swait()

						Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.1)
						RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.15)
						RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
						LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
						RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
						LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						if stoptuant1 == true then
							slaped.Value = true
						end

						if HasHum == true and 	ModelCanSlap == true and slaped2 ~= nil  then


							if HitModel:FindFirstChild("HumanoidRootPart")	 then



								local rainto = HitModel.HumanoidRootPart.CFrame.lookVector*0
								local rainto2 = CFrame.new(0,0,0) * HitModel.HumanoidRootPart.CFrame.lookVector*3.5
								local rainpos = HitModel.HumanoidRootPart.CFrame	
								rainto = rainto + rainto2	



								local Laserpart = Instance.new("Part",model)

								Laserpart.Size = Vector3.new(.1,.1,.1)
								Laserpart.CanCollide = false
								Laserpart.Transparency = 1
								Laserpart.Anchored = true
								Laserpart.CFrame = rainpos* cn(0,0, 0)+rainto	
								game:GetService("Debris"):AddItem(Laserpart, .05)	




								RootPart.CFrame = Laserpart.CFrame * CFrame.Angles(math.rad(-0),math.rad(180),math.rad(0))

							end

							slaped.Value = true
							slaped2.Value = true



						end


					end
					canstoptuant1 = false
					if slaped.Value == true and stoptuant1 == false then



						for i = 0,4,.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10)),.15)
							RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(170),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)
						end	



						for i = 0,2,.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(20)),.1)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)),.15)
							RS.C0 = RS.C0:lerp(CFrame.new(1.35, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(210),math.rad(0),math.rad(20- 1 * math.cos(sine / 20))),.1)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)


						end	
						so("146163534", Torso, 10, 1.3)
						for i = 0,2,0.1 do
							swait()

							Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(-60)),.3)
							RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(-.05, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(60)),.3)
							RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(135),math.rad(90),math.rad(0- 1 * math.cos(sine / 20))),.5)
							LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(-3+ 1 * math.cos(sine / 20))),.1)
							RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
							LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)


						end	

						stoptuant1 = false	
					else
						stoptuant1 = false
					end







					attack = false	
					coroutine.resume(coroutine.create(function()	
						slaped:Destoy()
					end))



				end



















			end





			if k == "g" and canstoptuant1 == false and attack == false and MenyOpen == false then	
				attack = true
				canstoptuant1 = true 
				MenyOpen = true
				local stillwaiting = true
				print("Fet Tuant stuff")
				while stillwaiting == true  do swait()
					Humanoid.JumpPower=0
					Humanoid.WalkSpeed=0
					-- canstoptuant1 


					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)


					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)

					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)


					if stoptuant1 == true then	
						stillwaiting = false	

					end


				end


				canstoptuant1 = false
				stoptuant1 = false


				if MenyOpen == true then
					attack = false
					MenyOpen = false
					print("Closed Tuant stuff")
				end
			end

--[[

if k == "" and  MenyOpen == true and canstoptuant1 == true then
MenyOpen = false
stoptuant1 = true


attack = false	
end





for i = 0,6,.1 do swait()
Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

end



--]]


			-- so("285615370", Torso, 1, 1,17)

			if k == "e" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+2 * math.cos(sine / 20)),math.rad(0),math.rad(-15)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, 0.6- .03 * math.cos(sine / 20), -.3) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-50- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("666675542", Torso, 10, 1)
				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+2 * math.cos(sine / 20)),math.rad(0),math.rad(-15)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.2, 0.6- .03 * math.cos(sine / 20), -.3) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-50- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,6,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+6 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-23+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.2)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-3),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end


				attack = false	
			end



			if k == "q" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("145303015", Torso, 10, 1,25)


				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(150+1 * math.cos(sine / 20)),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end




				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 4)),math.rad(0),math.rad(20)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.4, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180+5 * math.cos(sine / 3)),math.rad(0),math.rad(-15- 0 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end



				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,36,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-13+4 * math.cos(sine / 3)),math.rad(0),math.rad(30)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-6+4 * math.cos(sine / 3)),math.rad(0),math.rad(00)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,10,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(6+4 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(60),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end








				attack = false	
			end


			if k == "r" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("1058417264", Torso, 10, 1)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				--so("593142105", Torso, 10, .8)
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end








				attack = false	
			end




			if k == "p" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("252252871", Torso, 10, 1,9)
				-- 10 sec start
				for i = 0,3,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+20 * math.cos(sine / 20*2)),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(1),math.rad(0),math.rad(-10+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 3.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+0 * math.cos(sine / 20*2)),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(0- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(180),math.rad(0),math.rad(-0+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(0.5- .1 * math.cos(sine / 20))),.3)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-0.5+ .1 * math.cos(sine / 20))),.3)

				end

				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0+20 * math.cos(sine / 20*2)),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-10+ 1 * math.cos(sine / 20))),1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(10.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-10.5+ .1 * math.cos(sine / 20))),.15)

				end

				local Paper = Instance.new("Part", model)

				local PaperMesh = Instance.new("SpecialMesh", Paper)
				PaperMesh.MeshId = "http://www.roblox.com/asset/?id=40312463"
				PaperMesh.TextureId = "http://www.roblox.com/asset/?id=40311968"
				PaperMesh.Scale =  Vector3.new(2.2, 2.2, 2.2)
				Paper.Size = Vector3.new(1,1,1)
				Paper.BrickColor = BrickColor.new("White")
				Paper.CFrame = RightArm.CFrame
				Paper.Name = "Pie"

				local PLW = Instance.new("Weld")
				PLW.Name = "Pie Weld"
				PLW.Part0 = Head 
				PLW.C0 = cn(0, -0, -.7)*CFrame.Angles(math.rad(-10),math.rad(-0),math.rad(-0))
				PLW.C1 = cn(0, 0, 0) 
				PLW.Part1 = Paper
				PLW.Parent = RightArm 

				game:GetService("Debris"):AddItem(PLW, 10000)	
				game:GetService("Debris"):AddItem(Paper, 6)

				for i = 0,6,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+10 * math.cos(sine / 2)),math.rad(0),math.rad(i*100)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,7,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-40+2 * math.cos(sine / 20)),math.rad(0+10 * math.cos(sine / 1)),math.rad(0)),.4)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.4)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(i*200),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.4)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-i*200),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.4)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(i*200),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.4)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-i*200),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.4)

				end
				local explosionRadius = 0 -- Radius of 12 currently
				local explosionPressure = 0 -- Really high pressure that packs a punch!	
				local explosion = Instance.new("Explosion",workspace)
				explosion.BlastRadius = explosionRadius
				explosion.BlastPressure = explosionPressure
				explosion.Position = Torso.Position

				coroutine.resume(coroutine.create(function()	
					Paper:Destroy()
				end))





				attack = false	
			end





			if k == "f" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				for i = 0,.2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, 100 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),1)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.13)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,1,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(90)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("140364784", Torso, 10, 1)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end
				--so("593142105", Torso, 10, .8)
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,1.5,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-8+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(98),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(5.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-5.5+ .1 * math.cos(sine / 20))),.15)

				end





				attack = false	
			end

			if k == "x" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("135359981", Torso, 10, 1.2)
				for i = 0,14.8,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0+ 15 * math.cos(sine / 4))),.6)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, .5, -.15 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(180- 15 * math.cos(sine / 4)),math.rad(0),math.rad(-30- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.3, 0.6- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(180+ 15 * math.cos(sine / 4)),math.rad(0),math.rad(30+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(30),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end

			if k == "t" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("138110466", Torso, 10, 1)
				for i = 0,2,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.13)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,4,.1 do swait()
					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(3+2 * math.cos(sine / 20)),math.rad(0),math.rad(90)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(180)),.05)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end




			if k == "c" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("288824798", Torso, 10, 1)


				for i = 0,4,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.3, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(45),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end



			if k == "z" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("275278234", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 3)),math.rad(0),math.rad(0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+2 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.55- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(90-5 * math.cos(sine / 2)),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.55- .03 * math.cos(sine / 20), -.2) * CFrame.Angles(math.rad(90+5 * math.cos(sine / 2)),math.rad(0),math.rad(45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				attack = false	
			end


			if k == "h" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("135891629", Torso, 10, 1)


				for i = 0,7,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(-20)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), -.1) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.6- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(175),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.1)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(-5- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(5+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end


			if k == "v" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				so("290082048", Torso, 10, 1)


				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(95),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.2)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(160),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+2 * math.cos(sine / 5)),math.rad(0),math.rad(0)),.3)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, -.5, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.2)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(100),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.2)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				attack = false	
			end
			if k == "u" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("150611842", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(15+1 * math.cos(sine / 20)),math.rad(0),math.rad(10)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,1.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-10)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end

			if k == "b" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true
				for i = 0,1,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				so("141349049", Torso, 10, 1)


				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(110),math.rad(0),math.rad(10- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,0.5,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(105),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,2.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(20),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end




				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3.0,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-0+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.15)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(45- 1 * math.cos(sine / 20))),.1)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.25, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(91),math.rad(0),math.rad(-45+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end






			if k == "y" and  MenyOpen == true and canstoptuant1 == true then
				MenyOpen = false
				stoptuant1 = true

				so("738087836", Torso, 10, 1)

				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(5+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-0),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end

				for i = 0,2,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				for i = 0,3,.1 do swait()

					Neck.C0 = Neck.C0:lerp(NeckCF*CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10+1 * math.cos(sine / 20)),math.rad(0),math.rad(-0)),.08)
					RJ.C0 = RJ.C0:lerp(RootCF*CFrame.new(0, 0, -.1 +-.03 * math.cos(sine / 20)) * CFrame.Angles(math.rad(-10),math.rad(0),math.rad(0)),.15)
					RS.C0 = RS.C0:lerp(CFrame.new(1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(1- 1 * math.cos(sine / 20))),.05)
					LS.C0 = LS.C0:lerp(CFrame.new(-1.5, 0.5- .03 * math.cos(sine / 20), .2) * CFrame.Angles(math.rad(80),math.rad(0),math.rad(-1+ 1 * math.cos(sine / 20))),.1)
					RH.C0 = RH.C0:lerp(CFrame.new(.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(2.5- .1 * math.cos(sine / 20))),.15)
					LH.C0 = LH.C0:lerp(CFrame.new(-.5, -0.95+ .03 * math.cos(sine / 20), 0) * CFrame.Angles(math.rad(-15),math.rad(0),math.rad(-2.5+ .1 * math.cos(sine / 20))),.15)

				end
				attack = false	
			end








		end)
	end)
end
coroutine.wrap(LVUHF_fake_script)()
local function XVYTRXF_fake_script() -- Chips.LocalScript 
	local script = Instance.new('LocalScript', Chips)

	Chips.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/b289ts36"))()
	end)
end
coroutine.wrap(XVYTRXF_fake_script)()
local function JDLRIJH_fake_script() -- AmongUs.LocalScript 
	local script = Instance.new('LocalScript', AmongUs)

	AmongUs.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://pastebin.com/raw/JXUMavf3", true))()
	end)
end
coroutine.wrap(JDLRIJH_fake_script)()
local function WXMF_fake_script() -- Joy.LocalScript 
	local script = Instance.new('LocalScript', Joy)

	Joy.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
	end)
end
coroutine.wrap(WXMF_fake_script)()
local function FUIQ_fake_script() -- ParkourGod.LocalScript 
	local script = Instance.new('LocalScript', ParkourGod)

	ParkourGod.MouseButton1Down:connect(function()
		local player = game:service("Players").LocalPlayer
		local mouse = player:GetMouse()
		local cam = workspace.CurrentCamera
		local char = player.Character
		local Torsoz = char:findFirstChild("Torso")
		local RA = char:findFirstChild("Right Arm")
		local LA = char:findFirstChild("Left Arm")
		local RL = char:findFirstChild("Right Leg")
		local LL = char:findFirstChild("Left Leg")
		local H = char:findFirstChild("Head")
		local Hu = char:findFirstChild("Humanoid")
		local RS = Torsoz:findFirstChild("Right Shoulder")
		local LS = Torsoz:findFirstChild("Left Shoulder")
		local RH = Torsoz:findFirstChild("Right Hip")
		local LH = Torsoz:findFirstChild("Left Hip")
		local N = Torsoz:findFirstChild("Neck")
		local NV = Vector3.new(0,0,0)
		local FOV = 70
		local Shift, Space, Sitting = false,false,false
		local GravPoint = 0
		local Diving = false
		local DivingCooldown = 0
		local DivingDir = NV
		local DivingCF = CFrame.new(0,0,0)
		local DivingBG, DivingBV
		local HWallRunning = false
		local HWRGravDrop = false
		local HWRLastPart
		local HWRCooldown = 0
		local HWRDir
		local VWallRunning = false
		local VWRLastPart
		local VWRCooldown = 0
		local VWRLeft,VWRRight = false,false
		local Sliding = false
		local SlideCooldown = 0
		local Standing = true
		local Action = "Standing"
		local animplus = true
		local animspeed = 0
		local animangle = 0.01
		local Joint1, Joint2, Joint3, Joint4, Joint5

		for i, v in pairs(char:children()) do
			if (v.className == "LocalScript" and v.Name == "ParkourSkrip") or v.className == "NumberValue" or v.className == "BoolValue" or v.className == "Model" or v.Name == "Animate" then
				v:remove()
			end
		end

		local loadids = {112474909, 112474911, 112474909}

		local stamina = 10000
		local maxstamina = 10000
		local defsprint = 28
		local sprint = defsprint  

		local pause = Instance.new("BoolValue", char)
		pause.Name = "Pause"
		pause.Value = false
		local flow = Instance.new("NumberValue", char)
		flow.Name = "Flow"
		flow.Value = 0
		local flowcooldown = 0

		local m = Instance.new("Model", char)
		m.Name = "FlowChainPartz"

		local P = Instance.new("Part")
		P.Name = "TrailPart"
		P.formFactor = "Custom"
		P.Size = Vector3.new(0.2,0.2,0.2)
		P.Locked = true
		P.Anchored = true
		P.CanCollide = false
		P.TopSurface = 0
		P.BottomSurface = 0

		script.Name = "ParkourSkrip"

		local hue = 0

		function HSV(H,S,V)
			H = H % 360
			local C = V * S
			local H2 = H/60
			local X = C * (1 - math.abs((H2 %2) -1))
			local color = Color3.new(0,0,0)
			if H2 <= 0 then
				color = Color3.new(C,0,0)
			elseif 0 <= H2 and H2 <= 1 then
				color = Color3.new(C,X,0)
			elseif 1 <= H2 and H2 <= 2 then
				color = Color3.new(X,C,0)
			elseif 2 <= H2 and H2 <= 3 then
				color = Color3.new(0,C,X)
			elseif 3 <= H2 and H2 <= 4 then
				color = Color3.new(0,X,C)
			elseif 4 <= H2 and H2 <= 5 then
				color = Color3.new(X,0,C)
			elseif 5 <= H2 and H2 <= 6 then
				color = Color3.new(C,0,X)
			end
			local m = V - C
			return Color3.new(color.r + m, color.g + m, color.b + m)
		end

		function GetWeld(weld)
			if weld:findFirstChild("XAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "XAngle"
			end
			if weld:findFirstChild("YAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "YAngle"
			end
			if weld:findFirstChild("ZAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "ZAngle"
			end
			return weld.C0.p, Vector3.new(weld.XAngle.Value, weld.YAngle.Value, weld.ZAngle.Value)
		end

		function SetWeld(weld, i, loops, origpos,origangle, nextpos,nextangle)
			if weld:findFirstChild("XAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "XAngle"
			end
			if weld:findFirstChild("YAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "YAngle"
			end
			if weld:findFirstChild("ZAngle") == nil then
				local a = Instance.new("NumberValue", weld)
				a.Name = "ZAngle"
			end

			local tox,toy,toz = 0,0,0
			if origangle.x > nextangle.x then
				tox = -math.abs(origangle.x - nextangle.x) /loops*i
			else
				tox = math.abs(origangle.x - nextangle.x) /loops*i
			end
			if origangle.y > nextangle.y then
				toy = -math.abs(origangle.y - nextangle.y) /loops*i
			else
				toy = math.abs(origangle.y - nextangle.y) /loops*i
			end
			if origangle.z > nextangle.z then
				toz = -math.abs(origangle.z - nextangle.z) /loops*i
			else
				toz = math.abs(origangle.z - nextangle.z) /loops*i
			end

			local tox2,toy2,toz2 = 0,0,0
			if origpos.x > nextpos.x then
				tox2 = -math.abs(origpos.x - nextpos.x) /loops*i
			else
				tox2 = math.abs(origpos.x - nextpos.x) /loops*i
			end
			if origpos.y > nextpos.y then
				toy2 = -math.abs(origpos.y - nextpos.y) /loops*i
			else
				toy2 = math.abs(origpos.y - nextpos.y) /loops*i
			end
			if origpos.z > nextpos.z then
				toz2 = -math.abs(origpos.z - nextpos.z) /loops*i
			else
				toz2 = math.abs(origpos.z - nextpos.z) /loops*i
			end

			weld.XAngle.Value = origangle.x + tox
			weld.YAngle.Value = origangle.y + toy
			weld.ZAngle.Value = origangle.z + toz
			weld.C0 = CFrame.new(origpos.x + tox2,origpos.y + toy2,origpos.z + toz2) * CFrame.Angles(origangle.x + tox,origangle.y + toy,origangle.z + toz)
		end

		function LoadTextures()
			local pls = game:service("ContentProvider")
			for i, v in pairs(loadids) do
				pls:Preload("http://www.roblox.com/asset/?id="..v)
				wait(0.04)
			end
		end
		LoadTextures()

		function CreateGui()
			for i, v in pairs(player.PlayerGui:children()) do
				if v.className == "ScreenGui" and v.Name == "staminaGui" then
					v:remove()
				end
			end
			local g = Instance.new("ScreenGui", player.PlayerGui)
			g.Name = "staminaGui"

			local c = Instance.new("Frame", g)
			c.Visible = false
			c.Size = UDim2.new(0,86,0,320)
			c.BackgroundTransparency = 1
			c.Position = UDim2.new(1,-96,0.5,-160)
			c.Name = "Container"

			local t = Instance.new("TextLabel", c)
			t.Size = UDim2.new(0,0,-0.1,0)
			t.Position = UDim2.new(0.3,0,0.5,0)
			t.TextXAlignment = "Right"
			t.Font = "ArialBold"
			t.TextTransparency = 0.1
			t.TextColor3 = Color3.new(0,0.6,0.8)
			t.TextStrokeColor3 = Color3.new(0,0.2,0.8)
			t.TextStrokeTransparency = 0.3
			t.FontSize = 6
			t.BackgroundTransparency = 1
			local t2 = t:Clone()
			t2.Parent = c
			t2.Size = UDim2.new(0,0,0.1,0)
			local l = t:Clone()
			l.Parent = c
			l.Size = UDim2.new(0,0,0,0)
			l.Text = "-----"

			local f1 = Instance.new("Frame", c)
			f1.Name = "Backing"
			f1.ClipsDescendants = true
			f1.Size = UDim2.new(1,0,0,0)
			f1.BackgroundColor3 = Color3.new(0.8,0,0)
			f1.BackgroundTransparency = 1
			local f1img = Instance.new("ImageLabel", f1)
			f1img.BackgroundTransparency = 1
			f1img.Image = "http://www.roblox.com/asset/?id=112474909"
			f1img.Size = UDim2.new(1,0,0,c.Size.Y.Offset)

			local f2 = Instance.new("Frame", c)
			f2.Name = "Overlay"
			f2.ClipsDescendants = true
			f2.Size = UDim2.new(1,0,1,0)
			f2.BackgroundColor3 = Color3.new(0,0,0.8)
			f2.BackgroundTransparency = 1
			local f2img = Instance.new("ImageLabel", f2)
			f2img.BackgroundTransparency = 1
			f2img.Image = "http://www.roblox.com/asset/?id=112474911"
			f2img.Size = UDim2.new(1,0,0,c.Size.Y.Offset)

			function Calculate()
				local ysize = c.Size.Y.Offset
				local per = (stamina/maxstamina) * c.Size.Y.Offset
				local rem = (-(stamina/maxstamina-1)) * c.Size.Y.Offset
				f1.Size = UDim2.new(1,0,0,rem)
				f2.Size = UDim2.new(1,0,0,per)
				f2.Position = UDim2.new(0,0,0,rem)
				f2img.Position = UDim2.new(0,0,0,-rem)
				t.Text = math.floor(stamina)
				t2.Text = maxstamina
			end
			Calculate()

			wait(0.01)
			c.Visible = true
		end
		CreateGui()

		player.CharacterAdded:connect(function()
			char = player.Character
			Torsoz = char:findFirstChild("Torso")
			RA = char:findFirstChild("Right Arm")
			LA = char:findFirstChild("Left Arm")
			RL = char:findFirstChild("Right Leg")
			LL = char:findFirstChild("Left Leg")
			H = char:findFirstChild("Head")
			Hu = char:findFirstChild("Humanoid")
			RS = Torsoz:findFirstChild("Right Shoulder")
			LS = Torsoz:findFirstChild("Left Shoulder")
			RH = Torsoz:findFirstChild("Right Hip")
			LH = Torsoz:findFirstChild("Left Hip")
			N = Torsoz:findFirstChild("Neck")
			stamina = maxstamina
			CreateGui()
		end)

		function RAY(pos, dir, startpos, endpos, distleft, collidedlist)
			collidedlist = collidedlist or {char}
			startpos = startpos or pos
			distleft = distleft or dir.unit * dir.magnitude
			endpos = endpos or pos + distleft
			local ray = Ray.new(pos, distleft)
			local hitz,enz = workspace:FindPartOnRayWithIgnoreList(ray, collidedlist)
--[[
local p = P:Clone()
p.Parent = char
p.Size = Vector3.new(0.4,0.4,0.4)
p.BrickColor = BrickColor.new("Lime green")
p.CanCollide = false
p.CFrame = CFrame.new(enz)
p.Transparency = 0.3
]]
			if hitz ~= nil then
				if hitz.CanCollide == false then
					table.insert(collidedlist, hitz)
					local newpos = enz
					local newdistleft = distleft - (dir.unit * (pos - newpos).magnitude)
					if newdistleft ~= NV then
						return RAY(newpos-(dir*0.01), dir, startpos, endpos, newdistleft+(dir*0.01), collidedlist)
					end
				end
			end

			return hitz, enz, ray
		end

		function Sit()
			Standing = false
			local hitz,enz = RAY(Torsoz.Position, Vector3.new(0,-4.1,0))
			local tordir = Vector3.new(Torsoz.CFrame.lookVector.x,0,Torsoz.CFrame.lookVector.z)
			if (hitz ~= nil and hitz.CanCollide == true) then
				local cf = CFrame.new(enz+Vector3.new(0,1.28,0), enz+Vector3.new(0,1.28,0)+tordir) * CFrame.Angles(math.pi/6,0,0)
				local hitz2,enz2 = RAY(enz+Vector3.new(0,2.25,0), tordir*-2.2)
				Hu.PlatformStand = true
				Torsoz.CFrame = cf
				local bp = Instance.new("BodyPosition", Torsoz)
				bp.Name = "StaminaBodyObject"
				bp.maxForce = Vector3.new(1/0,1/0,1/0)
				bp.D = 100
				bp.position = cf.p
				local bg = Instance.new("BodyGyro", Torsoz)
				bg.Name = "StaminaBodyObject"
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.cframe = cf
				bg.D = 100
				SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.34,-1,0.2), Vector3.new((math.pi/2)-(math.pi/6),0,math.pi/8))
				SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.34,-1,0.2), Vector3.new((math.pi/2)-(math.pi/6),0,-math.pi/8))

				if hitz2 ~= nil and hitz2.CanCollide == true then
					Joint3.C0 = CFrame.new(0.9,0.4,-0.45) * CFrame.Angles(0,math.pi/2.13,0) * CFrame.Angles(math.pi/2.3,0,0)
					Joint4.C0 = CFrame.new(-0.9,0.4,-0.4) * CFrame.Angles(0,-math.pi/2.05,0) * CFrame.Angles(math.pi/2.3,0,0)
					Joint5.C0 = CFrame.new(0,1,0) * CFrame.Angles(-math.pi/8.8,0,0)
				else
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.4,0.4,0.1), Vector3.new(-(math.pi/6)-(math.pi/10),0,math.pi/9))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.4,0.4,0.1), Vector3.new(-(math.pi/6)-(math.pi/10),0,-math.pi/9))
					SetWeld(Joint5,1,1, NV,NV, Vector3.new(0,1,0), Vector3.new(-math.pi/12,0,0))
				end

				Sitting = true
				Action = "Sitting"
			end
		end


		function Stand()
			Hu.PlatformStand = false
			if Sitting == true then
				local tordir = Torsoz.Position + (Torsoz.CFrame.lookVector*10000)
				local cf = CFrame.new(Torsoz.Position + Vector3.new(0,1.8,0), Vector3.new(tordir.x,Torsoz.Position.y,tordir.z))
				Torsoz.CFrame = cf
			end
			for i, v in pairs(Torsoz:children()) do
				if v.Name == "StaminaBodyObject" then
					v:remove()
				end
			end
			RH.Part0 = nil
			LH.Part0 = nil
			RS.Part0 = nil
			LS.Part0 = nil
			Joint1.Part0 = Torsoz
			Joint1.Part1 = RL
			Joint1.C0 = CFrame.new(0.5,-1,0)
			Joint1.C1 = CFrame.new(0,1,0)
			Joint2.Part0 = Torsoz
			Joint2.Part1 = LL
			Joint2.C0 = CFrame.new(-0.5,-1,0)
			Joint2.C1 = CFrame.new(0,1,0)
			Joint3.Part0 = Torsoz
			Joint3.Part1 = RA
			Joint3.C0 = CFrame.new(1.5,0.5,0)
			Joint3.C1 = CFrame.new(0,0.5,0)
			Joint4.Part0 = Torsoz
			Joint4.Part1 = LA
			Joint4.C0 = CFrame.new(-1.5,0.5,0)
			Joint4.C1 = CFrame.new(0,0.5,0)
			Joint5.Part0 = Torsoz
			Joint5.Part1 = H
			Joint5.C0 = CFrame.new(0,1,0)
			Joint5.C1 = CFrame.new(0,-0.5,0)
			Sitting = false
			Diving = false
			Standing = true
			Action = "Standing"
		end

		--------------------------------------- Dive ----------------------------------

		function Dive()
			stamina = stamina - 10
			flow.Value = flow.Value + 10
			if flow.Value > 100 then
				flow.Value = 100
			end
			Standing = false
			local dir = Vector3.new(Torsoz.CFrame.lookVector.x,0,Torsoz.CFrame.lookVector.z)
			GravPoint = 18
			DivingDir = dir
			local cf = CFrame.new(Torsoz.Position, dir+Vector3.new(0,Torsoz.Position.y,0))
			DivingCF = cf
			DivingDir = dir
			Hu.PlatformStand = true
			local bv = Instance.new("BodyVelocity", Torsoz)
			bv.Name = "StaminaBodyObject"
			bv.maxForce = Vector3.new(1/0,1/0,1/0)
			bv.velocity = Vector3.new(DivingDir.x*24,GravPoint,DivingDir.z*24)
			DivingBV = bv
			local bg = Instance.new("BodyGyro", Torsoz)
			bg.Name = "StaminaBodyObject"
			bg.maxTorque = Vector3.new(1/0,1/0,1/0)
			bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+bv.velocity) * CFrame.Angles(-math.pi/2,0,0)
			bg.D = 100
			DivingBG = bg

			local joint = Joint3
			joint.C1 = CFrame.new(0,0.5,0)
			local joint2 = Joint4
			joint2.C1 = CFrame.new(0,0.5,0)
			local joint3 = Joint1
			joint3.C1 = CFrame.new(0,1,0)
			local joint4 = Joint2
			joint4.C1 = CFrame.new(0,1,0)

			local joint5 = Joint5

			Diving = true
			Action = "Diving"

			for i = 1, 8 do
				SetWeld(joint,i,8, Vector3.new(1.5,0.5,0), NV, Vector3.new(1.45,0.5,0.1), Vector3.new(-0.2,-math.pi/9,math.pi/13))
				SetWeld(joint2,i,8, Vector3.new(-1.5,0.5,0), NV, Vector3.new(-1.45,0.5,0.1), Vector3.new(-0.2,math.pi/9,-math.pi/13))
				SetWeld(joint3,i,8, Vector3.new(0.5,-1,0), NV, Vector3.new(0.5,-1,0.03), Vector3.new(-0.2,-math.pi/10,math.pi/14))
				SetWeld(joint4,i,8, Vector3.new(-0.5,-1,0), NV, Vector3.new(-0.5,-1,0.03), Vector3.new(-0.2,math.pi/10,-math.pi/14))
				SetWeld(joint5,i,8, Vector3.new(0,1,0), NV, Vector3.new(0,1,0), Vector3.new(0.45,0,0))
				wait(0.025)
			end

			local counter = 0
			while Diving == true do
				counter = counter + 1
				bg.Parent = Torsoz
				local hitz, enz = RAY(Torsoz.Position, bv.velocity.unit*4.6)
				if hitz ~= nil and hitz.CanCollide == true then
					local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-4,0))
					if hitz2 ~= nil then
						Diving = "Rolling"
						Action = "DiveRolling"
					else
						Torsoz.CFrame = Torsoz.CFrame * CFrame.new(0,-0.3,0)
						Torsoz.Velocity = NV
						flow.Value = 0
						break
					end
				end
				if counter > 190 then
					break
				end
				wait(0.02)
			end

			bv.velocity = (dir*20) + Vector3.new(0,-0.5,0)

			local bgcf = bg.cframe
			local haslanded = false
			local count = 0

			while haslanded == false do
				bg.cframe = bgcf * CFrame.Angles(-0.3*count,0,0)
				local hitz, enz = RAY(Torsoz.Position, ((Torsoz.CFrame*CFrame.new(0,-1,0)).p - Torsoz.CFrame.p).unit*1.6)
				if hitz ~= nil and hitz.CanCollide == true then
					haslanded = true
				end
				local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-3.8,0))
				if hitz2 == nil then
					Torsoz.Velocity = NV
					break
				elseif haslanded == true then
					local bp = Instance.new("BodyPosition", Torsoz)
					bp.Name = "StaminaJumpFix"
					bp.maxForce = Vector3.new(0,1/0,0)
					bp.P = 7000
					bp.position = enz2 + Vector3.new(0,2.8,0)
					game:service("Debris"):AddItem(bp, 0.3)
				else
					bv.velocity = (dir*20) + Vector3.new(0,-(Torsoz.Position - enz2).magnitude*3,0)

				end
				count = count + 1
				if count <= 6 then
					local i = count
					local j1,j1a = GetWeld(joint)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)
					SetWeld(joint,i,6, j1,j1a, Vector3.new(1.35,0.5,-0.2), Vector3.new(math.pi/2.6,0,-math.pi/5.8))
					SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.35,0.5,-0.2), Vector3.new(math.pi/2.6,0,math.pi/5.8))
					SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.51,0.4,-0.6), Vector3.new(-0.1,0,0.05))
					SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.51,0.4,-0.6), Vector3.new(-0.1,0,-0.05))
					SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,1,0), Vector3.new(-0.4,0,0))
				elseif count >= 50 then
					break
				end
				wait(0.02)
			end

			Torsoz.Velocity = NV

			Stand()
			DivingCooldown = 9
		end

		function FindSurface(part, position)
			local obj = part.CFrame:pointToObjectSpace(position)
			local siz = part.Size/2
			for i,v in pairs(Enum.NormalId:GetEnumItems()) do
				local vec = Vector3.FromNormalId(v)
				local wvec = part.CFrame:vectorToWorldSpace(vec)
				local vz = (obj)/(siz*vec)
				if (math.abs(vz.X-1) < 0.01 or math.abs(vz.Y-1) < 0.01 or math.abs(vz.Z-1) < 0.01) then
					return wvec,vec
				end
			end
			if part.className == "WedgePart" then
				return part.CFrame:vectorToWorldSpace(Vector3.new(0,0.707,-0.707)), Vector3.new(0,0.707,-0.707)
			end
		end

		function HWallRun(part, pos, side)
			if (part.className == "Part" and part.Shape == Enum.PartType.Block) or part.className ~= "Part" then
				flow.Value = flow.Value + 9
				Standing = false
				HWallRunning = true
				Action = "HWallRunning"
				GravPoint = 10
				HWRLastPart = part
				local dir, dirc = FindSurface(part, pos)
				towall = -dir
				dir = (CFrame.new(NV, dir) * CFrame.Angles(0,side,0)).lookVector

				local bv = Instance.new("BodyVelocity", Torsoz)
				bv.Name = "StaminaBodyObject"
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.P = 9000
				bv.velocity = (dir*(sprint-0.5)) + Vector3.new(0,GravPoint,0)
				local bg = Instance.new("BodyGyro", Torsoz)
				bg.Name = "StaminaBodyObject"
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.cframe = CFrame.new(Torsoz.Position+(towall*-2), Torsoz.Position) * CFrame.Angles(0,-side,-side/4.2)
				bg.D = 100

				local sid = Instance.new("Snap")

				local joint1 = Joint3
				if side == -math.pi/2 then
					SetWeld(joint1,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(math.pi/1.3,0.1,math.pi/2.5))
				else
					sid = joint1
					SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.6,0), Vector3.new(-math.pi/12,0,math.pi/7))
				end
				local j1c0 = joint1.C0

				local joint2 = Joint4
				if side == math.pi/2 then
					SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(math.pi/1.3,-0.1,-math.pi/2.5))
				else
					sid = joint2
					SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.6,0), Vector3.new(-math.pi/12,0,-math.pi/7))
				end
				local j2c0 = joint2.C0

				local joint3 = Joint1
				joint3.C1 = CFrame.new(0,1,0)
				if side == -math.pi/2 then
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.38,-0.3), Vector3.new(0,math.pi/2,0.14))
				else
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.8,-0.2), Vector3.new(0,math.pi/2,0.2))
				end

				local joint4 = Joint2
				joint4.C1 = CFrame.new(0,1,0)
				if side == -math.pi/2 then
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.8,-0.2), Vector3.new(0,0,0.2))
				else
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.38,-0.3), Vector3.new(0,0,0.14))
				end

				local joint5 = Joint5
				SetWeld(joint5,1,1,NV,NV,Vector3.new(0,0.9,0),Vector3.new(0,0,side/7))

				Torsoz.CFrame = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)
				bg.cframe = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)

				local aniangle = 0
				local aniplus = true
				local aniangle2 = 0
				local aniplus2 = true

				local prevpart = part
				HWRLastPart = part
				while HWallRunning == true do

					if aniangle > math.pi then
						aniplus = false
					elseif aniangle < -math.pi then
						aniplus = true  
					end
					if aniplus == true then
						aniangle = aniangle + 0.95
					elseif aniplus == false then
						aniangle = aniangle - 0.95
					end

					if aniangle2 > math.pi then
						aniplus2 = false
					elseif aniangle2 < -math.pi then
						aniplus2 = true  
					end
					if aniplus2 == true then
						aniangle2 = aniangle2 + 0.23
					elseif aniplus2 == false then
						aniangle2 = aniangle2 - 0.23
					end

					Hu.PlatformStand = true
					local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3,0))
					local hitz2, enz2 = RAY(Torsoz.Position, towall*3.4)

					--- if player ends wall run on ground
					if hitz ~= nil and hitz.CanCollide == true then
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
						local offset = (bg.cframe.p.y+enz2.y) - bg.cframe.p.y
						Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
						Torsoz.Velocity = NV
						break
					end

					---- if new wall found --------
					if hitz2 ~= nil and hitz2.CanCollide == true then
						if hitz2 ~= prevpart then
							local direct = CFrame.new(Torsoz.Position, Torsoz.Position+dir) * CFrame.Angles(0,side,0)
							local hitz3, enz3 = RAY(Torsoz.Position, (direct * CFrame.Angles(0,-side/2.3,0)).lookVector*4)
							if hitz3 ~= nil then
								Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
								bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
								dir, dirc = FindSurface(hitz2, enz2)
								towall = -dir
								dir = (CFrame.new(NV, dir) * CFrame.Angles(0,side,0)).lookVector
								prevpart = hitz2
								HWRLastPart = hitz2
							else
								---- if player fails to find new wall to run on
								Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
								bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
								Torsoz.Velocity = NV
								HWRCooldown = 5
								break
							end
						end
						--- continue to wall run
						Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
					else
						---- if player ends wall run at end of wall
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						Torsoz.Velocity = NV
						HWRCooldown = 5
						break
					end

					local hitz3, enz3 = RAY(Torsoz.Position, Torsoz.CFrame.lookVector*2)
					if hitz3 ~= nil and hitz3.CanCollide == true then
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						Torsoz.Velocity = NV
						HWRCooldown = 5
						break
					end

					bv.Parent = Torsoz
					bv.velocity = (dir*(sprint-0.5)) + Vector3.new(0,GravPoint,0)
					bg.cframe = bg.cframe * CFrame.Angles(aniangle/80,aniangle/80,0)
					Torsoz.CFrame = Torsoz.CFrame * CFrame.Angles(aniangle/80,aniangle/80,0)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					SetWeld(joint3,1,1, j3,j3a, j3,Vector3.new(-0.2+(aniangle/4),0,0))
					SetWeld(joint4,1,1, j4,j4a, j4,Vector3.new(-0.2+(-aniangle/4),0,0))
					if side == math.pi/2 then
						local j1,j1a = GetWeld(joint1)
						SetWeld(joint1,1,1, j1,j1a, j1, Vector3.new(0,0,0.8+(aniangle2/14)))
					else
						local j2,j2a = GetWeld(joint2)
						SetWeld(joint2,1,1, j2,j2a, j2, Vector3.new(0,0,-0.8-(aniangle2/14)))
					end

					wait(0.025)
					if GravPoint < -100 then
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
						local offset = math.abs((bg.cframe.p.y+enz2.y) - bg.cframe.p.y)
						Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
						break
					end

				end

				if HWallRunning == "Jumping" then
					HWRCooldown = 6
					joint1.C1 = CFrame.new(0,0.5,0)

					joint2.C1 = CFrame.new(0,0.5,0)
					if side == -math.pi/2 then
						joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/3)
					else
						joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/4)
					end

					joint3.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),-math.pi/4)
					else
						joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),math.pi/4)
					end
					joint4.MaxVelocity = 10
					joint4.DesiredAngle = 0
					joint4.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),math.pi/4)
					else
						joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),-math.pi/4)
					end

					local joint5 = Joint5
					joint5.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(0,side/2.4,0)
					joint5.C0 = CFrame.new(0,1,0)

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					GravPoint = 26
					local collidecount = 0
					local bgangle = side/2
					local count = 1
					local dir2 = (CFrame.new(NV, dir) * CFrame.Angles(0,-side/2.4,0)).lookVector
					HWRDir = dir2
					bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
					while HWallRunning == "Jumping" do
						local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-4,0))
						local hitz2, enz2 = RAY(Torsoz.Position, dir2*1.4)
						if hitz ~= nil and hitz.CanCollide == true then
							local offset = math.abs(enz.y - Torsoz.CFrame.p.y)
							Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2.9,0), enz+Vector3.new(0,2.9,0)+dir2)
							Torsoz.Velocity = NV
							break
						end

						if hitz2 ~= nil and hitz2.CanCollide == true then
							collidecount = collidecount + 1
							if collidecount == 4 then
								Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir2) * CFrame.new(0,0,0.4)
								Torsoz.Velocity = Vector3.new(0,Torsoz.Velocity.y,0)
								HWRCooldown = 5
								VWRCooldown = 5
								wait(0.02)
								break
							end
						end

						if side/2 > 0 then
							if bgangle > 0.2 then
								bgangle = bgangle - 0.055
							end
						else
							if bgangle < -0.2 then
								bgangle = bgangle + 0.055
							end
						end

						if count <= 5 then
							if side == -math.pi/2 then
								SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/4))
								SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/3))
								SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint3.C0 = joint3.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
								SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint4.C0 = joint4.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
							else
								SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/3))
								SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/4))
								SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint3.C0 = joint3.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
								SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint4.C0 = joint4.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
							end

							count = count + 1
						end

						bg.Parent = Torsoz
						bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(0,side/15,-bgangle)
						bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
						if collidecount ~= 0 then
							bv.velocity = Vector3.new(0,bv.velocity.y,0)
						end
						if GravPoint < -120 then
							break
						end
						wait(0.025)
					end
				end

				Hu.PlatformStand = false
				bv:remove()

				HWRGravDrop = false
				Stand()
				HWallRunning = false
			end
		end

		function VWR(part, pos)
			if (part.className == "Part" and part.Shape == Enum.PartType.Block) or part.className ~= "Part" then
				print("VWR Activated")
				flow.Value = flow.Value + 9
				Standing = false
				VWallRunning = true
				Action = "VWallRunning"
				GravPoint = 0
				local percent = 1
				VWRLastPart = part
				local dir, dirc = FindSurface(part, pos)
				towall = -dir
				dir = (CFrame.new(NV, -dir) * CFrame.Angles(math.pi/2,0,0)).lookVector
--[[
local p = P:Clone()
p.Parent = char
p.Size = Vector3.new(2,2,2)
p.BrickColor = BrickColor.new("Lime green")
p.CanCollide = false
p.CFrame = part.CFrame * CFrame.new(dirc*5)
p.Transparency = 0.3
]]
				local bv = Instance.new("BodyVelocity", Torsoz)
				bv.Name = "StaminaBodyObject"
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.P = 9000
				bv.velocity = (dir*(sprint-1))*percent

				local bg = Instance.new("BodyGyro", Torsoz)
				bg.Name = "StaminaBodyObject"
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.D = 100
				local posi = pos + (-towall*1.8)
				bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)
				Torsoz.CFrame = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)

				local joint1 = Joint3
				SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,math.pi/8))

				local joint2 = Joint4
				SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,-math.pi/8))

				local joint3 = Joint1
				SetWeld(joint3,1,1, NV,NV, Vector3.new(0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
				joint3.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

				local joint4 = Joint2
				SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
				joint4.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

				local joint5 = Joint5
				SetWeld(joint5,1,1, NV,NV, Vector3.new(0,1,0), Vector3.new(math.pi/20,0,0))

				local aniangle = 0
				local aniplus = true

				while VWallRunning == true do
					local hitz, enz = RAY(Torsoz.Position, towall*2.1)
					local hitz2, enz2 = RAY(Torsoz.Position, (CFrame.new(NV,towall)*CFrame.Angles(math.pi/2,0,0)).lookVector*2.4)

					if aniangle > math.pi then
						aniplus = false
					elseif aniangle < -math.pi then
						aniplus = true  
					end
					if aniplus == true then
						aniangle = aniangle + (1.3*(percent+0.2))
					elseif aniplus == false then
						aniangle = aniangle - (1.3*(percent+0.2))
					end

					bv.velocity = (dir*(sprint-1))*percent
					if VWRLeft == true then
						bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
					end
					if VWRRight == true then
						bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
					end

					bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0) * CFrame.Angles(0,aniangle/60,0)

					SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(math.pi/8)+(aniangle/30)))
					SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(-math.pi/8)+(-aniangle/30)))
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.51,-0.75,-(aniangle/30)), Vector3.new(0,math.pi/2,(aniangle/8)-0.3))
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.51,-0.75,(aniangle/30)), Vector3.new(0,math.pi/2,(-aniangle/8)-0.3))

					if hitz == nil then
						local lv = Torsoz.Position + (Torsoz.CFrame.lookVector*100)
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Vector3.new(lv.x,Torsoz.Position.y,lv.z))
						break
					end

					if hitz2 ~= nil then
						percent = 0
						VWallRunning = "Falling"
						Action = "VWRFalling"
						GravPoint = -7
						break
					end

					wait(0.02)
					percent = percent - 0.028
					if percent <= 0.15 then
						VWallRunning = "Falling"
						Action = "VWRFalling"
					end
				end

				-------------------------- Falling from VWR ------------------------------
				if VWallRunning == "Falling" then
					GravPoint = GravPoint - 1
					local dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
					bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					local counter = 0
					while VWallRunning == "Falling" do
						counter = counter + 1
						local hitz, enz = RAY(H.Position, Vector3.new(0,-2.4,0))

						dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
						bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
						if VWRLeft == true then
							bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						if VWRRight == true then
							bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles(-math.pi/2.55,math.pi,0)

						if counter <= 35 then
							SetWeld(joint1,counter,35, j1,j1a, Vector3.new(1.4,0.45,-0.1), Vector3.new(math.pi/9,0,math.pi/9))
							SetWeld(joint2,counter,35, j2,j2a, Vector3.new(-1.4,0.45,-0.1), Vector3.new(math.pi/9,0,-math.pi/9))
							SetWeld(joint3,counter,35, j3,j3a, Vector3.new(0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
							joint3.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
							SetWeld(joint4,counter,35, j4,j4a, Vector3.new(-0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
							joint4.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
							SetWeld(joint5,counter,35, j5,j5a, Vector3.new(0,1,0), Vector3.new(-math.pi/6,0,0))
						end

						if hitz ~= nil then
							bv:remove()
							Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2,0), (enz+Vector3.new(0,2,0)) + ((-towall*25) + Vector3.new(0,GravPoint,0))) * CFrame.Angles(-math.pi/2.55,math.pi,0)
							Torsoz.Velocity = NV
							Torsoz.RotVelocity = NV
							local bp = Instance.new("BodyPosition", Torsoz)
							bp.maxForce = Vector3.new(1/0,1/0,1/0)
							bp.position = Torsoz.CFrame.p
							game:service("Debris"):AddItem(bp, 0.16)
							flow.Value = 0
							break
						end

						if GravPoint > - 180 then
							GravPoint = GravPoint - 1.9
						end
						if counter > 200 then
							break
						end
						wait(0.02)
					end

					local bp = Instance.new("BodyPosition")

					local counter2 = counter
					local bgangleplus = 0

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					local landingpos

					while VWallRunning == "BackflipFromFall" do
						counter2 = counter2 + 1
						local hitz, enz = RAY(H.Position+Vector3.new(0,2,0), Vector3.new(0,-4.4,0))

						if counter2 - counter < 13 then
							bgangleplus = bgangleplus - ((math.pi*1.1)/13)
						end
						if counter2 - counter <= 13 then
							SetWeld(joint1,counter2-counter,13, j1,j1a, Vector3.new(1.4,0.5,0.1), Vector3.new(math.pi/2,0.1,math.pi/2))
							SetWeld(joint2,counter2-counter,13, j2,j2a, Vector3.new(-1.4,0.5,0.1), Vector3.new(math.pi/2,-0.1,-math.pi/2))
							SetWeld(joint3,counter2-counter,13, j3,j3a, Vector3.new(0.52,-0.3,-0.65), Vector3.new(0,math.pi/2,0))
							SetWeld(joint4,counter2-counter,13, j4,j4a, Vector3.new(-0.51,-0.9,-0.05), Vector3.new(0,math.pi/2,0))
							SetWeld(joint5,counter2-counter,13, j5,j5a, Vector3.new(0,0.9,0), Vector3.new(-math.pi/7,0,0))
						end

						dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
						--bv.velocity = Vector3.new(0,-2,0)
						bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
						if VWRLeft == true then
							bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						if VWRRight == true then
							bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles((-math.pi/2.4) + bgangleplus,math.pi,0)

						if hitz ~= nil then
							bv:remove()
							landingpos = enz - (towall*1.3)
							if counter2 - counter > 8 then
								bp = Instance.new("BodyPosition", Torsoz)
								bp.maxForce = Vector3.new(1/0,1/0,1/0)
								bp.position = enz+Vector3.new(0,2.4,0) + (-towall*1)
								VWallRunning = "LandingFall"
							else
								Torsoz.CFrame = bg.cframe + (enz+Vector3.new(0,2.3,0))
								Torsoz.Velocity = NV
								Torsoz.RotVelocity = NV
								local bp = Instance.new("BodyPosition", Torsoz)
								bp.maxForce = Vector3.new(1/0,1/0,1/0)
								bp.position = Torsoz.CFrame.p
								game:service("Debris"):AddItem(bp, 0.14)
								flow.Value = 0
							end
							break
						end

						if GravPoint > - 180 then
							GravPoint = GravPoint - 1.9
						end
						if counter2 > 200 then
							break
						end
						wait(0.02)
					end

					if VWallRunning == "LandingFall" then
						print("Landing")

						joint3.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
						joint4.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)

						local a
						local mesh
						if GravPoint < -70 then
							a = P:Clone()
							a.Parent = Torsoz
							a.Name = "AirLandingEffect"
							a.BrickColor = BrickColor.new("Medium stone grey")
							a.Transparency = 0.3
							a.CFrame = CFrame.new(landingpos+Vector3.new(0,0.4,0))
							mesh = Instance.new("SpecialMesh", a)
							mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
							mesh.Scale = Vector3.new(0,0,0)
						end

						local bgcf = CFrame.new(NV, Vector3.new(towall.x,0,towall.z))
						bg.cframe = bgcf * CFrame.Angles(-math.pi/7,0,0)
						local bgval = math.pi/7/2

						for i = 1, 6 do
							Hu.PlatformStand = true
							SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.2,0.5,0.2), Vector3.new(math.pi/2,0.5,math.pi/1.2))
							SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.2,0.5,0.2), Vector3.new(math.pi/2,-0.5,-math.pi/1.2))
							SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.51,-0.3,-0.8), Vector3.new(0,math.pi/2,-math.pi/7))
							SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.51,-0.8,-0.7), Vector3.new(0,math.pi/2,-math.pi/3))
							SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,0.85,0), Vector3.new(-math.pi/8,0,0))
							bp.position = bp.position + Vector3.new(0,-0.07,0)
							bg.cframe = bgcf * CFrame.Angles((-bgval*2) + (bgval/6*i),0,0)
							Torsoz.CFrame = bg.cframe + bp.position
							if a ~= nil then
								mesh.Scale = mesh.Scale + Vector3.new(1.3,0.35,1.3)
								a.Transparency = 0.3 + (0.7/6*i)
							end
							wait(0.02)
						end
						if a ~= nil then
							a:remove()
						end
						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)
						for i = 1, 6 do
							Hu.PlatformStand = true
							SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.5,0.5,0), Vector3.new(0,0,0))
							SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.5,0.5,0), Vector3.new(0,0,0))
							SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
							SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
							SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,1,0), Vector3.new(0,0,0))
							bp.position = bp.position + Vector3.new(0,0.1,0)
							bg.cframe = bgcf * CFrame.Angles(-bgval + (bgval/6*i),0,0)
							Torsoz.CFrame = bg.cframe + bp.position
							wait(0.02)
						end

						bp:remove()
					end

				end

				bv:remove()
				bg:remove()
				VWallRunning = false
				Stand()
			end
		end

		function Slide(pos)
			flow.Value = flow.Value + 6
			Action = "Sliding"
			Sliding = true
			GravPoint = Torsoz.Velocity.y
			local spd = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude + 10
			local dir = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).unit

			local bv = Instance.new("BodyVelocity", Torsoz)
			bv.maxForce = Vector3.new(1/0,1/0,1/0)
			bv.velocity = dir*spd
			local bg = Instance.new("BodyGyro", Torsoz)
			bg.maxTorque = Vector3.new(1/0,1/0,1/0)
			bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)

			local joint1 = Joint1
			local joint2 = Joint2
			local joint3 = Joint3
			local joint4 = Joint4
			local joint5 = Joint5
			local j1,j1a = GetWeld(joint1)
			local j2,j2a = GetWeld(joint2)

			SetWeld(joint1,1,1, NV,NV, Vector3.new(j1.x,j1.y,j1.z), Vector3.new(j1a.x,math.pi/2,j1a.z))
			joint1.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
			SetWeld(joint2,1,1, NV,NV, Vector3.new(j2.x,j2.y,j2.z), Vector3.new(j2a.x,math.pi/2,j2a.z))
			joint2.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)

			local j1,j1a = GetWeld(joint1)
			local j2,j2a = GetWeld(joint2)
			local j3,j3a = GetWeld(joint3)
			local j4,j4a = GetWeld(joint4)
			local j5,j5a = GetWeld(joint5)

			local count = 0
			local lastpos

			while Sliding == true do
				count = count + 1
				Hu.PlatformStand = true
				local hitz1, enz1 = RAY(Torsoz.Position+Vector3.new(0,0.03,0), dir *2.5)
				local hitz2, enz2 = RAY(Torsoz.Position-Vector3.new(0,0.2,0), dir *2.5)
				local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
				bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

				if count <= 5 then
					SetWeld(joint1,count,5, j1,j1a, Vector3.new(0.5,-0.8,-0.15), Vector3.new(0,(math.pi/2)+0.1,-0.4))
					SetWeld(joint2,count,5, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,(math.pi/2)-0.4,0))
					SetWeld(joint3,count,5, j3,j3a, Vector3.new(1.5,0.5,0), Vector3.new(-0.7,-0.24,math.pi/5))
					SetWeld(joint4,count,5, j4,j4a, Vector3.new(-1.5,0.5,0), Vector3.new(-0.1,0,-math.pi/1.5))
					SetWeld(joint5,count,5, j5,j5a, Vector3.new(0,1,0), Vector3.new(-0.5,-0.2,0))
				end

				if (hitz1 ~= nil and hitz1.CanCollide == true) or (hitz2 ~= nil and  hitz2.CanCollide == true) then
					bv:remove()
					bg:remove()
					Sliding = "HitObject"
				end
				if ghitz ~= nil then
					GravPoint = 0
					Torsoz.CFrame = CFrame.new(genz, genz+dir) * CFrame.Angles(math.pi/2.2,0.24,0) + Vector3.new(0,0.7,0)
					spd = spd - 0.95
				else
					if GravPoint > -180 then
						GravPoint = GravPoint - 5.6
					end
					spd = spd - 0.36
				end
				if spd < 7 then
					Sliding = false
				end
				wait(0.02)
			end

			if Sliding == false then
				local j1,j1a = GetWeld(joint1)
				local j2,j2a = GetWeld(joint2)
				local j3,j3a = GetWeld(joint3)
				local j4,j4a = GetWeld(joint4)
				local j5,j5a = GetWeld(joint5)
				for i = 1, 4 do
					SetWeld(joint1,i,4, j1,j1a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
					SetWeld(joint2,i,4, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
					SetWeld(joint3,i,4, j3,j3a, Vector3.new(1.5,0.5,0), NV)
					SetWeld(joint4,i,4, j4,j4a, Vector3.new(-1.5,0.5,0), NV)
					SetWeld(joint5,i,4, j5,j5a, Vector3.new(0,1,0), NV)
					local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
					bg.cframe = CFrame.new(NV, dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0)
					bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

					if hitz ~= nil then
						GravPoint = 0
						Torsoz.CFrame = CFrame.new(enz, enz+dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0) + Vector3.new(0,0.7+(1.8/4*i),0)
						spd = spd - 0.95
					else
						if GravPoint > -180 then
							GravPoint = GravPoint - 5.6
						end
						spd = spd - 0.36
					end
					wait(0.02)
				end
				local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
				Torsoz.CFrame = CFrame.new(enz, enz+dir) + Vector3.new(0,3,0)
			end
			bv:remove()
			bg:remove()
			SlideCooldown = 10
			Stand()
		end

		function KD(key)
			if pause.Value == false then
				if key == string.char(32) then
					Space = true

					local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-3.7,0))
					local hitz, enz = RAY(Torsoz.Position+Vector3.new(0,1.1,0), Torsoz.CFrame.lookVector*2.3)
					local righthitz, rightenz
					local lefthitz, leftenz

					if HWallRunning == false then
						righthitz, rightenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)
						lefthitz, leftenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(-1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)

					elseif HWallRunning == "Jumping" then
						righthitz, rightenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)
						lefthitz, leftenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(-1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)

					end

					if Action == "Standing" and Shift == true and (hitz == nil or hitz.CanCollide == false) and (righthitz == nil or righthitz.CanCollide == false) and (lefthitz == nil or lefthitz.CanCollide == false) and (ghitz == nil or ghitz.CanCollide == false) and (Torsoz.Velocity.y > 6 and Torsoz.Velocity.y < 50) and DivingCooldown <= 0 then
						if stamina >= 10 then
							--if Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 12 then
							Dive()
							--end
						end
					end

					if hitz == nil and VWallRunning == "Falling" then
						VWallRunning = "BackflipFromFall"
					end

					if Shift == true and Torsoz.Velocity.y > -50 and Diving == false and DivingCooldown <= 0 then
						local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-3.5,0))

						if hitz ~= nil then
							if Action == "Standing" and VWRCooldown == 0 then
								if hitz2 == nil or hitz2.CanCollide == false then
									VWR(hitz, enz)
								end
							end
						end

						if (HWallRunning == false or (HWallRunning == "Jumping" and (HWRLastPart ~= righthitz or HWRLastPart ~= lefthitz))) and HWRCooldown == 0 and VWallRunning == false then

							if (hitz == nil or HWallRunning == "Jumping") and ((righthitz ~= nil and righthitz.Parent:findFirstChild("Humanoid") == nil and righthitz.Parent.className ~= "Hat") or (lefthitz ~= nil and lefthitz.Parent:findFirstChild("Humanoid") == nil and lefthitz.Parent.className ~= "Hat")) then
								if hitz2 == nil or hitz2.CanCollide == false then
									local right = (rightenz - Torsoz.Position).magnitude
									local left = (leftenz - Torsoz.Position).magnitude
									if right < left then
										if HWallRunning == "Jumping" and HWRLastPart ~= righthitz then
											HWallRunning = false
											while Standing == false do
												wait(0.01)
											end
											print("2nd Right Activated!")
											HWallRun(righthitz, rightenz, -math.pi/2)
										else
											if hitz == nil then
												print("Right Activated")
												HWallRun(righthitz, rightenz, -math.pi/2)
											end
										end
									elseif left < right then
										if HWallRunning == "Jumping" and HWRLastPart ~= lefthitz then
											HWallRunning = false
											while Standing == false do
												wait(0.01)
											end
											print("2nd Left Activated!")
											HWallRun(lefthitz, leftenz, math.pi/2)
										else
											if hitz == nil then
												print("Left Activated")
												HWallRun(lefthitz, leftenz, math.pi/2)
											end
										end
									end
								end
							end
						end

					end

					if HWallRunning == true then
						HWallRunning = "Jumping"
						Action = "HWRJumping"
					end

				elseif key == string.char(48) then
					Shift = true
				elseif key == string.char(50) then
					if Action == "Standing" then
						Sit()
					elseif HWallRunning == true then
						HWRGravDrop = true
					end
				elseif key == string.char(52) then
					if Shift == true and Action == "Standing" and SlideCooldown == 0 and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 15 and Torsoz.Velocity.y > -40 then
						print("Sliding")
						Slide()
					end
				elseif key == "a" then
					VWRLeft = true
				elseif key == "d" then
					VWRRight = true
				end
			end
		end

		function KU(key)
			if key == string.char(32) then
				Space = false
			elseif key == string.char(48) then
				Shift = false
			elseif key == string.char(50) then
				if Action == "Sitting" then
					Stand()
				end
			elseif key == string.char(52) then
				Sliding = false
			elseif key == "a" then
				VWRLeft = false
			elseif key == "d" then
				VWRRight = false
			end
		end

		mouse.KeyDown:connect(function(key) KD(key) end)
		mouse.KeyUp:connect(function(key) KU(key) end)

		Joint1 = Instance.new("Snap", Torsoz)
		GetWeld(Joint1)
		Joint2 = Instance.new("Snap", Torsoz)
		GetWeld(Joint2)
		Joint3 = Instance.new("Snap", Torsoz)
		GetWeld(Joint3)
		Joint4 = Instance.new("Snap", Torsoz)
		GetWeld(Joint4)
		Joint5 = Instance.new("Snap", Torsoz)
		GetWeld(Joint5)
		Stand()

		local animatebg = Instance.new("BodyGyro")
		animatebg.D = 100
		local GravAction = "Idle"
		local PrevGravAction = GravAction

		local prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
		local prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
		local hue = 0
		local recyclecount = 0
		local tickoffset = tick()
		local fadetab = {}
		local fadetab2 = {}
		local animatebgcount = 0

		for i = 1, 13 do
			local p = P:Clone()
			p.Name = "Part"..i
			local mesh = Instance.new("SpecialMesh", p)
			mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
			mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
			table.insert(fadetab, {p, mesh})
		end
		for i = 1, 13 do
			local p = P:Clone()
			p.Name = "Part"..i
			local mesh = Instance.new("SpecialMesh", p)
			mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
			mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
			table.insert(fadetab2, {p, mesh})
		end

		game:service("RunService").Stepped:connect(function()
			GravAction = "Idle"
			hue = hue + 3
			hue = hue % 360

			------------- anim angle changing --------
			if animangle > math.pi then
				animplus = false
			elseif animangle < -math.pi then
				animplus = true  
			end
			if animplus == true then
				animangle = animangle + animspeed
			elseif animplus == false then
				animangle = animangle - animspeed
			end

			local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3.9,0))
			if Shift == true then
				Hu.WalkSpeed = sprint
			else
				Hu.WalkSpeed = 16
			end
			if (FOV >= 70 and FOV < 74) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 25 then
				FOV = FOV + 1
			elseif (FOV <= 74 and FOV > 70) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude < 20 then
				FOV = FOV - 1
			end
			if pause.Value == true then
				Hu.WalkSpeed = 0
			end
			if Sitting == true then
				local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-2.2,0))
				Hu.PlatformStand = true
				if hitz2 == nil then
					Stand()
				end
			end
			if Diving == true then
				Hu.PlatformStand = true
				DivingBV.velocity = Vector3.new(DivingDir.x*(sprint+2),GravPoint,DivingDir.z*(sprint+2))
				DivingBG.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+DivingBV.velocity) * CFrame.Angles(-math.pi/2,0,0)

				if GravPoint > -180 then
					GravPoint = GravPoint - 2
				end
			end
			if DivingCooldown > 0 then
				DivingCooldown = DivingCooldown - 1
			end
			if HWallRunning == true then
				if HWRGravDrop == false then
					GravPoint = GravPoint - 0.4
				else
					GravPoint = GravPoint - 2
				end
			elseif HWallRunning == "Jumping" then
				GravPoint = GravPoint - 1.7
			end
			----------------------------- stamina ----------------------------------------
			if Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 18 and Action == "Standing" and Shift == true then
				if stamina > 0 then
					stamina = stamina - 0.5
					if stamina < 0 then
						Shift = false
						stamina = 0
					end
				else
					Shift = false
					stamina = 0
				end
				if Action == "Standing" then
					animspeed = 0.85
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/4.85,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/4.85,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/3.5,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/3.5,0,0))
				end
			elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 12 and Action ~= "Sliding" then
				if stamina < maxstamina then
					stamina = stamina + 0.5
					if stamina > maxstamina then
						stamina = maxstamina
					end
				else
					stamina = maxstamina
				end
				if Action == "Standing" then
					animspeed = 0.65
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/7,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/7,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/5,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/5,0,0))
				end
			elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude < 2 then
				animspeed = 0.1
				if Action == "Standing" then
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/30,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/30,0,0))
				end
				if stamina < maxstamina then
					if Sitting == false then
						stamina = stamina + 0.65
					else
						stamina = stamina + 1.02
					end
					if stamina > maxstamina then
						stamina = maxstamina
					end
				else
					stamina = maxstamina
				end
			end

			if hitz == nil then
				if Torsoz.Velocity.y > 1 or (Torsoz.Velocity.y < -1 and Torsoz.Velocity.y > -90) then
					if Action == "Standing" then
						GravAction = "Rising"
						animspeed = 0.1
						SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
						SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new((math.pi-0.2)+(animangle/30),0,0))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new((math.pi-0.2)+(-animangle/30),0,0))
						if animatebg.Parent ~= nil then
							animatebg.Parent = Torsoz
							animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
							local lokvec = Torsoz.CFrame.lookVector*100
							animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
							animatebg.Parent = nil
						end
					end
				end
			end

			if hitz == nil then
				local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-6,0))
				if hitz2 == nil then
					if Torsoz.Velocity.y < -90 then
						if Action == "Standing" then
							GravAction = "Falling"
							animspeed = 1.1
							animatebg.Parent = Torsoz
							animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
							local lokvec = Torsoz.CFrame.lookVector*100
							animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z)) * CFrame.Angles(-math.pi/11,animangle/70,0)
							SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.45,-0.8,0), Vector3.new((animangle/27)-0.3,0,0.18))
							SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.45,-0.8,0), Vector3.new((-animangle/27)-0.3,0,-0.18))
							SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.4,0.5,0), Vector3.new((math.pi+0.2)+(animangle/26),0,0.18))
							SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.4,0.5,0), Vector3.new((math.pi+0.2)+(-animangle/26),0,-0.18))
						end
					end
				elseif hitz2.CanCollide == true then
					if animatebg.Parent ~= nil then
						animatebg.Parent = Torsoz
						animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
						local lokvec = Torsoz.CFrame.lookVector*100
						animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
						animatebg.Parent = nil
					end
				end
			end

			if GravAction == "Idle" and animatebg.Parent ~= nil then
				animatebg.Parent = nil
			end

			if math.abs(tickoffset - tick()) > 0.05 then
				tickoffset = tick()
				local flowcolor = HSV(hue, 0.7,1)
				recyclecount = (recyclecount % #fadetab) + 1
				if flow.Value > 25 then
					local lapos = (LA.CFrame * CFrame.new(0,-1,0)).p
					local rapos = (RA.CFrame * CFrame.new(0,-1,0)).p
					local p = fadetab[recyclecount]
					p[1].Parent = m
					p[1].CFrame = CFrame.new((lapos+prevlapos)/2, lapos)
					p[2].Scale = Vector3.new(0.5,0.5,(lapos-prevlapos).magnitude*2)
					p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
					p[1].Transparency = math.abs((flow.Value/120) - 0.8)
					p[1].Transparency = p[1].Transparency + (1/#fadetab)
					local p = fadetab2[recyclecount]
					p[1].Parent = m
					p[1].CFrame = CFrame.new((rapos+prevrapos)/2, rapos)
					p[2].Scale = Vector3.new(0.5,0.5,(rapos-prevrapos).magnitude*2)
					p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
					p[1].Transparency = math.abs((flow.Value/120) - 0.8)
					p[1].Transparency = p[1].Transparency + (1/#fadetab)
				end

				for i, v in pairs(fadetab) do
					if v[1].Transparency < 0.9 then
						v[1].Transparency = v[1].Transparency + (1/#fadetab)
						fadetab2[i][1].Transparency = fadetab2[i][1].Transparency + (1/#fadetab)
					elseif v[1].Transparency ~= 1 then
						v[1].Transparency = 1
						v[1].Position = Vector3.new(50000,0,0)
						fadetab2[i][1].Transparency = 1
						fadetab2[i][1].Position = Vector3.new(50000,0,0)
					end
				end

				prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
				prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
			end

			if flow.Value > 140 then
				if char.Parent ~= nil then
					char:remove()
				end
			end

			if flowcooldown > 0 then
				flowcooldown = flowcooldown - 1
			end
			if HWRCooldown > 0 then
				HWRCooldown = HWRCooldown - 1
			end
			if VWRCooldown > 0 then
				if hitz ~= nil and VWRCooldown > 0 then
					VWRCooldown = VWRCooldown - 1
				end
			end
			if SlideCooldown > 0 then
				SlideCooldown = SlideCooldown - 1
			end

			if Action == "HWallRunning" or Action == "VWallRunning" then
				flow.Value = flow.Value + 0.24
				if flow.Value > 100 then
					flow.Value = 100
				end
				flowcooldown = 40
			elseif Action == "Diving" then
				flowcooldown = 30
			elseif Action == "Sliding" then
				flowcooldown = 15
			elseif Action == "Standing" or Action == "Sitting" then
				if flow.Value > 0 and flowcooldown <= 0 then
					flow.Value = flow.Value - 0.37
					if flow.Value < 0 then
						flow.Value = 0
					end
				end
			end

			cam.FieldOfView = FOV
			prevanimbgcount = animatebgcount
			sprint = defsprint + ((flow.Value/100)*2.4)
			PrevGravAction = GravAction
			Calculate()
		end)
	end)
end
coroutine.wrap(FUIQ_fake_script)()
local function OJBQH_fake_script() -- Killbot.LocalScript 
	local script = Instance.new('LocalScript', Killbot)

	Killbot.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/G24tcRXA"))()
	end)
end
coroutine.wrap(OJBQH_fake_script)()
local function FBOEIQQ_fake_script() -- Page.LocalScript 
	local script = Instance.new('LocalScript', Page)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page2"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(FBOEIQQ_fake_script)()
local function AYMBPZZ_fake_script() -- Smug.LocalScript 
	local script = Instance.new('LocalScript', Smug)

	Smug.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/ZuKy7HFF"))()
	end)
end
coroutine.wrap(AYMBPZZ_fake_script)()
local function DXDC_fake_script() -- Ender.LocalScript 
	local script = Instance.new('LocalScript', Ender)

	Ender.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/bndCgupK"))()
	end)
end
coroutine.wrap(DXDC_fake_script)()
local function IQJKYKI_fake_script() -- Spider.LocalScript 
	local script = Instance.new('LocalScript', Spider)

	Spider.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/txsk1LJg"))()
	end)
end
coroutine.wrap(IQJKYKI_fake_script)()
local function TBTR_fake_script() -- Sonic.LocalScript 
	local script = Instance.new('LocalScript', Sonic)

	Sonic.MouseButton1Down:connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/SyF5t70A"))()
	end)
end
coroutine.wrap(TBTR_fake_script)()
local function LUOM_fake_script() -- Page_2.LocalScript 
	local script = Instance.new('LocalScript', Page_2)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page1"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(-1,0,.3,0)
		currpage:TweenPosition(UDim2.new(1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(LUOM_fake_script)()
local function BEIEU_fake_script() -- Page_3.LocalScript 
	local script = Instance.new('LocalScript', Page_3)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page3"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(BEIEU_fake_script)()
local function UALQUS_fake_script() -- UtgV2.LocalScript 
	local script = Instance.new('LocalScript', UtgV2)

	UtgV2.MouseButton1Down:connect(function()
		-- Gui to Lua
		-- Version: 3.2

		-- Instances:

		local UTG_V2 = Instance.new("ScreenGui")
		local Main = Instance.new("Frame")
		local UIGradient = Instance.new("UIGradient")
		local UICorner = Instance.new("UICorner")
		local Title = Instance.new("TextLabel")
		local SubTitile = Instance.new("TextLabel")
		local Welcome = Instance.new("TextLabel")
		local UICorner_2 = Instance.new("UICorner")
		local Credits = Instance.new("TextLabel")
		local UICorner_3 = Instance.new("UICorner")
		local OptionListFrame = Instance.new("Frame")
		local OptionList = Instance.new("ScrollingFrame")
		local Sonic = Instance.new("TextButton")
		local UICorner_4 = Instance.new("UICorner")
		local Gale = Instance.new("TextButton")
		local UICorner_5 = Instance.new("UICorner")
		local Among_Us = Instance.new("TextButton")
		local UICorner_6 = Instance.new("UICorner")
		local Killbot = Instance.new("TextButton")
		local UICorner_7 = Instance.new("UICorner")
		local NekoMaid = Instance.new("TextButton")
		local UICorner_8 = Instance.new("UICorner")
		local Smug = Instance.new("TextButton")
		local UICorner_9 = Instance.new("UICorner")
		local ShadowBlade = Instance.new("TextButton")
		local UICorner_10 = Instance.new("UICorner")
		local SwordStand = Instance.new("TextButton")
		local UICorner_11 = Instance.new("UICorner")
		local Neptunion = Instance.new("TextButton")
		local UICorner_12 = Instance.new("UICorner")
		local RbNeptunion = Instance.new("TextButton")
		local UICorner_13 = Instance.new("UICorner")
		local Wall = Instance.new("TextButton")
		local UICorner_14 = Instance.new("UICorner")
		local achroGlicher = Instance.new("TextButton")
		local UICorner_15 = Instance.new("UICorner")
		local FlamingCube = Instance.new("TextButton")
		local UICorner_16 = Instance.new("UICorner")
		local Spider = Instance.new("TextButton")
		local UICorner_17 = Instance.new("UICorner")
		local Cop = Instance.new("TextButton")
		local UICorner_18 = Instance.new("UICorner")
		local Chips = Instance.new("TextButton")
		local UICorner_19 = Instance.new("UICorner")
		local Joy = Instance.new("TextButton")
		local UICorner_20 = Instance.new("UICorner")
		local UMD = Instance.new("TextButton")
		local UICorner_21 = Instance.new("UICorner")
		local Chill = Instance.new("TextButton")
		local UICorner_22 = Instance.new("UICorner")
		local Grapple = Instance.new("TextButton")
		local UICorner_23 = Instance.new("UICorner")
		local ServerAdmin = Instance.new("TextButton")
		local UICorner_24 = Instance.new("UICorner")
		local Ender = Instance.new("TextButton")
		local UICorner_25 = Instance.new("UICorner")
		local Ban = Instance.new("TextButton")
		local UICorner_26 = Instance.new("UICorner")
		local Netless = Instance.new("TextButton")
		local UICorner_27 = Instance.new("UICorner")
		local Shadow = Instance.new("Frame")
		local UICorner_28 = Instance.new("UICorner")
		local TextLabel = Instance.new("TextLabel")
		local AntiReport = Instance.new("TextButton")
		local UICorner_29 = Instance.new("UICorner")
		local Shadow_2 = Instance.new("Frame")
		local UICorner_30 = Instance.new("UICorner")
		local TextLabel_2 = Instance.new("TextLabel")
		local X = Instance.new("TextButton")
		local UICorner_31 = Instance.new("UICorner")
		local OpenUTG = Instance.new("TextButton")

		--Properties:

		UTG_V2.Name = "UTG_V2"
		UTG_V2.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		UTG_V2.ResetOnSpawn = false

		Main.Name = "Main"
		Main.Parent = UTG_V2
		Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Main.BorderColor3 = Color3.fromRGB(27, 42, 53)
		Main.BorderSizePixel = 0
		Main.Position = UDim2.new(0.0592107326, 0, 0.0301492307, 0)
		Main.Size = UDim2.new(0, 451, 0, 534)

		UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(137, 0, 254)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(223, 0, 255))}
		UIGradient.Parent = Main

		UICorner.CornerRadius = UDim.new(0, 5)
		UICorner.Parent = Main

		Title.Name = "Title"
		Title.Parent = Main
		Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Title.BackgroundTransparency = 1.000
		Title.Position = UDim2.new(0.0711524412, 0, -0.00186577276, 0)
		Title.Size = UDim2.new(0, 385, 0, 54)
		Title.Font = Enum.Font.SourceSans
		Title.Text = "ULTIMATE TROLLING GUI V2"
		Title.TextColor3 = Color3.fromRGB(255, 255, 255)
		Title.TextScaled = true
		Title.TextSize = 38.000
		Title.TextWrapped = true

		SubTitile.Name = "SubTitile"
		SubTitile.Parent = Title
		SubTitile.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		SubTitile.BackgroundTransparency = 1.000
		SubTitile.Position = UDim2.new(-0.285957217, 0, 0.388888925, 0)
		SubTitile.Size = UDim2.new(0, 611, 0, 54)
		SubTitile.Font = Enum.Font.SourceSans
		SubTitile.Text = "FE UTG is back! And is now V2! Thx for using! :)"
		SubTitile.TextColor3 = Color3.fromRGB(255, 255, 255)
		SubTitile.TextSize = 20.000

		Welcome.Name = "Welcome"
		Welcome.Parent = Main
		Welcome.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Welcome.Position = UDim2.new(0.0505445786, 0, 0.114676468, 0)
		Welcome.Size = UDim2.new(0, 403, 0, 36)
		Welcome.Font = Enum.Font.SourceSansBold
		Welcome.Text = "Welcome to the brand new FE UTG! Made by Bulkez"
		Welcome.TextColor3 = Color3.fromRGB(0, 0, 0)
		Welcome.TextScaled = true
		Welcome.TextSize = 14.000
		Welcome.TextWrapped = true

		UICorner_2.Parent = Welcome

		Credits.Name = "Credits"
		Credits.Parent = Main
		Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Credits.Position = UDim2.new(0.0527422242, 0, 0.772552848, 0)
		Credits.Size = UDim2.new(0, 405, 0, 44)
		Credits.Font = Enum.Font.SourceSansBold
		Credits.Text = "Made by Blukez also credit to the original script creators also thx FO10 :)"
		Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
		Credits.TextScaled = true
		Credits.TextSize = 14.000
		Credits.TextWrapped = true

		UICorner_3.Parent = Credits

		OptionListFrame.Name = "OptionListFrame"
		OptionListFrame.Parent = Main
		OptionListFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		OptionListFrame.BackgroundTransparency = 1.000
		OptionListFrame.Position = UDim2.new(0.0279720332, 0, 0.191011235, 0)
		OptionListFrame.Size = UDim2.new(0, 403, 0, 711)

		OptionList.Name = "OptionList"
		OptionList.Parent = OptionListFrame
		OptionList.Active = true
		OptionList.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		OptionList.Position = UDim2.new(0.0351866931, 0, 0.00994348992, 0)
		OptionList.Size = UDim2.new(0, 402, 0, 296)

		Sonic.Name = "Sonic"
		Sonic.Parent = OptionList
		Sonic.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Sonic.Position = UDim2.new(0.0231197979, 0, 0.00696475245, 0)
		Sonic.Size = UDim2.new(0, 370, 0, 50)
		Sonic.Font = Enum.Font.SourceSans
		Sonic.Text = "Sonic"
		Sonic.TextColor3 = Color3.fromRGB(255, 255, 255)
		Sonic.TextScaled = true
		Sonic.TextSize = 14.000
		Sonic.TextWrapped = true

		UICorner_4.Parent = Sonic

		Gale.Name = "Gale"
		Gale.Parent = OptionList
		Gale.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Gale.Position = UDim2.new(0.0231197979, 0, 0.0506699458, 0)
		Gale.Size = UDim2.new(0, 370, 0, 50)
		Gale.Font = Enum.Font.SourceSans
		Gale.Text = "Gale"
		Gale.TextColor3 = Color3.fromRGB(255, 255, 255)
		Gale.TextScaled = true
		Gale.TextSize = 14.000
		Gale.TextWrapped = true

		UICorner_5.Parent = Gale

		Among_Us.Name = "Among_Us"
		Among_Us.Parent = OptionList
		Among_Us.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Among_Us.Position = UDim2.new(0.0231197979, 0, 0.092793569, 0)
		Among_Us.Size = UDim2.new(0, 370, 0, 50)
		Among_Us.Font = Enum.Font.SourceSans
		Among_Us.Text = "Among us"
		Among_Us.TextColor3 = Color3.fromRGB(255, 255, 255)
		Among_Us.TextScaled = true
		Among_Us.TextSize = 14.000
		Among_Us.TextWrapped = true

		UICorner_6.Parent = Among_Us

		Killbot.Name = "Killbot"
		Killbot.Parent = OptionList
		Killbot.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Killbot.Position = UDim2.new(0.0231197979, 0, 0.1349172, 0)
		Killbot.Size = UDim2.new(0, 370, 0, 50)
		Killbot.Font = Enum.Font.SourceSans
		Killbot.Text = "Killbot"
		Killbot.TextColor3 = Color3.fromRGB(255, 255, 255)
		Killbot.TextScaled = true
		Killbot.TextSize = 14.000
		Killbot.TextWrapped = true

		UICorner_7.Parent = Killbot

		NekoMaid.Name = "NekoMaid"
		NekoMaid.Parent = OptionList
		NekoMaid.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		NekoMaid.Position = UDim2.new(0.0231197979, 0, 0.177534401, 0)
		NekoMaid.Size = UDim2.new(0, 370, 0, 50)
		NekoMaid.Font = Enum.Font.SourceSans
		NekoMaid.Text = "Neko Maid"
		NekoMaid.TextColor3 = Color3.fromRGB(255, 255, 255)
		NekoMaid.TextScaled = true
		NekoMaid.TextSize = 14.000
		NekoMaid.TextWrapped = true

		UICorner_8.Parent = NekoMaid

		Smug.Name = "Smug"
		Smug.Parent = OptionList
		Smug.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Smug.Position = UDim2.new(0.0231197979, 0, 0.22079052, 0)
		Smug.Size = UDim2.new(0, 370, 0, 50)
		Smug.Font = Enum.Font.SourceSans
		Smug.Text = "Smug Dance V6"
		Smug.TextColor3 = Color3.fromRGB(255, 255, 255)
		Smug.TextScaled = true
		Smug.TextSize = 14.000
		Smug.TextWrapped = true

		UICorner_9.Parent = Smug

		ShadowBlade.Name = "ShadowBlade"
		ShadowBlade.Parent = OptionList
		ShadowBlade.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		ShadowBlade.Position = UDim2.new(0.0231197979, 0, 0.263522238, 0)
		ShadowBlade.Size = UDim2.new(0, 370, 0, 50)
		ShadowBlade.Font = Enum.Font.SourceSans
		ShadowBlade.Text = "Shadow Blade"
		ShadowBlade.TextColor3 = Color3.fromRGB(255, 255, 255)
		ShadowBlade.TextScaled = true
		ShadowBlade.TextSize = 14.000
		ShadowBlade.TextWrapped = true

		UICorner_10.Parent = ShadowBlade

		SwordStand.Name = "SwordStand"
		SwordStand.Parent = OptionList
		SwordStand.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		SwordStand.Position = UDim2.new(0.0231197979, 0, 0.304071069, 0)
		SwordStand.Size = UDim2.new(0, 370, 0, 50)
		SwordStand.Font = Enum.Font.SourceSans
		SwordStand.Text = "Sword Stand"
		SwordStand.TextColor3 = Color3.fromRGB(255, 255, 255)
		SwordStand.TextScaled = true
		SwordStand.TextSize = 14.000
		SwordStand.TextWrapped = true

		UICorner_11.Parent = SwordStand

		Neptunion.Name = "Neptunion"
		Neptunion.Parent = OptionList
		Neptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Neptunion.Position = UDim2.new(0.0231197979, 0, 0.347187638, 0)
		Neptunion.Size = UDim2.new(0, 370, 0, 50)
		Neptunion.Font = Enum.Font.SourceSans
		Neptunion.Text = "Neptunion V"
		Neptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
		Neptunion.TextScaled = true
		Neptunion.TextSize = 14.000
		Neptunion.TextWrapped = true

		UICorner_12.Parent = Neptunion

		RbNeptunion.Name = "RbNeptunion"
		RbNeptunion.Parent = OptionList
		RbNeptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		RbNeptunion.Position = UDim2.new(0.0231197979, 0, 0.390972137, 0)
		RbNeptunion.Size = UDim2.new(0, 370, 0, 50)
		RbNeptunion.Font = Enum.Font.SourceSans
		RbNeptunion.Text = "RB Neptunion"
		RbNeptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
		RbNeptunion.TextScaled = true
		RbNeptunion.TextSize = 14.000
		RbNeptunion.TextWrapped = true

		UICorner_13.Parent = RbNeptunion

		Wall.Name = "Wall"
		Wall.Parent = OptionList
		Wall.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Wall.Position = UDim2.new(0.0231197979, 0, 0.434192657, 0)
		Wall.Size = UDim2.new(0, 370, 0, 50)
		Wall.Font = Enum.Font.SourceSans
		Wall.Text = "Wall"
		Wall.TextColor3 = Color3.fromRGB(255, 255, 255)
		Wall.TextScaled = true
		Wall.TextSize = 14.000
		Wall.TextWrapped = true

		UICorner_14.Parent = Wall

		achroGlicher.Name = "achroGlicher"
		achroGlicher.Parent = OptionList
		achroGlicher.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		achroGlicher.Position = UDim2.new(0.0231197979, 0, 0.47801882, 0)
		achroGlicher.Size = UDim2.new(0, 370, 0, 50)
		achroGlicher.Font = Enum.Font.SourceSans
		achroGlicher.Text = "Achromatic Glicher"
		achroGlicher.TextColor3 = Color3.fromRGB(255, 255, 255)
		achroGlicher.TextScaled = true
		achroGlicher.TextSize = 14.000
		achroGlicher.TextWrapped = true

		UICorner_15.Parent = achroGlicher

		FlamingCube.Name = "FlamingCube"
		FlamingCube.Parent = OptionList
		FlamingCube.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		FlamingCube.Position = UDim2.new(0.0231197979, 0, 0.521497488, 0)
		FlamingCube.Size = UDim2.new(0, 370, 0, 50)
		FlamingCube.Font = Enum.Font.SourceSans
		FlamingCube.Text = "Flaming Cube"
		FlamingCube.TextColor3 = Color3.fromRGB(255, 255, 255)
		FlamingCube.TextScaled = true
		FlamingCube.TextSize = 14.000
		FlamingCube.TextWrapped = true

		UICorner_16.Parent = FlamingCube

		Spider.Name = "Spider"
		Spider.Parent = OptionList
		Spider.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Spider.Position = UDim2.new(0.0231197979, 0, 0.564180851, 0)
		Spider.Size = UDim2.new(0, 370, 0, 50)
		Spider.Font = Enum.Font.SourceSans
		Spider.Text = "Spider"
		Spider.TextColor3 = Color3.fromRGB(255, 255, 255)
		Spider.TextScaled = true
		Spider.TextSize = 14.000
		Spider.TextWrapped = true

		UICorner_17.Parent = Spider

		Cop.Name = "Cop"
		Cop.Parent = OptionList
		Cop.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Cop.Position = UDim2.new(0.0231197979, 0, 0.606966078, 0)
		Cop.Size = UDim2.new(0, 370, 0, 50)
		Cop.Font = Enum.Font.SourceSans
		Cop.Text = "Cop"
		Cop.TextColor3 = Color3.fromRGB(255, 255, 255)
		Cop.TextScaled = true
		Cop.TextSize = 14.000
		Cop.TextWrapped = true

		UICorner_18.Parent = Cop

		Chips.Name = "Chips"
		Chips.Parent = OptionList
		Chips.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Chips.Position = UDim2.new(0.0231197979, 0, 0.649766564, 0)
		Chips.Size = UDim2.new(0, 370, 0, 50)
		Chips.Font = Enum.Font.SourceSans
		Chips.Text = "Chips"
		Chips.TextColor3 = Color3.fromRGB(255, 255, 255)
		Chips.TextScaled = true
		Chips.TextSize = 14.000
		Chips.TextWrapped = true

		UICorner_19.Parent = Chips

		Joy.Name = "Joy"
		Joy.Parent = OptionList
		Joy.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Joy.Position = UDim2.new(0.0231197979, 0, 0.69195044, 0)
		Joy.Size = UDim2.new(0, 370, 0, 50)
		Joy.Font = Enum.Font.SourceSans
		Joy.Text = ":Joy:"
		Joy.TextColor3 = Color3.fromRGB(255, 255, 255)
		Joy.TextScaled = true
		Joy.TextSize = 14.000
		Joy.TextWrapped = true

		UICorner_20.Parent = Joy

		UMD.Name = "UMD"
		UMD.Parent = OptionList
		UMD.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		UMD.Position = UDim2.new(0.0231197979, 0, 0.732523978, 0)
		UMD.Size = UDim2.new(0, 370, 0, 50)
		UMD.Font = Enum.Font.SourceSans
		UMD.Text = "Ultimate meme dance"
		UMD.TextColor3 = Color3.fromRGB(255, 255, 255)
		UMD.TextScaled = true
		UMD.TextSize = 14.000
		UMD.TextWrapped = true

		UICorner_21.Parent = UMD

		Chill.Name = "Chill"
		Chill.Parent = OptionList
		Chill.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Chill.Position = UDim2.new(0.0231197979, 0, 0.772394419, 0)
		Chill.Size = UDim2.new(0, 370, 0, 50)
		Chill.Font = Enum.Font.SourceSans
		Chill.Text = "Chill"
		Chill.TextColor3 = Color3.fromRGB(255, 255, 255)
		Chill.TextScaled = true
		Chill.TextSize = 14.000
		Chill.TextWrapped = true

		UICorner_22.Parent = Chill

		Grapple.Name = "Grapple"
		Grapple.Parent = OptionList
		Grapple.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Grapple.Position = UDim2.new(0.0231197979, 0, 0.815179646, 0)
		Grapple.Size = UDim2.new(0, 370, 0, 50)
		Grapple.Font = Enum.Font.SourceSans
		Grapple.Text = "Grapple"
		Grapple.TextColor3 = Color3.fromRGB(255, 255, 255)
		Grapple.TextScaled = true
		Grapple.TextSize = 14.000
		Grapple.TextWrapped = true

		UICorner_23.Parent = Grapple

		ServerAdmin.Name = "ServerAdmin"
		ServerAdmin.Parent = OptionList
		ServerAdmin.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		ServerAdmin.Position = UDim2.new(0.0231197979, 0, 0.858780205, 0)
		ServerAdmin.Size = UDim2.new(0, 370, 0, 50)
		ServerAdmin.Font = Enum.Font.SourceSans
		ServerAdmin.Text = "Server Admin"
		ServerAdmin.TextColor3 = Color3.fromRGB(255, 255, 255)
		ServerAdmin.TextScaled = true
		ServerAdmin.TextSize = 14.000
		ServerAdmin.TextWrapped = true

		UICorner_24.Parent = ServerAdmin

		Ender.Name = "Ender"
		Ender.Parent = OptionList
		Ender.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Ender.Position = UDim2.new(0.0231197979, 0, 0.902380705, 0)
		Ender.Size = UDim2.new(0, 370, 0, 50)
		Ender.Font = Enum.Font.SourceSans
		Ender.Text = "Ender"
		Ender.TextColor3 = Color3.fromRGB(255, 255, 255)
		Ender.TextScaled = true
		Ender.TextSize = 14.000
		Ender.TextWrapped = true

		UICorner_25.Parent = Ender

		Ban.Name = "Ban"
		Ban.Parent = OptionList
		Ban.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Ban.Position = UDim2.new(0.0231197979, 0, 0.945981264, 0)
		Ban.Size = UDim2.new(0, 370, 0, 50)
		Ban.Font = Enum.Font.SourceSans
		Ban.Text = "Ban Hammer"
		Ban.TextColor3 = Color3.fromRGB(255, 255, 255)
		Ban.TextScaled = true
		Ban.TextSize = 14.000
		Ban.TextWrapped = true

		UICorner_26.Parent = Ban

		Netless.Name = "Netless"
		Netless.Parent = Main
		Netless.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
		Netless.BorderSizePixel = 0
		Netless.Position = UDim2.new(0.51807934, 0, 0.868913829, 0)
		Netless.Size = UDim2.new(0, 195, 0, 57)
		Netless.ZIndex = 2
		Netless.Font = Enum.Font.GothamSemibold
		Netless.Text = ""
		Netless.TextColor3 = Color3.fromRGB(255, 255, 255)
		Netless.TextScaled = true
		Netless.TextSize = 14.000
		Netless.TextWrapped = true

		UICorner_27.Parent = Netless

		Shadow.Name = "Shadow"
		Shadow.Parent = Netless
		Shadow.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
		Shadow.BorderSizePixel = 0
		Shadow.Size = UDim2.new(1, 0, 1, 4)

		UICorner_28.Parent = Shadow

		TextLabel.Parent = Netless
		TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1.000
		TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
		TextLabel.BorderSizePixel = 0
		TextLabel.Position = UDim2.new(0.5, 0, 0.49999997, 0)
		TextLabel.Size = UDim2.new(1, -20, 1, -20)
		TextLabel.ZIndex = 2
		TextLabel.Font = Enum.Font.GothamSemibold
		TextLabel.Text = "Netless (Use AFTER any scripts)"
		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.TextScaled = true
		TextLabel.TextSize = 14.000
		TextLabel.TextWrapped = true

		AntiReport.Name = "AntiReport"
		AntiReport.Parent = Main
		AntiReport.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
		AntiReport.BorderSizePixel = 0
		AntiReport.Position = UDim2.new(0.0489794947, 0, 0.868913829, 0)
		AntiReport.Size = UDim2.new(0, 197, 0, 57)
		AntiReport.ZIndex = 2
		AntiReport.Font = Enum.Font.GothamSemibold
		AntiReport.Text = ""
		AntiReport.TextColor3 = Color3.fromRGB(255, 255, 255)
		AntiReport.TextScaled = true
		AntiReport.TextSize = 14.000
		AntiReport.TextWrapped = true

		UICorner_29.Parent = AntiReport

		Shadow_2.Name = "Shadow"
		Shadow_2.Parent = AntiReport
		Shadow_2.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
		Shadow_2.BorderSizePixel = 0
		Shadow_2.Size = UDim2.new(1, 0, 1, 4)

		UICorner_30.Parent = Shadow_2

		TextLabel_2.Parent = AntiReport
		TextLabel_2.AnchorPoint = Vector2.new(0.5, 0.5)
		TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel_2.BackgroundTransparency = 1.000
		TextLabel_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
		TextLabel_2.BorderSizePixel = 0
		TextLabel_2.Position = UDim2.new(0.5, 0, 0.5, 0)
		TextLabel_2.Size = UDim2.new(1, -20, 1, -20)
		TextLabel_2.ZIndex = 2
		TextLabel_2.Font = Enum.Font.GothamSemibold
		TextLabel_2.Text = "AntiReport"
		TextLabel_2.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel_2.TextScaled = true
		TextLabel_2.TextSize = 14.000
		TextLabel_2.TextWrapped = true

		X.Name = "X"
		X.Parent = Main
		X.BackgroundColor3 = Color3.fromRGB(251, 98, 92)
		X.BorderSizePixel = 0
		X.Position = UDim2.new(0.927937925, 0, -0.0262172297, 0)
		X.Size = UDim2.new(0, 47, 0, 45)
		X.ZIndex = 2
		X.Font = Enum.Font.GothamSemibold
		X.Text = "X"
		X.TextColor3 = Color3.fromRGB(255, 255, 255)
		X.TextSize = 32.000
		X.TextWrapped = true

		UICorner_31.CornerRadius = UDim.new(1, 0)
		UICorner_31.Parent = X

		OpenUTG.Name = "OpenUTG"
		OpenUTG.Parent = UTG_V2
		OpenUTG.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		OpenUTG.BackgroundTransparency = 1.000
		OpenUTG.Position = UDim2.new(0.79603678, 0, 0.698529005, 0)
		OpenUTG.Size = UDim2.new(0, 165, 0, 62)
		OpenUTG.Visible = false
		OpenUTG.Font = Enum.Font.SourceSans
		OpenUTG.Text = "Open UTG"
		OpenUTG.TextColor3 = Color3.fromRGB(255, 255, 255)
		OpenUTG.TextScaled = true
		OpenUTG.TextSize = 14.000
		OpenUTG.TextWrapped = true

		-- Scripts:

		local function MBUQEV_fake_script() -- Main.DraggableScript 
			local script = Instance.new('LocalScript', Main)

			local UIS = game:GetService('UserInputService')
			local frame = script.Parent
			local dragToggle = nil
			local dragSpeed = 0.25
			local dragStart = nil
			local startPos = nil

			local function updateInput(input)
				local delta = input.Position - dragStart
				local position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
					startPos.Y.Scale, startPos.Y.Offset + delta.Y)
				game:GetService('TweenService'):Create(frame, TweenInfo.new(dragSpeed), {Position = position}):Play()
			end

			frame.InputBegan:Connect(function(input)
				if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then 
					dragToggle = true
					dragStart = input.Position
					startPos = frame.Position
					input.Changed:Connect(function()
						if input.UserInputState == Enum.UserInputState.End then
							dragToggle = false
						end
					end)
				end
			end)

			UIS.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					if dragToggle then
						updateInput(input)
					end
				end
			end)

		end
		coroutine.wrap(MBUQEV_fake_script)()
		local function NWAVVF_fake_script() -- Netless.NetlessScript 
			local script = Instance.new('LocalScript', Netless)

			script.Parent.MouseButton1Click:Connect(function()
				for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
					if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
						game:GetService("RunService").Heartbeat:connect(function()
							v.Velocity = Vector3.new(0,35,0)
							wait(0.5)
						end)
					end
				end

				game:GetService("StarterGui"):SetCore("SendNotification", { 
					Title = "Notification";
					Text = "Netless activated";
					Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
				Duration = 16;
			end)
		end
		coroutine.wrap(NWAVVF_fake_script)()
		local function WSBO_fake_script() -- X.CloseUTGScript 
			local script = Instance.new('LocalScript', X)

			script.Parent.MouseButton1Click:Connect(function()
				script.Parent.Parent.Parent.Main.Visible = false
				script.Parent.Parent.Parent.OpenUTG.Visible = true
			end)
		end
		coroutine.wrap(WSBO_fake_script)()
		local function KZZCO_fake_script() -- OpenUTG.OpenUTGScript 
			local script = Instance.new('LocalScript', OpenUTG)

			script.Parent.MouseButton1Click:Connect(function()
				script.Parent.Parent.Main.Visible = true
				script.Parent.Visible = false
			end)
		end
		coroutine.wrap(KZZCO_fake_script)()

		AntiReport.MouseButton1Click:Connect(function()
			setfflag("AbuseReportScreenshotPercentage", 0)
			setfflag("DFFlagAbuseReportScreenshot", "False")
			print("Anti-Report loaded")
		end)

		Among_Us.MouseButton1Click:Connect(function()
			loadstring(game:HttpGet("https://pastebin.com/raw/JXUMavf3", true))()
		end)

		Ban.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/killermaster9999mega/thing/main/README.md"))()
		end)

		Chill.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/XmHFdTij"))()
		end)

		Chips.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/b289ts36"))()
		end)

		Cop.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/VAA5Mf60"))()
		end)

		Ender.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/bndCgupK"))()
		end)

		FlamingCube.MouseButton1Click:Connect(function()
			loadstring(game:HttpGet("https://pastebin.com/raw/D7pigANg"))()
		end)

		Gale.MouseButton1Click:Connect(function()
			loadstring(game:HttpGet(("https://pastebin.com/raw/PjJNLaFa"), true))()
		end)

		Grapple.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/AyASkDEG"))()
		end)

		Joy.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
		end)

		Killbot.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/G24tcRXA"))()
		end)

		NekoMaid.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://paste.ee/d/6bCwm/0"))()
		end)

		Neptunion.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/t0Mkc33N"))()
		end)

		RbNeptunion.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/gDi503fB"))()
		end)

		ServerAdmin.MouseButton1Click:Connect(function()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
		end)

		ShadowBlade.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/kMYThpNG"))()
		end)

		Smug.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/ZuKy7HFF"))()
		end)

		Sonic.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/SyF5t70A"))()
		end)

		Spider.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/txsk1LJg"))()
		end)

		SwordStand.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://paste.ee/r/NwGVX/0"))()
		end)

		UMD.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/0QfjMKrF"))()
		end)

		Wall.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/AY6kA2AV"))()
		end)

		achroGlicher.MouseButton1Click:Connect(function()
			loadstring(game:HttpGetAsync("https://pastebin.com/raw/T7cmny7C"))()
		end)
	end)
end
coroutine.wrap(UALQUS_fake_script)()
local function CHNP_fake_script() -- UtgV1.LocalScript 
	local script = Instance.new('LocalScript', UtgV1)

	UtgV1.MouseButton1Down:connect(function()
		-- Gui to Lua
		-- Version: 3.2

		-- Instances:

		local ScreenGui = Instance.new("ScreenGui")
		local Frame = Instance.new("Frame")
		local Name = Instance.new("TextLabel")
		local Credits = Instance.new("TextLabel")
		local Note = Instance.new("TextLabel")
		local TextLabel = Instance.new("TextLabel")
		local ACTIVATE = Instance.new("TextButton")
		local arrow_forward = Instance.new("ImageButton")
		local arrow_back = Instance.new("ImageButton")

		--Properties:

		ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

		Frame.Parent = ScreenGui
		Frame.BackgroundColor3 = Color3.fromRGB(55, 75, 255)
		Frame.Position = UDim2.new(0.333580971, 0, 0.183551848, 0)
		Frame.Size = UDim2.new(0, 448, 0, 531)

		Name.Name = "Name"
		Name.Parent = Frame
		Name.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Name.Size = UDim2.new(0, 448, 0, 74)
		Name.Font = Enum.Font.SourceSans
		Name.Text = "FE UTG"
		Name.TextColor3 = Color3.fromRGB(0, 0, 0)
		Name.TextScaled = true
		Name.TextSize = 14.000
		Name.TextWrapped = true

		Credits.Name = "Credits"
		Credits.Parent = Frame
		Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Credits.Position = UDim2.new(0, 0, 0.138282403, 0)
		Credits.Size = UDim2.new(0, 448, 0, 57)
		Credits.Font = Enum.Font.SourceSans
		Credits.Text = "Made By KillerMaster"
		Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
		Credits.TextScaled = true
		Credits.TextSize = 14.000
		Credits.TextWrapped = true

		Note.Name = "Note"
		Note.Parent = Frame
		Note.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Note.Position = UDim2.new(0, 0, 0.905838013, 0)
		Note.Size = UDim2.new(0, 448, 0, 50)
		Note.Font = Enum.Font.SourceSans
		Note.Text = "Note: Please reset to close this ui once ur done reading"
		Note.TextColor3 = Color3.fromRGB(0, 0, 0)
		Note.TextScaled = true
		Note.TextSize = 14.000
		Note.TextWrapped = true

		TextLabel.Parent = Frame
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.Position = UDim2.new(0, 0, 0.244821087, 0)
		TextLabel.Size = UDim2.new(0, 448, 0, 285)
		TextLabel.Font = Enum.Font.SourceSans
		TextLabel.Text = "NOTE: GUI Not Draggable!"
		TextLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
		TextLabel.TextScaled = true
		TextLabel.TextSize = 14.000
		TextLabel.TextWrapped = true

		ACTIVATE.Name = "ACTIVATE"
		ACTIVATE.Parent = Frame
		ACTIVATE.BackgroundColor3 = Color3.fromRGB(40, 255, 16)
		ACTIVATE.Position = UDim2.new(0.265625, 0, 0.781544268, 0)
		ACTIVATE.Size = UDim2.new(0, 205, 0, 66)
		ACTIVATE.Font = Enum.Font.SciFi
		ACTIVATE.Text = "ACITVATE UTG"
		ACTIVATE.TextColor3 = Color3.fromRGB(0, 0, 0)
		ACTIVATE.TextScaled = true
		ACTIVATE.TextSize = 14.000
		ACTIVATE.TextWrapped = true
		ACTIVATE.MouseButton1Down:connect(function()
			game.Players.LocalPlayer.Character.Humanoid.Health = 0
			loadstring(game:HttpGet("https://pastebin.com/raw/r3Y3PCaz",true))()
		end)

		arrow_forward.Name = "arrow_forward"
		arrow_forward.Parent = Frame
		arrow_forward.BackgroundTransparency = 1.000
		arrow_forward.Position = UDim2.new(-0.00124046206, 0, 0.781766474, 0)
		arrow_forward.Size = UDim2.new(0, 119, 0, 65)
		arrow_forward.ZIndex = 2
		arrow_forward.Image = "rbxassetid://3926307971"
		arrow_forward.ImageRectOffset = Vector2.new(564, 284)
		arrow_forward.ImageRectSize = Vector2.new(36, 36)

		arrow_back.Name = "arrow_back"
		arrow_back.Parent = arrow_forward
		arrow_back.BackgroundTransparency = 1.000
		arrow_back.Position = UDim2.new(2.72268915, 0, 0, 0)
		arrow_back.Size = UDim2.new(0, 123, 0, 65)
		arrow_back.ZIndex = 2
		arrow_back.Image = "rbxassetid://3926307971"
		arrow_back.ImageRectOffset = Vector2.new(124, 324)
		arrow_back.ImageRectSize = Vector2.new(36, 36)
	end)
end
coroutine.wrap(CHNP_fake_script)()
local function QZSOM_fake_script() -- UtgReborn.LocalScript 
	local script = Instance.new('LocalScript', UtgReborn)

	UtgReborn.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/o5u3/utgrebirth/stuff/script", true))()
	end)
end
coroutine.wrap(QZSOM_fake_script)()
local function TEKEYAQ_fake_script() -- Linorix.LocalScript 
	local script = Instance.new('LocalScript', Linorix)

	Linorix.MouseButton1Down:connect(function()
		loadstring(game:HttpGet(('https://pastebin.com/raw/KumP53dH'),true))()
	end)
end
coroutine.wrap(TEKEYAQ_fake_script)()
local function GIFQ_fake_script() -- Page_4.LocalScript 
	local script = Instance.new('LocalScript', Page_4)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page3"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(-1,0,.3,0)
		currpage:TweenPosition(UDim2.new(1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(GIFQ_fake_script)()
local function FBMBQLM_fake_script() -- Page_5.LocalScript 
	local script = Instance.new('LocalScript', Page_5)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page5"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(FBMBQLM_fake_script)()
local function TCBQEK_fake_script() -- UltraClickers4.LocalScript 
	local script = Instance.new('LocalScript', UltraClickers4)

	UltraClickers4.MouseButton1Down:connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/GhoulScriptsRoblox/Ghoul-Hub---Ultra-Clickers-4/main/GhoulHub"))()
	end)
end
coroutine.wrap(TCBQEK_fake_script)()
local function AOKZI_fake_script() -- Page_6.LocalScript 
	local script = Instance.new('LocalScript', Page_6)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page4"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(-1,0,.3,0)
		currpage:TweenPosition(UDim2.new(1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(AOKZI_fake_script)()
local function EMRMLTU_fake_script() -- Page_7.LocalScript 
	local script = Instance.new('LocalScript', Page_7)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page2"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(-1,0,.3,0)
		currpage:TweenPosition(UDim2.new(1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(EMRMLTU_fake_script)()
local function ZTVGMOF_fake_script() -- Page_8.LocalScript 
	local script = Instance.new('LocalScript', Page_8)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page4"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(ZTVGMOF_fake_script)()
local function XLGLTRH_fake_script() -- Close.LocalScript 
	local script = Instance.new('LocalScript', Close)

	script.Parent.MouseButton1Click:connect(function()
		script.Parent.Parent.Visible = false
		script.Parent.Parent.Parent.TextButton.Visible = true
	end)
end
coroutine.wrap(XLGLTRH_fake_script)()
local function SHIORPK_fake_script() -- Netless.LocalScript 
	local script = Instance.new('LocalScript', Netless)

	Netless.MouseButton1Down:connect(function()
		loadstring(game:HttpGet(('https://pastebin.com/raw/Cu7bKQWN'),true))()
	end)
end
coroutine.wrap(SHIORPK_fake_script)()
local function LZNT_fake_script() -- Respawn.LocalScript 
	local script = Instance.new('LocalScript', Respawn)

	function respawn()
		local char = game.Players.LocalPlayer.Character
		if char:FindFirstChildOfClass("Humanoid") then char:FindFirstChildOfClass("Humanoid"):ChangeState(15) end
		char:ClearAllChildren()
		local newChar = Instance.new("Model")
		newChar.Parent = workspace
		game.Players.LocalPlayer.Character = newChar
		wait()
		game.Players.LocalPlayer.Character = char
		newChar:Destroy()
	end
	
	script.Parent.MouseButton1Click:Connect(function()
		respawn()
	end)
end
coroutine.wrap(LZNT_fake_script)()
local function SQDAEJP_fake_script() -- AntiFling.LocalScript 
	local script = Instance.new('LocalScript', AntiFling)

	script.Parent.MouseButton1Click:Connect(function()
		local Services = setmetatable({}, {__index = function(Self, Index)
			local NewService = game.GetService(game, Index)
			if NewService then
				Self[Index] = NewService
			end
			return NewService
		end})
	
		-- [ LocalPlayer ] --
		local LocalPlayer = Services.Players.LocalPlayer
	
		-- // Functions \\ --
		local function PlayerAdded(Player)
			local Detected = false
			local Character;
			local PrimaryPart;
	
			local function CharacterAdded(NewCharacter)
				Character = NewCharacter
				repeat
					wait()
					PrimaryPart = NewCharacter:FindFirstChild("HumanoidRootPart")
				until PrimaryPart
				Detected = false
			end
	
			CharacterAdded(Player.Character or Player.CharacterAdded:Wait())
			Player.CharacterAdded:Connect(CharacterAdded)
			Services.RunService.Heartbeat:Connect(function()
				if (Character and Character:IsDescendantOf(workspace)) and (PrimaryPart and PrimaryPart:IsDescendantOf(Character)) then
					if PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 or PrimaryPart.AssemblyLinearVelocity.Magnitude > 100 then
						if Detected == false then
							game.StarterGui:SetCore("ChatMakeSystemMessage", {
								Text = "Fling Exploit detected, Player: " .. tostring(Player);
								Color = Color3.fromRGB(255, 200, 0);
							})
						end
						Detected = true
						for i,v in ipairs(Character:GetDescendants()) do
							if v:IsA("BasePart") then
								v.CanCollide = false
								v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
								v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
								v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
							end
						end
						PrimaryPart.CanCollide = false
						PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
						PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
						PrimaryPart.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
					end
				end
			end)
		end
	
		-- // Event Listeners \\ --
		for i,v in ipairs(Services.Players:GetPlayers()) do
			if v ~= LocalPlayer then
				PlayerAdded(v)
			end
		end
		Services.Players.PlayerAdded:Connect(PlayerAdded)
	
		local LastPosition = nil
		Services.RunService.Heartbeat:Connect(function()
			pcall(function()
				local PrimaryPart = LocalPlayer.Character.PrimaryPart
				if PrimaryPart.AssemblyLinearVelocity.Magnitude > 250 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 250 then
					PrimaryPart.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
					PrimaryPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
					PrimaryPart.CFrame = LastPosition
	
					game.StarterGui:SetCore("ChatMakeSystemMessage", {
						Text = "You were flung. Neutralizing velocity.";
						Color = Color3.fromRGB(255, 0, 0);
					})
				elseif PrimaryPart.AssemblyLinearVelocity.Magnitude < 50 or PrimaryPart.AssemblyAngularVelocity.Magnitude > 50 then
					LastPosition = PrimaryPart.CFrame
				end
			end)
		end)
	end)
	end
coroutine.wrap(SQDAEJP_fake_script)()
local function NXJMNU_fake_script() -- ScreenGui.Draggable 
	local script = Instance.new('LocalScript', ScreenGui)

	frame = script.Parent.Main
	frame.Draggable = true
	frame.Active = true
	frame.Selectable = true
end
coroutine.wrap(NXJMNU_fake_script)()
t3 = Joint1
				joint3.C1 = CFrame.new(0,1,0)
				if side == -math.pi/2 then
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.38,-0.3), Vector3.new(0,math.pi/2,0.14))
				else
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.5,-0.8,-0.2), Vector3.new(0,math.pi/2,0.2))
				end

				local joint4 = Joint2
				joint4.C1 = CFrame.new(0,1,0)
				if side == -math.pi/2 then
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.8,-0.2), Vector3.new(0,0,0.2))
				else
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.5,-0.38,-0.3), Vector3.new(0,0,0.14))
				end

				local joint5 = Joint5
				SetWeld(joint5,1,1,NV,NV,Vector3.new(0,0.9,0),Vector3.new(0,0,side/7))

				Torsoz.CFrame = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)
				bg.cframe = CFrame.new(pos+(towall*-2), pos) * CFrame.Angles(0,-side,-side/2.2)

				local aniangle = 0
				local aniplus = true
				local aniangle2 = 0
				local aniplus2 = true

				local prevpart = part
				HWRLastPart = part
				while HWallRunning == true do

					if aniangle > math.pi then
						aniplus = false
					elseif aniangle < -math.pi then
						aniplus = true  
					end
					if aniplus == true then
						aniangle = aniangle + 0.95
					elseif aniplus == false then
						aniangle = aniangle - 0.95
					end

					if aniangle2 > math.pi then
						aniplus2 = false
					elseif aniangle2 < -math.pi then
						aniplus2 = true  
					end
					if aniplus2 == true then
						aniangle2 = aniangle2 + 0.23
					elseif aniplus2 == false then
						aniangle2 = aniangle2 - 0.23
					end

					Hu.PlatformStand = true
					local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3,0))
					local hitz2, enz2 = RAY(Torsoz.Position, towall*3.4)

					--- if player ends wall run on ground
					if hitz ~= nil and hitz.CanCollide == true then
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
						local offset = (bg.cframe.p.y+enz2.y) - bg.cframe.p.y
						Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
						Torsoz.Velocity = NV
						break
					end

					---- if new wall found --------
					if hitz2 ~= nil and hitz2.CanCollide == true then
						if hitz2 ~= prevpart then
							local direct = CFrame.new(Torsoz.Position, Torsoz.Position+dir) * CFrame.Angles(0,side,0)
							local hitz3, enz3 = RAY(Torsoz.Position, (direct * CFrame.Angles(0,-side/2.3,0)).lookVector*4)
							if hitz3 ~= nil then
								Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
								bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side*1.1,-side/2.2)
								dir, dirc = FindSurface(hitz2, enz2)
								towall = -dir
								dir = (CFrame.new(NV, dir) * CFrame.Angles(0,side,0)).lookVector
								prevpart = hitz2
								HWRLastPart = hitz2
							else
								---- if player fails to find new wall to run on
								Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
								bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
								Torsoz.Velocity = NV
								HWRCooldown = 5
								break
							end
						end
						--- continue to wall run
						Torsoz.CFrame = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,-side/2.2)
					else
						---- if player ends wall run at end of wall
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						Torsoz.Velocity = NV
						HWRCooldown = 5
						break
					end

					local hitz3, enz3 = RAY(Torsoz.Position, Torsoz.CFrame.lookVector*2)
					if hitz3 ~= nil and hitz3.CanCollide == true then
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						bg.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+dir)
						Torsoz.Velocity = NV
						HWRCooldown = 5
						break
					end

					bv.Parent = Torsoz
					bv.velocity = (dir*(sprint-0.5)) + Vector3.new(0,GravPoint,0)
					bg.cframe = bg.cframe * CFrame.Angles(aniangle/80,aniangle/80,0)
					Torsoz.CFrame = Torsoz.CFrame * CFrame.Angles(aniangle/80,aniangle/80,0)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					SetWeld(joint3,1,1, j3,j3a, j3,Vector3.new(-0.2+(aniangle/4),0,0))
					SetWeld(joint4,1,1, j4,j4a, j4,Vector3.new(-0.2+(-aniangle/4),0,0))
					if side == math.pi/2 then
						local j1,j1a = GetWeld(joint1)
						SetWeld(joint1,1,1, j1,j1a, j1, Vector3.new(0,0,0.8+(aniangle2/14)))
					else
						local j2,j2a = GetWeld(joint2)
						SetWeld(joint2,1,1, j2,j2a, j2, Vector3.new(0,0,-0.8-(aniangle2/14)))
					end

					wait(0.025)
					if GravPoint < -100 then
						bg.cframe = CFrame.new(enz2+(towall*-2), enz2) * CFrame.Angles(0,-side,0)
						local offset = math.abs((bg.cframe.p.y+enz2.y) - bg.cframe.p.y)
						Torsoz.CFrame = CFrame.new(Vector3.new(bg.cframe.p.x,offset,bg.cframe.p.z), enz2) * CFrame.Angles(0,-side,0)
						break
					end

				end

				if HWallRunning == "Jumping" then
					HWRCooldown = 6
					joint1.C1 = CFrame.new(0,0.5,0)

					joint2.C1 = CFrame.new(0,0.5,0)
					if side == -math.pi/2 then
						joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/3)
					else
						joint2.C0 = CFrame.new(-1.35,0.5,0) * CFrame.Angles(0,side/2.4,-math.pi/4)
					end

					joint3.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),-math.pi/4)
					else
						joint3.C0 = CFrame.new(0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),math.pi/4)
					end
					joint4.MaxVelocity = 10
					joint4.DesiredAngle = 0
					joint4.C1 = CFrame.new(0,1,0)
					if side == -math.pi/2 then
						joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,math.pi+(side/2.4),math.pi/4)
					else
						joint4.C0 = CFrame.new(-0.5,-0.8,0) * CFrame.Angles(0,(side/2.4),-math.pi/4)
					end

					local joint5 = Joint5
					joint5.C1 = CFrame.new(0,-0.5,0) * CFrame.Angles(0,side/2.4,0)
					joint5.C0 = CFrame.new(0,1,0)

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					GravPoint = 26
					local collidecount = 0
					local bgangle = side/2
					local count = 1
					local dir2 = (CFrame.new(NV, dir) * CFrame.Angles(0,-side/2.4,0)).lookVector
					HWRDir = dir2
					bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
					while HWallRunning == "Jumping" do
						local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-4,0))
						local hitz2, enz2 = RAY(Torsoz.Position, dir2*1.4)
						if hitz ~= nil and hitz.CanCollide == true then
							local offset = math.abs(enz.y - Torsoz.CFrame.p.y)
							Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2.9,0), enz+Vector3.new(0,2.9,0)+dir2)
							Torsoz.Velocity = NV
							break
						end

						if hitz2 ~= nil and hitz2.CanCollide == true then
							collidecount = collidecount + 1
							if collidecount == 4 then
								Torsoz.CFrame = CFrame.new(Torsoz.Position, Torsoz.Position+dir2) * CFrame.new(0,0,0.4)
								Torsoz.Velocity = Vector3.new(0,Torsoz.Velocity.y,0)
								HWRCooldown = 5
								VWRCooldown = 5
								wait(0.02)
								break
							end
						end

						if side/2 > 0 then
							if bgangle > 0.2 then
								bgangle = bgangle - 0.055
							end
						else
							if bgangle < -0.2 then
								bgangle = bgangle + 0.055
							end
						end

						if count <= 5 then
							if side == -math.pi/2 then
								SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/4))
								SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/3))
								SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint3.C0 = joint3.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
								SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint4.C0 = joint4.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
							else
								SetWeld(joint1,count,5, j1,j1a, Vector3.new(1.35,0.5,0), Vector3.new(0,side/2.4,math.pi/3))
								SetWeld(joint2,count,5, j2,j2a, Vector3.new(-1.35,0.5,0), Vector3.new(0,side/2.4,-math.pi/4))
								SetWeld(joint3,count,5, j3,j3a, Vector3.new(0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint3.C0 = joint3.C0 * CFrame.Angles((math.pi/4)/5*count,0,0)
								SetWeld(joint4,count,5, j4,j4a, Vector3.new(-0.5,-0.8,0), Vector3.new(0,-side/1.7,0))
								joint4.C0 = joint4.C0 * CFrame.Angles((-math.pi/4)/5*count,0,0)
							end

							count = count + 1
						end

						bg.Parent = Torsoz
						bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(0,side/15,-bgangle)
						bv.velocity = (dir2*(sprint+5)) + Vector3.new(0,GravPoint,0)
						if collidecount ~= 0 then
							bv.velocity = Vector3.new(0,bv.velocity.y,0)
						end
						if GravPoint < -120 then
							break
						end
						wait(0.025)
					end
				end

				Hu.PlatformStand = false
				bv:remove()

				HWRGravDrop = false
				Stand()
				HWallRunning = false
			end
		end

		function VWR(part, pos)
			if (part.className == "Part" and part.Shape == Enum.PartType.Block) or part.className ~= "Part" then
				print("VWR Activated")
				flow.Value = flow.Value + 9
				Standing = false
				VWallRunning = true
				Action = "VWallRunning"
				GravPoint = 0
				local percent = 1
				VWRLastPart = part
				local dir, dirc = FindSurface(part, pos)
				towall = -dir
				dir = (CFrame.new(NV, -dir) * CFrame.Angles(math.pi/2,0,0)).lookVector
--[[
local p = P:Clone()
p.Parent = char
p.Size = Vector3.new(2,2,2)
p.BrickColor = BrickColor.new("Lime green")
p.CanCollide = false
p.CFrame = part.CFrame * CFrame.new(dirc*5)
p.Transparency = 0.3
]]
				local bv = Instance.new("BodyVelocity", Torsoz)
				bv.Name = "StaminaBodyObject"
				bv.maxForce = Vector3.new(1/0,1/0,1/0)
				bv.P = 9000
				bv.velocity = (dir*(sprint-1))*percent

				local bg = Instance.new("BodyGyro", Torsoz)
				bg.Name = "StaminaBodyObject"
				bg.maxTorque = Vector3.new(1/0,1/0,1/0)
				bg.D = 100
				local posi = pos + (-towall*1.8)
				bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)
				Torsoz.CFrame = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0)

				local joint1 = Joint3
				SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,math.pi/8))

				local joint2 = Joint4
				SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,0,-math.pi/8))

				local joint3 = Joint1
				SetWeld(joint3,1,1, NV,NV, Vector3.new(0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
				joint3.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

				local joint4 = Joint2
				SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.48,-0.6,-0.1), Vector3.new(0,math.pi/2,0))
				joint4.C1 = CFrame.new(0,0.7,0.2) * CFrame.Angles(0,math.pi/2,0)

				local joint5 = Joint5
				SetWeld(joint5,1,1, NV,NV, Vector3.new(0,1,0), Vector3.new(math.pi/20,0,0))

				local aniangle = 0
				local aniplus = true

				while VWallRunning == true do
					local hitz, enz = RAY(Torsoz.Position, towall*2.1)
					local hitz2, enz2 = RAY(Torsoz.Position, (CFrame.new(NV,towall)*CFrame.Angles(math.pi/2,0,0)).lookVector*2.4)

					if aniangle > math.pi then
						aniplus = false
					elseif aniangle < -math.pi then
						aniplus = true  
					end
					if aniplus == true then
						aniangle = aniangle + (1.3*(percent+0.2))
					elseif aniplus == false then
						aniangle = aniangle - (1.3*(percent+0.2))
					end

					bv.velocity = (dir*(sprint-1))*percent
					if VWRLeft == true then
						bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
					end
					if VWRRight == true then
						bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * (11*percent+5))
					end

					bg.cframe = CFrame.new(posi, posi+towall) * CFrame.Angles((math.pi/5),0,0) * CFrame.Angles(0,aniangle/60,0)

					SetWeld(joint1,1,1, NV,NV, Vector3.new(1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(math.pi/8)+(aniangle/30)))
					SetWeld(joint2,1,1, NV,NV, Vector3.new(-1.4,0.45,-0.1), Vector3.new(-math.pi/3.2,aniangle/52,(-math.pi/8)+(-aniangle/30)))
					SetWeld(joint3,1,1, NV,NV, Vector3.new(0.51,-0.75,-(aniangle/30)), Vector3.new(0,math.pi/2,(aniangle/8)-0.3))
					SetWeld(joint4,1,1, NV,NV, Vector3.new(-0.51,-0.75,(aniangle/30)), Vector3.new(0,math.pi/2,(-aniangle/8)-0.3))

					if hitz == nil then
						local lv = Torsoz.Position + (Torsoz.CFrame.lookVector*100)
						Torsoz.CFrame = CFrame.new(Torsoz.Position, Vector3.new(lv.x,Torsoz.Position.y,lv.z))
						break
					end

					if hitz2 ~= nil then
						percent = 0
						VWallRunning = "Falling"
						Action = "VWRFalling"
						GravPoint = -7
						break
					end

					wait(0.02)
					percent = percent - 0.028
					if percent <= 0.15 then
						VWallRunning = "Falling"
						Action = "VWRFalling"
					end
				end

				-------------------------- Falling from VWR ------------------------------
				if VWallRunning == "Falling" then
					GravPoint = GravPoint - 1
					local dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
					bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					local counter = 0
					while VWallRunning == "Falling" do
						counter = counter + 1
						local hitz, enz = RAY(H.Position, Vector3.new(0,-2.4,0))

						dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
						bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
						if VWRLeft == true then
							bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						if VWRRight == true then
							bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles(-math.pi/2.55,math.pi,0)

						if counter <= 35 then
							SetWeld(joint1,counter,35, j1,j1a, Vector3.new(1.4,0.45,-0.1), Vector3.new(math.pi/9,0,math.pi/9))
							SetWeld(joint2,counter,35, j2,j2a, Vector3.new(-1.4,0.45,-0.1), Vector3.new(math.pi/9,0,-math.pi/9))
							SetWeld(joint3,counter,35, j3,j3a, Vector3.new(0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
							joint3.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
							SetWeld(joint4,counter,35, j4,j4a, Vector3.new(-0.5,-0.75,0), Vector3.new(0,math.pi/2,math.pi/9))
							joint4.C1 = CFrame.new(0,0.7 + (0.3/35*counter),0.2 - (0.2/35*counter)) * CFrame.Angles(0,math.pi/2,0)
							SetWeld(joint5,counter,35, j5,j5a, Vector3.new(0,1,0), Vector3.new(-math.pi/6,0,0))
						end

						if hitz ~= nil then
							bv:remove()
							Torsoz.CFrame = CFrame.new(enz+Vector3.new(0,2,0), (enz+Vector3.new(0,2,0)) + ((-towall*25) + Vector3.new(0,GravPoint,0))) * CFrame.Angles(-math.pi/2.55,math.pi,0)
							Torsoz.Velocity = NV
							Torsoz.RotVelocity = NV
							local bp = Instance.new("BodyPosition", Torsoz)
							bp.maxForce = Vector3.new(1/0,1/0,1/0)
							bp.position = Torsoz.CFrame.p
							game:service("Debris"):AddItem(bp, 0.16)
							flow.Value = 0
							break
						end

						if GravPoint > - 180 then
							GravPoint = GravPoint - 1.9
						end
						if counter > 200 then
							break
						end
						wait(0.02)
					end

					local bp = Instance.new("BodyPosition")

					local counter2 = counter
					local bgangleplus = 0

					local j1,j1a = GetWeld(joint1)
					local j2,j2a = GetWeld(joint2)
					local j3,j3a = GetWeld(joint3)
					local j4,j4a = GetWeld(joint4)
					local j5,j5a = GetWeld(joint5)

					local landingpos

					while VWallRunning == "BackflipFromFall" do
						counter2 = counter2 + 1
						local hitz, enz = RAY(H.Position+Vector3.new(0,2,0), Vector3.new(0,-4.4,0))

						if counter2 - counter < 13 then
							bgangleplus = bgangleplus - ((math.pi*1.1)/13)
						end
						if counter2 - counter <= 13 then
							SetWeld(joint1,counter2-counter,13, j1,j1a, Vector3.new(1.4,0.5,0.1), Vector3.new(math.pi/2,0.1,math.pi/2))
							SetWeld(joint2,counter2-counter,13, j2,j2a, Vector3.new(-1.4,0.5,0.1), Vector3.new(math.pi/2,-0.1,-math.pi/2))
							SetWeld(joint3,counter2-counter,13, j3,j3a, Vector3.new(0.52,-0.3,-0.65), Vector3.new(0,math.pi/2,0))
							SetWeld(joint4,counter2-counter,13, j4,j4a, Vector3.new(-0.51,-0.9,-0.05), Vector3.new(0,math.pi/2,0))
							SetWeld(joint5,counter2-counter,13, j5,j5a, Vector3.new(0,0.9,0), Vector3.new(-math.pi/7,0,0))
						end

						dirpos = (-towall *5) + Vector3.new(0,GravPoint,0)
						--bv.velocity = Vector3.new(0,-2,0)
						bv.velocity = CFrame.new(NV, dirpos).lookVector * dirpos.magnitude
						if VWRLeft == true then
							bv.velocity = bv.velocity + ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						if VWRRight == true then
							bv.velocity = bv.velocity - ((CFrame.new(NV, towall) * CFrame.Angles(0,math.pi/2,0)).lookVector * 9)
						end
						bg.cframe = CFrame.new(NV, (-towall*30) + Vector3.new(0,GravPoint,0)) * CFrame.Angles((-math.pi/2.4) + bgangleplus,math.pi,0)

						if hitz ~= nil then
							bv:remove()
							landingpos = enz - (towall*1.3)
							if counter2 - counter > 8 then
								bp = Instance.new("BodyPosition", Torsoz)
								bp.maxForce = Vector3.new(1/0,1/0,1/0)
								bp.position = enz+Vector3.new(0,2.4,0) + (-towall*1)
								VWallRunning = "LandingFall"
							else
								Torsoz.CFrame = bg.cframe + (enz+Vector3.new(0,2.3,0))
								Torsoz.Velocity = NV
								Torsoz.RotVelocity = NV
								local bp = Instance.new("BodyPosition", Torsoz)
								bp.maxForce = Vector3.new(1/0,1/0,1/0)
								bp.position = Torsoz.CFrame.p
								game:service("Debris"):AddItem(bp, 0.14)
								flow.Value = 0
							end
							break
						end

						if GravPoint > - 180 then
							GravPoint = GravPoint - 1.9
						end
						if counter2 > 200 then
							break
						end
						wait(0.02)
					end

					if VWallRunning == "LandingFall" then
						print("Landing")

						joint3.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
						joint4.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)

						local a
						local mesh
						if GravPoint < -70 then
							a = P:Clone()
							a.Parent = Torsoz
							a.Name = "AirLandingEffect"
							a.BrickColor = BrickColor.new("Medium stone grey")
							a.Transparency = 0.3
							a.CFrame = CFrame.new(landingpos+Vector3.new(0,0.4,0))
							mesh = Instance.new("SpecialMesh", a)
							mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
							mesh.Scale = Vector3.new(0,0,0)
						end

						local bgcf = CFrame.new(NV, Vector3.new(towall.x,0,towall.z))
						bg.cframe = bgcf * CFrame.Angles(-math.pi/7,0,0)
						local bgval = math.pi/7/2

						for i = 1, 6 do
							Hu.PlatformStand = true
							SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.2,0.5,0.2), Vector3.new(math.pi/2,0.5,math.pi/1.2))
							SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.2,0.5,0.2), Vector3.new(math.pi/2,-0.5,-math.pi/1.2))
							SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.51,-0.3,-0.8), Vector3.new(0,math.pi/2,-math.pi/7))
							SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.51,-0.8,-0.7), Vector3.new(0,math.pi/2,-math.pi/3))
							SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,0.85,0), Vector3.new(-math.pi/8,0,0))
							bp.position = bp.position + Vector3.new(0,-0.07,0)
							bg.cframe = bgcf * CFrame.Angles((-bgval*2) + (bgval/6*i),0,0)
							Torsoz.CFrame = bg.cframe + bp.position
							if a ~= nil then
								mesh.Scale = mesh.Scale + Vector3.new(1.3,0.35,1.3)
								a.Transparency = 0.3 + (0.7/6*i)
							end
							wait(0.02)
						end
						if a ~= nil then
							a:remove()
						end
						local j1,j1a = GetWeld(joint1)
						local j2,j2a = GetWeld(joint2)
						local j3,j3a = GetWeld(joint3)
						local j4,j4a = GetWeld(joint4)
						local j5,j5a = GetWeld(joint5)
						for i = 1, 6 do
							Hu.PlatformStand = true
							SetWeld(joint1,i,6, j1,j1a, Vector3.new(1.5,0.5,0), Vector3.new(0,0,0))
							SetWeld(joint2,i,6, j2,j2a, Vector3.new(-1.5,0.5,0), Vector3.new(0,0,0))
							SetWeld(joint3,i,6, j3,j3a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
							SetWeld(joint4,i,6, j4,j4a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
							SetWeld(joint5,i,6, j5,j5a, Vector3.new(0,1,0), Vector3.new(0,0,0))
							bp.position = bp.position + Vector3.new(0,0.1,0)
							bg.cframe = bgcf * CFrame.Angles(-bgval + (bgval/6*i),0,0)
							Torsoz.CFrame = bg.cframe + bp.position
							wait(0.02)
						end

						bp:remove()
					end

				end

				bv:remove()
				bg:remove()
				VWallRunning = false
				Stand()
			end
		end

		function Slide(pos)
			flow.Value = flow.Value + 6
			Action = "Sliding"
			Sliding = true
			GravPoint = Torsoz.Velocity.y
			local spd = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude + 10
			local dir = Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).unit

			local bv = Instance.new("BodyVelocity", Torsoz)
			bv.maxForce = Vector3.new(1/0,1/0,1/0)
			bv.velocity = dir*spd
			local bg = Instance.new("BodyGyro", Torsoz)
			bg.maxTorque = Vector3.new(1/0,1/0,1/0)
			bg.cframe = CFrame.new(NV, dir) * CFrame.Angles(math.pi/2.2,0.24,0)

			local joint1 = Joint1
			local joint2 = Joint2
			local joint3 = Joint3
			local joint4 = Joint4
			local joint5 = Joint5
			local j1,j1a = GetWeld(joint1)
			local j2,j2a = GetWeld(joint2)

			SetWeld(joint1,1,1, NV,NV, Vector3.new(j1.x,j1.y,j1.z), Vector3.new(j1a.x,math.pi/2,j1a.z))
			joint1.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)
			SetWeld(joint2,1,1, NV,NV, Vector3.new(j2.x,j2.y,j2.z), Vector3.new(j2a.x,math.pi/2,j2a.z))
			joint2.C1 = CFrame.new(0,1,0) * CFrame.Angles(0,math.pi/2,0)

			local j1,j1a = GetWeld(joint1)
			local j2,j2a = GetWeld(joint2)
			local j3,j3a = GetWeld(joint3)
			local j4,j4a = GetWeld(joint4)
			local j5,j5a = GetWeld(joint5)

			local count = 0
			local lastpos

			while Sliding == true do
				count = count + 1
				Hu.PlatformStand = true
				local hitz1, enz1 = RAY(Torsoz.Position+Vector3.new(0,0.03,0), dir *2.5)
				local hitz2, enz2 = RAY(Torsoz.Position-Vector3.new(0,0.2,0), dir *2.5)
				local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
				bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

				if count <= 5 then
					SetWeld(joint1,count,5, j1,j1a, Vector3.new(0.5,-0.8,-0.15), Vector3.new(0,(math.pi/2)+0.1,-0.4))
					SetWeld(joint2,count,5, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,(math.pi/2)-0.4,0))
					SetWeld(joint3,count,5, j3,j3a, Vector3.new(1.5,0.5,0), Vector3.new(-0.7,-0.24,math.pi/5))
					SetWeld(joint4,count,5, j4,j4a, Vector3.new(-1.5,0.5,0), Vector3.new(-0.1,0,-math.pi/1.5))
					SetWeld(joint5,count,5, j5,j5a, Vector3.new(0,1,0), Vector3.new(-0.5,-0.2,0))
				end

				if (hitz1 ~= nil and hitz1.CanCollide == true) or (hitz2 ~= nil and  hitz2.CanCollide == true) then
					bv:remove()
					bg:remove()
					Sliding = "HitObject"
				end
				if ghitz ~= nil then
					GravPoint = 0
					Torsoz.CFrame = CFrame.new(genz, genz+dir) * CFrame.Angles(math.pi/2.2,0.24,0) + Vector3.new(0,0.7,0)
					spd = spd - 0.95
				else
					if GravPoint > -180 then
						GravPoint = GravPoint - 5.6
					end
					spd = spd - 0.36
				end
				if spd < 7 then
					Sliding = false
				end
				wait(0.02)
			end

			if Sliding == false then
				local j1,j1a = GetWeld(joint1)
				local j2,j2a = GetWeld(joint2)
				local j3,j3a = GetWeld(joint3)
				local j4,j4a = GetWeld(joint4)
				local j5,j5a = GetWeld(joint5)
				for i = 1, 4 do
					SetWeld(joint1,i,4, j1,j1a, Vector3.new(0.5,-1,0), Vector3.new(0,math.pi/2,0))
					SetWeld(joint2,i,4, j2,j2a, Vector3.new(-0.5,-1,0), Vector3.new(0,math.pi/2,0))
					SetWeld(joint3,i,4, j3,j3a, Vector3.new(1.5,0.5,0), NV)
					SetWeld(joint4,i,4, j4,j4a, Vector3.new(-1.5,0.5,0), NV)
					SetWeld(joint5,i,4, j5,j5a, Vector3.new(0,1,0), NV)
					local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
					bg.cframe = CFrame.new(NV, dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0)
					bv.velocity = dir*spd + Vector3.new(0,GravPoint,0)

					if hitz ~= nil then
						GravPoint = 0
						Torsoz.CFrame = CFrame.new(enz, enz+dir) * CFrame.Angles((math.pi/2.2) - ((math.pi/2.2)/4*i),0.24 - (0.24/4*i),0) + Vector3.new(0,0.7+(1.8/4*i),0)
						spd = spd - 0.95
					else
						if GravPoint > -180 then
							GravPoint = GravPoint - 5.6
						end
						spd = spd - 0.36
					end
					wait(0.02)
				end
				local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-2.6,0))
				Torsoz.CFrame = CFrame.new(enz, enz+dir) + Vector3.new(0,3,0)
			end
			bv:remove()
			bg:remove()
			SlideCooldown = 10
			Stand()
		end

		function KD(key)
			if pause.Value == false then
				if key == string.char(32) then
					Space = true

					local ghitz, genz = RAY(Torsoz.Position, Vector3.new(0,-3.7,0))
					local hitz, enz = RAY(Torsoz.Position+Vector3.new(0,1.1,0), Torsoz.CFrame.lookVector*2.3)
					local righthitz, rightenz
					local lefthitz, leftenz

					if HWallRunning == false then
						righthitz, rightenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)
						lefthitz, leftenz = RAY(Torsoz.Position, ((Torsoz.CFrame * CFrame.new(-1.5,0,-0.2)).p - Torsoz.CFrame.p).unit*3.9)

					elseif HWallRunning == "Jumping" then
						righthitz, rightenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)
						lefthitz, leftenz = RAY(Torsoz.Position, ((CFrame.new(Torsoz.Position, Torsoz.Position + HWRDir) * CFrame.new(-1.5,0,-0.2)).p - Torsoz.Position).unit*3.9)

					end

					if Action == "Standing" and Shift == true and (hitz == nil or hitz.CanCollide == false) and (righthitz == nil or righthitz.CanCollide == false) and (lefthitz == nil or lefthitz.CanCollide == false) and (ghitz == nil or ghitz.CanCollide == false) and (Torsoz.Velocity.y > 6 and Torsoz.Velocity.y < 50) and DivingCooldown <= 0 then
						if stamina >= 10 then
							--if Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 12 then
							Dive()
							--end
						end
					end

					if hitz == nil and VWallRunning == "Falling" then
						VWallRunning = "BackflipFromFall"
					end

					if Shift == true and Torsoz.Velocity.y > -50 and Diving == false and DivingCooldown <= 0 then
						local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-3.5,0))

						if hitz ~= nil then
							if Action == "Standing" and VWRCooldown == 0 then
								if hitz2 == nil or hitz2.CanCollide == false then
									VWR(hitz, enz)
								end
							end
						end

						if (HWallRunning == false or (HWallRunning == "Jumping" and (HWRLastPart ~= righthitz or HWRLastPart ~= lefthitz))) and HWRCooldown == 0 and VWallRunning == false then

							if (hitz == nil or HWallRunning == "Jumping") and ((righthitz ~= nil and righthitz.Parent:findFirstChild("Humanoid") == nil and righthitz.Parent.className ~= "Hat") or (lefthitz ~= nil and lefthitz.Parent:findFirstChild("Humanoid") == nil and lefthitz.Parent.className ~= "Hat")) then
								if hitz2 == nil or hitz2.CanCollide == false then
									local right = (rightenz - Torsoz.Position).magnitude
									local left = (leftenz - Torsoz.Position).magnitude
									if right < left then
										if HWallRunning == "Jumping" and HWRLastPart ~= righthitz then
											HWallRunning = false
											while Standing == false do
												wait(0.01)
											end
											print("2nd Right Activated!")
											HWallRun(righthitz, rightenz, -math.pi/2)
										else
											if hitz == nil then
												print("Right Activated")
												HWallRun(righthitz, rightenz, -math.pi/2)
											end
										end
									elseif left < right then
										if HWallRunning == "Jumping" and HWRLastPart ~= lefthitz then
											HWallRunning = false
											while Standing == false do
												wait(0.01)
											end
											print("2nd Left Activated!")
											HWallRun(lefthitz, leftenz, math.pi/2)
										else
											if hitz == nil then
												print("Left Activated")
												HWallRun(lefthitz, leftenz, math.pi/2)
											end
										end
									end
								end
							end
						end

					end

					if HWallRunning == true then
						HWallRunning = "Jumping"
						Action = "HWRJumping"
					end

				elseif key == string.char(48) then
					Shift = true
				elseif key == string.char(50) then
					if Action == "Standing" then
						Sit()
					elseif HWallRunning == true then
						HWRGravDrop = true
					end
				elseif key == string.char(52) then
					if Shift == true and Action == "Standing" and SlideCooldown == 0 and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 15 and Torsoz.Velocity.y > -40 then
						print("Sliding")
						Slide()
					end
				elseif key == "a" then
					VWRLeft = true
				elseif key == "d" then
					VWRRight = true
				end
			end
		end

		function KU(key)
			if key == string.char(32) then
				Space = false
			elseif key == string.char(48) then
				Shift = false
			elseif key == string.char(50) then
				if Action == "Sitting" then
					Stand()
				end
			elseif key == string.char(52) then
				Sliding = false
			elseif key == "a" then
				VWRLeft = false
			elseif key == "d" then
				VWRRight = false
			end
		end

		mouse.KeyDown:connect(function(key) KD(key) end)
		mouse.KeyUp:connect(function(key) KU(key) end)

		Joint1 = Instance.new("Snap", Torsoz)
		GetWeld(Joint1)
		Joint2 = Instance.new("Snap", Torsoz)
		GetWeld(Joint2)
		Joint3 = Instance.new("Snap", Torsoz)
		GetWeld(Joint3)
		Joint4 = Instance.new("Snap", Torsoz)
		GetWeld(Joint4)
		Joint5 = Instance.new("Snap", Torsoz)
		GetWeld(Joint5)
		Stand()

		local animatebg = Instance.new("BodyGyro")
		animatebg.D = 100
		local GravAction = "Idle"
		local PrevGravAction = GravAction

		local prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
		local prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
		local hue = 0
		local recyclecount = 0
		local tickoffset = tick()
		local fadetab = {}
		local fadetab2 = {}
		local animatebgcount = 0

		for i = 1, 13 do
			local p = P:Clone()
			p.Name = "Part"..i
			local mesh = Instance.new("SpecialMesh", p)
			mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
			mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
			table.insert(fadetab, {p, mesh})
		end
		for i = 1, 13 do
			local p = P:Clone()
			p.Name = "Part"..i
			local mesh = Instance.new("SpecialMesh", p)
			mesh.MeshId = "http://www.roblox.com/Asset/?id=9856898"
			mesh.TextureId = "http://www.roblox.com/Asset/?id=48358980"
			table.insert(fadetab2, {p, mesh})
		end

		game:service("RunService").Stepped:connect(function()
			GravAction = "Idle"
			hue = hue + 3
			hue = hue % 360

			------------- anim angle changing --------
			if animangle > math.pi then
				animplus = false
			elseif animangle < -math.pi then
				animplus = true  
			end
			if animplus == true then
				animangle = animangle + animspeed
			elseif animplus == false then
				animangle = animangle - animspeed
			end

			local hitz, enz = RAY(Torsoz.Position, Vector3.new(0,-3.9,0))
			if Shift == true then
				Hu.WalkSpeed = sprint
			else
				Hu.WalkSpeed = 16
			end
			if (FOV >= 70 and FOV < 74) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude > 25 then
				FOV = FOV + 1
			elseif (FOV <= 74 and FOV > 70) and Vector3.new(Torsoz.Velocity.x,0,Torsoz.Velocity.z).magnitude < 20 then
				FOV = FOV - 1
			end
			if pause.Value == true then
				Hu.WalkSpeed = 0
			end
			if Sitting == true then
				local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-2.2,0))
				Hu.PlatformStand = true
				if hitz2 == nil then
					Stand()
				end
			end
			if Diving == true then
				Hu.PlatformStand = true
				DivingBV.velocity = Vector3.new(DivingDir.x*(sprint+2),GravPoint,DivingDir.z*(sprint+2))
				DivingBG.cframe = CFrame.new(Torsoz.Position, Torsoz.Position+DivingBV.velocity) * CFrame.Angles(-math.pi/2,0,0)

				if GravPoint > -180 then
					GravPoint = GravPoint - 2
				end
			end
			if DivingCooldown > 0 then
				DivingCooldown = DivingCooldown - 1
			end
			if HWallRunning == true then
				if HWRGravDrop == false then
					GravPoint = GravPoint - 0.4
				else
					GravPoint = GravPoint - 2
				end
			elseif HWallRunning == "Jumping" then
				GravPoint = GravPoint - 1.7
			end
			----------------------------- stamina ----------------------------------------
			if Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 18 and Action == "Standing" and Shift == true then
				if stamina > 0 then
					stamina = stamina - 0.5
					if stamina < 0 then
						Shift = false
						stamina = 0
					end
				else
					Shift = false
					stamina = 0
				end
				if Action == "Standing" then
					animspeed = 0.85
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/4.85,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/4.85,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/3.5,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/3.5,0,0))
				end
			elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude > 12 and Action ~= "Sliding" then
				if stamina < maxstamina then
					stamina = stamina + 0.5
					if stamina > maxstamina then
						stamina = maxstamina
					end
				else
					stamina = maxstamina
				end
				if Action == "Standing" then
					animspeed = 0.65
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/7,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/7,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/5,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/5,0,0))
				end
			elseif Vector3.new(Torsoz.Velocity.x, 0, Torsoz.Velocity.z).magnitude < 2 then
				animspeed = 0.1
				if Action == "Standing" then
					SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
					SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
					SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new(animangle/30,0,0))
					SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new(-animangle/30,0,0))
				end
				if stamina < maxstamina then
					if Sitting == false then
						stamina = stamina + 0.65
					else
						stamina = stamina + 1.02
					end
					if stamina > maxstamina then
						stamina = maxstamina
					end
				else
					stamina = maxstamina
				end
			end

			if hitz == nil then
				if Torsoz.Velocity.y > 1 or (Torsoz.Velocity.y < -1 and Torsoz.Velocity.y > -90) then
					if Action == "Standing" then
						GravAction = "Rising"
						animspeed = 0.1
						SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.5,-1,0), Vector3.new(-animangle/38,0,0))
						SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.5,-1,0), Vector3.new(animangle/38,0,0))
						SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.5,0.5,0), Vector3.new((math.pi-0.2)+(animangle/30),0,0))
						SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.5,0.5,0), Vector3.new((math.pi-0.2)+(-animangle/30),0,0))
						if animatebg.Parent ~= nil then
							animatebg.Parent = Torsoz
							animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
							local lokvec = Torsoz.CFrame.lookVector*100
							animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
							animatebg.Parent = nil
						end
					end
				end
			end

			if hitz == nil then
				local hitz2, enz2 = RAY(Torsoz.Position, Vector3.new(0,-6,0))
				if hitz2 == nil then
					if Torsoz.Velocity.y < -90 then
						if Action == "Standing" then
							GravAction = "Falling"
							animspeed = 1.1
							animatebg.Parent = Torsoz
							animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
							local lokvec = Torsoz.CFrame.lookVector*100
							animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z)) * CFrame.Angles(-math.pi/11,animangle/70,0)
							SetWeld(Joint1,1,1, NV,NV, Vector3.new(0.45,-0.8,0), Vector3.new((animangle/27)-0.3,0,0.18))
							SetWeld(Joint2,1,1, NV,NV, Vector3.new(-0.45,-0.8,0), Vector3.new((-animangle/27)-0.3,0,-0.18))
							SetWeld(Joint3,1,1, NV,NV, Vector3.new(1.4,0.5,0), Vector3.new((math.pi+0.2)+(animangle/26),0,0.18))
							SetWeld(Joint4,1,1, NV,NV, Vector3.new(-1.4,0.5,0), Vector3.new((math.pi+0.2)+(-animangle/26),0,-0.18))
						end
					end
				elseif hitz2.CanCollide == true then
					if animatebg.Parent ~= nil then
						animatebg.Parent = Torsoz
						animatebg.maxTorque = Vector3.new(1/0,10000,1/0)
						local lokvec = Torsoz.CFrame.lookVector*100
						animatebg.cframe = CFrame.new(NV, Vector3.new(lokvec.x,0,lokvec.z))
						animatebg.Parent = nil
					end
				end
			end

			if GravAction == "Idle" and animatebg.Parent ~= nil then
				animatebg.Parent = nil
			end

			if math.abs(tickoffset - tick()) > 0.05 then
				tickoffset = tick()
				local flowcolor = HSV(hue, 0.7,1)
				recyclecount = (recyclecount % #fadetab) + 1
				if flow.Value > 25 then
					local lapos = (LA.CFrame * CFrame.new(0,-1,0)).p
					local rapos = (RA.CFrame * CFrame.new(0,-1,0)).p
					local p = fadetab[recyclecount]
					p[1].Parent = m
					p[1].CFrame = CFrame.new((lapos+prevlapos)/2, lapos)
					p[2].Scale = Vector3.new(0.5,0.5,(lapos-prevlapos).magnitude*2)
					p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
					p[1].Transparency = math.abs((flow.Value/120) - 0.8)
					p[1].Transparency = p[1].Transparency + (1/#fadetab)
					local p = fadetab2[recyclecount]
					p[1].Parent = m
					p[1].CFrame = CFrame.new((rapos+prevrapos)/2, rapos)
					p[2].Scale = Vector3.new(0.5,0.5,(rapos-prevrapos).magnitude*2)
					p[2].VertexColor = Vector3.new(flowcolor.r,flowcolor.g,flowcolor.b)
					p[1].Transparency = math.abs((flow.Value/120) - 0.8)
					p[1].Transparency = p[1].Transparency + (1/#fadetab)
				end

				for i, v in pairs(fadetab) do
					if v[1].Transparency < 0.9 then
						v[1].Transparency = v[1].Transparency + (1/#fadetab)
						fadetab2[i][1].Transparency = fadetab2[i][1].Transparency + (1/#fadetab)
					elseif v[1].Transparency ~= 1 then
						v[1].Transparency = 1
						v[1].Position = Vector3.new(50000,0,0)
						fadetab2[i][1].Transparency = 1
						fadetab2[i][1].Position = Vector3.new(50000,0,0)
					end
				end

				prevrapos = (RA.CFrame * CFrame.new(0,-1,0)).p
				prevlapos = (LA.CFrame * CFrame.new(0,-1,0)).p
			end

			if flow.Value > 140 then
				if char.Parent ~= nil then
					char:remove()
				end
			end

			if flowcooldown > 0 then
				flowcooldown = flowcooldown - 1
			end
			if HWRCooldown > 0 then
				HWRCooldown = HWRCooldown - 1
			end
			if VWRCooldown > 0 then
				if hitz ~= nil and VWRCooldown > 0 then
					VWRCooldown = VWRCooldown - 1
				end
			end
			if SlideCooldown > 0 then
				SlideCooldown = SlideCooldown - 1
			end

			if Action == "HWallRunning" or Action == "VWallRunning" then
				flow.Value = flow.Value + 0.24
				if flow.Value > 100 then
					flow.Value = 100
				end
				flowcooldown = 40
			elseif Action == "Diving" then
				flowcooldown = 30
			elseif Action == "Sliding" then
				flowcooldown = 15
			elseif Action == "Standing" or Action == "Sitting" then
				if flow.Value > 0 and flowcooldown <= 0 then
					flow.Value = flow.Value - 0.37
					if flow.Value < 0 then
						flow.Value = 0
					end
				end
			end

			cam.FieldOfView = FOV
			prevanimbgcount = animatebgcount
			sprint = defsprint + ((flow.Value/100)*2.4)
			PrevGravAction = GravAction
			Calculate()
		end)
	end)
end
coroutine.wrap(KJVCAQN_fake_script)()
local function SSQRVAO_fake_script() -- Page.LocalScript 
	local script = Instance.new('LocalScript', Page)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page2"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(SSQRVAO_fake_script)()
local function RDLG_fake_script() -- Page_2.LocalScript 
	local script = Instance.new('LocalScript', Page_2)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page1"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(RDLG_fake_script)()
local function PFFE_fake_script() -- Page_3.LocalScript 
	local script = Instance.new('LocalScript', Page_3)

	local function findPlayer(name)
		name = name:lower()
		if name == 'me' then
			return game:GetService'Players'.LocalPlayer
		end
		for i,v in pairs(game:GetService'Players':GetPlayers()) do
			if v.Name:lower():find(name) == 1 then
				return v
			end
		end
	end
	
	if(_G.TweenDB==nil)then
		_G.TweenDB=false
	end
	
	local currpage = script.Parent.Parent
	local nextpage = script.Parent.Parent.Parent:WaitForChild"Page3"
	script.Parent.MouseButton1Click:connect(function()
		if(_G.TweenDB)then return end
		_G.TweenDB=true
		nextpage.Visible=true
		currpage.Visible=true
		nextpage.Position = UDim2.new(1,0,.3,0)
		currpage:TweenPosition(UDim2.new(-1,0,.3,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,.6,true)
		wait(.4)
		nextpage:TweenPosition(UDim2.new(0,0,.3,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,.5,true)
		wait(.5)
		_G.TweenDB=false
	end)
end
coroutine.wrap(PFFE_fake_script)()
local function UHNOWD_fake_script() -- UtgV2.LocalScript 
	local script = Instance.new('LocalScript', UtgV2)

	UtgV2.MouseButton1Down:connect(function()
		local UTG_V2 = Instance.new("ScreenGui")
		local Main = Instance.new("Frame")
		local UIGradient = Instance.new("UIGradient")
		local UICorner = Instance.new("UICorner")
		local Title = Instance.new("TextLabel")
		local SubTitile = Instance.new("TextLabel")
		local Welcome = Instance.new("TextLabel")
		local UICorner_2 = Instance.new("UICorner")
		local Credits = Instance.new("TextLabel")
		local UICorner_3 = Instance.new("UICorner")
		local OptionListFrame = Instance.new("Frame")
		local OptionList = Instance.new("ScrollingFrame")
		local Sonic = Instance.new("TextButton")
		local UICorner_4 = Instance.new("UICorner")
		local Gale = Instance.new("TextButton")
		local UICorner_5 = Instance.new("UICorner")
		local Among_Us = Instance.new("TextButton")
		local UICorner_6 = Instance.new("UICorner")
		local Killbot = Instance.new("TextButton")
		local UICorner_7 = Instance.new("UICorner")
		local NekoMaid = Instance.new("TextButton")
		local UICorner_8 = Instance.new("UICorner")
		local Smug = Instance.new("TextButton")
		local UICorner_9 = Instance.new("UICorner")
		local ShadowBlade = Instance.new("TextButton")
		local UICorner_10 = Instance.new("UICorner")
		local SwordStand = Instance.new("TextButton")
		local UICorner_11 = Instance.new("UICorner")
		local Neptunion = Instance.new("TextButton")
		local UICorner_12 = Instance.new("UICorner")
		local RbNeptunion = Instance.new("TextButton")
		local UICorner_13 = Instance.new("UICorner")
		local Wall = Instance.new("TextButton")
		local UICorner_14 = Instance.new("UICorner")
		local achroGlicher = Instance.new("TextButton")
		local UICorner_15 = Instance.new("UICorner")
		local FlamingCube = Instance.new("TextButton")
		local UICorner_16 = Instance.new("UICorner")
		local Spider = Instance.new("TextButton")
		local UICorner_17 = Instance.new("UICorner")
		local Cop = Instance.new("TextButton")
		local UICorner_18 = Instance.new("UICorner")
		local Chips = Instance.new("TextButton")
		local UICorner_19 = Instance.new("UICorner")
		local Joy = Instance.new("TextButton")
		local UICorner_20 = Instance.new("UICorner")
		local UMD = Instance.new("TextButton")
		local UICorner_21 = Instance.new("UICorner")
		local Chill = Instance.new("TextButton")
		local UICorner_22 = Instance.new("UICorner")
		local Grapple = Instance.new("TextButton")
		local UICorner_23 = Instance.new("UICorner")
		local ServerAdmin = Instance.new("TextButton")
		local UICorner_24 = Instance.new("UICorner")
		local Ender = Instance.new("TextButton")
		local UICorner_25 = Instance.new("UICorner")
		local Ban = Instance.new("TextButton")
		local UICorner_26 = Instance.new("UICorner")
		local Netless = Instance.new("TextButton")
		local UICorner_27 = Instance.new("UICorner")
		local Shadow = Instance.new("Frame")
		local UICorner_28 = Instance.new("UICorner")
		local TextLabel = Instance.new("TextLabel")
		local AntiReport = Instance.new("TextButton")
		local UICorner_29 = Instance.new("UICorner")
		local Shadow_2 = Instance.new("Frame")
		local UICorner_30 = Instance.new("UICorner")
		local TextLabel_2 = Instance.new("TextLabel")
		local X = Instance.new("TextButton")
		local UICorner_31 = Instance.new("UICorner")
		local OpenUTG = Instance.new("TextButton")

		--Properties:

		UTG_V2.Name = "UTG_V2"
		UTG_V2.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
		UTG_V2.ResetOnSpawn = false

		Main.Name = "Main"
		Main.Parent = UTG_V2
		Main.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Main.BorderColor3 = Color3.fromRGB(27, 42, 53)
		Main.BorderSizePixel = 0
		Main.Position = UDim2.new(0.0592107326, 0, 0.0301492307, 0)
		Main.Size = UDim2.new(0, 451, 0, 534)

		UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(137, 0, 254)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(223, 0, 255))}
		UIGradient.Parent = Main

		UICorner.CornerRadius = UDim.new(0, 5)
		UICorner.Parent = Main

		Title.Name = "Title"
		Title.Parent = Main
		Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Title.BackgroundTransparency = 1.000
		Title.Position = UDim2.new(0.0711524412, 0, -0.00186577276, 0)
		Title.Size = UDim2.new(0, 385, 0, 54)
		Title.Font = Enum.Font.SourceSans
		Title.Text = "ULTIMATE TROLLING GUI V2"
		Title.TextColor3 = Color3.fromRGB(255, 255, 255)
		Title.TextScaled = true
		Title.TextSize = 38.000
		Title.TextWrapped = true

		SubTitile.Name = "SubTitile"
		SubTitile.Parent = Title
		SubTitile.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		SubTitile.BackgroundTransparency = 1.000
		SubTitile.Position = UDim2.new(-0.285957217, 0, 0.388888925, 0)
		SubTitile.Size = UDim2.new(0, 611, 0, 54)
		SubTitile.Font = Enum.Font.SourceSans
		SubTitile.Text = "FE UTG is back! And is now V2! Thx for using! :)"
		SubTitile.TextColor3 = Color3.fromRGB(255, 255, 255)
		SubTitile.TextSize = 20.000

		Welcome.Name = "Welcome"
		Welcome.Parent = Main
		Welcome.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Welcome.Position = UDim2.new(0.0505445786, 0, 0.114676468, 0)
		Welcome.Size = UDim2.new(0, 403, 0, 36)
		Welcome.Font = Enum.Font.SourceSansBold
		Welcome.Text = "Welcome to the brand new FE UTG! Made by Bulkez"
		Welcome.TextColor3 = Color3.fromRGB(0, 0, 0)
		Welcome.TextScaled = true
		Welcome.TextSize = 14.000
		Welcome.TextWrapped = true

		UICorner_2.Parent = Welcome

		Credits.Name = "Credits"
		Credits.Parent = Main
		Credits.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Credits.Position = UDim2.new(0.0527422242, 0, 0.772552848, 0)
		Credits.Size = UDim2.new(0, 405, 0, 44)
		Credits.Font = Enum.Font.SourceSansBold
		Credits.Text = "Made by Blukez also credit to the original script creators also thx FO10 :)"
		Credits.TextColor3 = Color3.fromRGB(0, 0, 0)
		Credits.TextScaled = true
		Credits.TextSize = 14.000
		Credits.TextWrapped = true

		UICorner_3.Parent = Credits

		OptionListFrame.Name = "OptionListFrame"
		OptionListFrame.Parent = Main
		OptionListFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		OptionListFrame.BackgroundTransparency = 1.000
		OptionListFrame.Position = UDim2.new(0.0279720332, 0, 0.191011235, 0)
		OptionListFrame.Size = UDim2.new(0, 403, 0, 711)

		OptionList.Name = "OptionList"
		OptionList.Parent = OptionListFrame
		OptionList.Active = true
		OptionList.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		OptionList.Position = UDim2.new(0.0351866931, 0, 0.00994348992, 0)
		OptionList.Size = UDim2.new(0, 402, 0, 296)

		Sonic.Name = "Sonic"
		Sonic.Parent = OptionList
		Sonic.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Sonic.Position = UDim2.new(0.0231197979, 0, 0.00696475245, 0)
		Sonic.Size = UDim2.new(0, 370, 0, 50)
		Sonic.Font = Enum.Font.SourceSans
		Sonic.Text = "Sonic"
		Sonic.TextColor3 = Color3.fromRGB(255, 255, 255)
		Sonic.TextScaled = true
		Sonic.TextSize = 14.000
		Sonic.TextWrapped = true

		UICorner_4.Parent = Sonic

		Gale.Name = "Gale"
		Gale.Parent = OptionList
		Gale.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Gale.Position = UDim2.new(0.0231197979, 0, 0.0506699458, 0)
		Gale.Size = UDim2.new(0, 370, 0, 50)
		Gale.Font = Enum.Font.SourceSans
		Gale.Text = "Gale"
		Gale.TextColor3 = Color3.fromRGB(255, 255, 255)
		Gale.TextScaled = true
		Gale.TextSize = 14.000
		Gale.TextWrapped = true

		UICorner_5.Parent = Gale

		Among_Us.Name = "Among_Us"
		Among_Us.Parent = OptionList
		Among_Us.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Among_Us.Position = UDim2.new(0.0231197979, 0, 0.092793569, 0)
		Among_Us.Size = UDim2.new(0, 370, 0, 50)
		Among_Us.Font = Enum.Font.SourceSans
		Among_Us.Text = "Among us"
		Among_Us.TextColor3 = Color3.fromRGB(255, 255, 255)
		Among_Us.TextScaled = true
		Among_Us.TextSize = 14.000
		Among_Us.TextWrapped = true

		UICorner_6.Parent = Among_Us

		Killbot.Name = "Killbot"
		Killbot.Parent = OptionList
		Killbot.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Killbot.Position = UDim2.new(0.0231197979, 0, 0.1349172, 0)
		Killbot.Size = UDim2.new(0, 370, 0, 50)
		Killbot.Font = Enum.Font.SourceSans
		Killbot.Text = "Killbot"
		Killbot.TextColor3 = Color3.fromRGB(255, 255, 255)
		Killbot.TextScaled = true
		Killbot.TextSize = 14.000
		Killbot.TextWrapped = true

		UICorner_7.Parent = Killbot

		NekoMaid.Name = "NekoMaid"
		NekoMaid.Parent = OptionList
		NekoMaid.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		NekoMaid.Position = UDim2.new(0.0231197979, 0, 0.177534401, 0)
		NekoMaid.Size = UDim2.new(0, 370, 0, 50)
		NekoMaid.Font = Enum.Font.SourceSans
		NekoMaid.Text = "Neko Maid"
		NekoMaid.TextColor3 = Color3.fromRGB(255, 255, 255)
		NekoMaid.TextScaled = true
		NekoMaid.TextSize = 14.000
		NekoMaid.TextWrapped = true

		UICorner_8.Parent = NekoMaid

		Smug.Name = "Smug"
		Smug.Parent = OptionList
		Smug.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Smug.Position = UDim2.new(0.0231197979, 0, 0.22079052, 0)
		Smug.Size = UDim2.new(0, 370, 0, 50)
		Smug.Font = Enum.Font.SourceSans
		Smug.Text = "Smug Dance V6"
		Smug.TextColor3 = Color3.fromRGB(255, 255, 255)
		Smug.TextScaled = true
		Smug.TextSize = 14.000
		Smug.TextWrapped = true

		UICorner_9.Parent = Smug

		ShadowBlade.Name = "ShadowBlade"
		ShadowBlade.Parent = OptionList
		ShadowBlade.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		ShadowBlade.Position = UDim2.new(0.0231197979, 0, 0.263522238, 0)
		ShadowBlade.Size = UDim2.new(0, 370, 0, 50)
		ShadowBlade.Font = Enum.Font.SourceSans
		ShadowBlade.Text = "Shadow Blade"
		ShadowBlade.TextColor3 = Color3.fromRGB(255, 255, 255)
		ShadowBlade.TextScaled = true
		ShadowBlade.TextSize = 14.000
		ShadowBlade.TextWrapped = true

		UICorner_10.Parent = ShadowBlade

		SwordStand.Name = "SwordStand"
		SwordStand.Parent = OptionList
		SwordStand.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		SwordStand.Position = UDim2.new(0.0231197979, 0, 0.304071069, 0)
		SwordStand.Size = UDim2.new(0, 370, 0, 50)
		SwordStand.Font = Enum.Font.SourceSans
		SwordStand.Text = "Sword Stand"
		SwordStand.TextColor3 = Color3.fromRGB(255, 255, 255)
		SwordStand.TextScaled = true
		SwordStand.TextSize = 14.000
		SwordStand.TextWrapped = true

		UICorner_11.Parent = SwordStand

		Neptunion.Name = "Neptunion"
		Neptunion.Parent = OptionList
		Neptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Neptunion.Position = UDim2.new(0.0231197979, 0, 0.347187638, 0)
		Neptunion.Size = UDim2.new(0, 370, 0, 50)
		Neptunion.Font = Enum.Font.SourceSans
		Neptunion.Text = "Neptunion V"
		Neptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
		Neptunion.TextScaled = true
		Neptunion.TextSize = 14.000
		Neptunion.TextWrapped = true

		UICorner_12.Parent = Neptunion

		RbNeptunion.Name = "RbNeptunion"
		RbNeptunion.Parent = OptionList
		RbNeptunion.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		RbNeptunion.Position = UDim2.new(0.0231197979, 0, 0.390972137, 0)
		RbNeptunion.Size = UDim2.new(0, 370, 0, 50)
		RbNeptunion.Font = Enum.Font.SourceSans
		RbNeptunion.Text = "RB Neptunion"
		RbNeptunion.TextColor3 = Color3.fromRGB(255, 255, 255)
		RbNeptunion.TextScaled = true
		RbNeptunion.TextSize = 14.000
		RbNeptunion.TextWrapped = true

		UICorner_13.Parent = RbNeptunion

		Wall.Name = "Wall"
		Wall.Parent = OptionList
		Wall.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Wall.Position = UDim2.new(0.0231197979, 0, 0.434192657, 0)
		Wall.Size = UDim2.new(0, 370, 0, 50)
		Wall.Font = Enum.Font.SourceSans
		Wall.Text = "Wall"
		Wall.TextColor3 = Color3.fromRGB(255, 255, 255)
		Wall.TextScaled = true
		Wall.TextSize = 14.000
		Wall.TextWrapped = true

		UICorner_14.Parent = Wall

		achroGlicher.Name = "achroGlicher"
		achroGlicher.Parent = OptionList
		achroGlicher.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		achroGlicher.Position = UDim2.new(0.0231197979, 0, 0.47801882, 0)
		achroGlicher.Size = UDim2.new(0, 370, 0, 50)
		achroGlicher.Font = Enum.Font.SourceSans
		achroGlicher.Text = "Achromatic Glicher"
		achroGlicher.TextColor3 = Color3.fromRGB(255, 255, 255)
		achroGlicher.TextScaled = true
		achroGlicher.TextSize = 14.000
		achroGlicher.TextWrapped = true

		UICorner_15.Parent = achroGlicher

		FlamingCube.Name = "FlamingCube"
		FlamingCube.Parent = OptionList
		FlamingCube.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		FlamingCube.Position = UDim2.new(0.0231197979, 0, 0.521497488, 0)
		FlamingCube.Size = UDim2.new(0, 370, 0, 50)
		FlamingCube.Font = Enum.Font.SourceSans
		FlamingCube.Text = "Flaming Cube"
		FlamingCube.TextColor3 = Color3.fromRGB(255, 255, 255)
		FlamingCube.TextScaled = true
		FlamingCube.TextSize = 14.000
		FlamingCube.TextWrapped = true

		UICorner_16.Parent = FlamingCube

		Spider.Name = "Spider"
		Spider.Parent = OptionList
		Spider.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Spider.Position = UDim2.new(0.0231197979, 0, 0.564180851, 0)
		Spider.Size = UDim2.new(0, 370, 0, 50)
		Spider.Font = Enum.Font.SourceSans
		Spider.Text = "Spider"
		Spider.TextColor3 = Color3.fromRGB(255, 255, 255)
		Spider.TextScaled = true
		Spider.TextSize = 14.000
		Spider.TextWrapped = true

		UICorner_17.Parent = Spider

		Cop.Name = "Cop"
		Cop.Parent = OptionList
		Cop.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Cop.Position = UDim2.new(0.0231197979, 0, 0.606966078, 0)
		Cop.Size = UDim2.new(0, 370, 0, 50)
		Cop.Font = Enum.Font.SourceSans
		Cop.Text = "Cop"
		Cop.TextColor3 = Color3.fromRGB(255, 255, 255)
		Cop.TextScaled = true
		Cop.TextSize = 14.000
		Cop.TextWrapped = true

		UICorner_18.Parent = Cop

		Chips.Name = "Chips"
		Chips.Parent = OptionList
		Chips.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Chips.Position = UDim2.new(0.0231197979, 0, 0.649766564, 0)
		Chips.Size = UDim2.new(0, 370, 0, 50)
		Chips.Font = Enum.Font.SourceSans
		Chips.Text = "Chips"
		Chips.TextColor3 = Color3.fromRGB(255, 255, 255)
		Chips.TextScaled = true
		Chips.TextSize = 14.000
		Chips.TextWrapped = true

		UICorner_19.Parent = Chips

		Joy.Name = "Joy"
		Joy.Parent = OptionList
		Joy.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Joy.Position = UDim2.new(0.0231197979, 0, 0.69195044, 0)
		Joy.Size = UDim2.new(0, 370, 0, 50)
		Joy.Font = Enum.Font.SourceSans
		Joy.Text = ":Joy:"
		Joy.TextColor3 = Color3.fromRGB(255, 255, 255)
		Joy.TextScaled = true
		Joy.TextSize = 14.000
		Joy.TextWrapped = true

		UICorner_20.Parent = Joy

		UMD.Name = "UMD"
		UMD.Parent = OptionList
		UMD.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		UMD.Position = UDim2.new(0.0231197979, 0, 0.732523978, 0)
		UMD.Size = UDim2.new(0, 370, 0, 50)
		UMD.Font = Enum.Font.SourceSans
		UMD.Text = "Ultimate meme dance"
		UMD.TextColor3 = Color3.fromRGB(255, 255, 255)
		UMD.TextScaled = true
		UMD.TextSize = 14.000
		UMD.TextWrapped = true

		UICorner_21.Parent = UMD

		Chill.Name = "Chill"
		Chill.Parent = OptionList
		Chill.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Chill.Position = UDim2.new(0.0231197979, 0, 0.772394419, 0)
		Chill.Size = UDim2.new(0, 370, 0, 50)
		Chill.Font = Enum.Font.SourceSans
		Chill.Text = "Chill"
		Chill.TextColor3 = Color3.fromRGB(255, 255, 255)
		Chill.TextScaled = true
		Chill.TextSize = 14.000
		Chill.TextWrapped = true

		UICorner_22.Parent = Chill

		Grapple.Name = "Grapple"
		Grapple.Parent = OptionList
		Grapple.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Grapple.Position = UDim2.new(0.0231197979, 0, 0.815179646, 0)
		Grapple.Size = UDim2.new(0, 370, 0, 50)
		Grapple.Font = Enum.Font.SourceSans
		Grapple.Text = "Grapple"
		Grapple.TextColor3 = Color3.fromRGB(255, 255, 255)
		Grapple.TextScaled = true
		Grapple.TextSize = 14.000
		Grapple.TextWrapped = true

		UICorner_23.Parent = Grapple

		ServerAdmin.Name = "ServerAdmin"
		ServerAdmin.Parent = OptionList
		ServerAdmin.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		ServerAdmin.Position = UDim2.new(0.0231197979, 0, 0.858780205, 0)
		ServerAdmin.Size = UDim2.new(0, 370, 0, 50)
		ServerAdmin.Font = Enum.Font.SourceSans
		ServerAdmin.Text = "Server Admin"
		ServerAdmin.TextColor3 = Color3.fromRGB(255, 255, 255)
		ServerAdmin.TextScaled = true
		ServerAdmin.TextSize = 14.000
		ServerAdmin.TextWrapped = true

		UICorner_24.Parent = ServerAdmin

		Ender.Name = "Ender"
		Ender.Parent = OptionList
		Ender.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Ender.Position = UDim2.new(0.0231197979, 0, 0.902380705, 0)
		Ender.Size = UDim2.new(0, 370, 0, 50)
		Ender.Font = Enum.Font.SourceSans
		Ender.Text = "Ender"
		Ender.TextColor3 = Color3.fromRGB(255, 255, 255)
		Ender.TextScaled = true
		Ender.TextSize = 14.000
		Ender.TextWrapped = true

		UICorner_25.Parent = Ender

		Ban.Name = "Ban"
		Ban.Parent = OptionList
		Ban.BackgroundColor3 = Color3.fromRGB(170, 0, 255)
		Ban.Position = UDim2.new(0.0231197979, 0, 0.945981264, 0)
		Ban.Size = UDim2.new(0, 370, 0, 50)
		Ban.Font = Enum.Font.SourceSans
		Ban.Text = "Ban Hammer"
		Ban.TextColor3 = Color3.fromRGB(255, 255, 255)
		Ban.TextScaled = true
		Ban.TextSize = 14.000
		Ban.TextWrapped = true

		UICorner_26.Parent = Ban

		Netless.Name = "Netless"
		Netless.Parent = Main
		Netless.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
		Netless.BorderSizePixel = 0
		Netless.Position = UDim2.new(0.51807934, 0, 0.868913829, 0)
		Netless.Size = UDim2.new(0, 195, 0, 57)
		Netless.ZIndex = 2
		Netless.Font = Enum.Font.GothamSemibold
		Netless.Text = ""
		Netless.TextColor3 = Color3.fromRGB(255, 255, 255)
		Netless.TextScaled = true
		Netless.TextSize = 14.000
		Netless.TextWrapped = true

		UICorner_27.Parent = Netless

		Shadow.Name = "Shadow"
		Shadow.Parent = Netless
		Shadow.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
		Shadow.BorderSizePixel = 0
		Shadow.Size = UDim2.new(1, 0, 1, 4)

		UICorner_28.Parent = Shadow

		TextLabel.Parent = Netless
		TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1.000
		TextLabel.BorderColor3 = Color3.fromRGB(27, 42, 53)
		TextLabel.BorderSizePixel = 0
		TextLabel.Position = UDim2.new(0.5, 0, 0.49999997, 0)
		TextLabel.Size = UDim2.new(1, -20, 1, -20)
		TextLabel.ZIndex = 2
		TextLabel.Font = Enum.Font.GothamSemibold
		TextLabel.Text = "Netless (Use AFTER any scripts)"
		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.TextScaled = true
		TextLabel.TextSize = 14.000
		TextLabel.TextWrapped = true

		AntiReport.Name = "AntiReport"
		AntiReport.Parent = Main
		AntiReport.BackgroundColor3 = Color3.fromRGB(77, 156, 115)
		AntiReport.BorderSizePixel = 0
		AntiReport.Position = UDim2.new(0.0489794947, 0, 0.868913829, 0)
		AntiReport.Size = UDim2.new(0, 197, 0, 57)
		AntiReport.ZIndex = 2
		AntiReport.Font = Enum.Font.GothamSemibold
		AntiReport.Text = ""
		AntiReport.TextColor3 = Color3.fromRGB(255, 255, 255)
		AntiReport.TextScaled = true
		AntiReport.TextSize = 14.000
		AntiReport.TextWrapped = true

		UICorner_29.Parent = AntiReport

		Shadow_2.Name = "Shadow"
		Shadow_2.Parent = AntiReport
		Shadow_2.BackgroundColor3 = Color3.fromRGB(58, 118, 86)
		Shadow_2.BorderSizePixel = 0
		Shadow_2.Size = UDim2.new(1, 0, 1, 4)

		UICorner_30.Parent = Shadow_2

		TextLabel_2.Parent = AntiReport
		TextLabel_2.AnchorPoint = Vector2.new(0.5, 0.5)
		TextLabel_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel_2.BackgroundTransparency = 1.000
		TextLabel_2.BorderColor3 = Color3.fromRGB(27, 42, 53)
		TextLabel_2.BorderSizePixel = 0
		TextLabel_2.Position = UDim2.new(0.5, 0, 0.5, 0)
		TextLabel_2.Size = UDim2.new(1, -20, 1, -20)
		TextLabel_2.ZIndex 
